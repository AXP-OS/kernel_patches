From 6cfcc1c582a565f5360f7a3977f4a8f42d5245cd Mon Sep 17 00:00:00 2001
From: Sridhar Ancha <sancha@codeaurora.org>
Date: Fri, 9 Sep 2016 21:49:22 +0530
Subject: CVE-2016-3706: getaddrinfo: stack overflow in hostent conversion [BZ
 #20010]

Change-Id: Ib614b7365a341eb47191b4299feb0008a7d0ebb4
(cherry picked from commit 0c82ab38064baaf25169d75ddccaa3926b62c7e3)
---
 recipes/eglibc/eglibc-2.17/CVE-2016-3706.patch | 167 +++++++++++++++++++++++++
 recipes/eglibc/eglibc_2.17.bbappend            |   1 +
 2 files changed, 168 insertions(+)
 create mode 100755 recipes/eglibc/eglibc-2.17/CVE-2016-3706.patch

diff --git a/recipes/eglibc/eglibc-2.17/CVE-2016-3706.patch b/recipes/eglibc/eglibc-2.17/CVE-2016-3706.patch
new file mode 100755
index 0000000..7a29fdd
--- /dev/null
+++ b/recipes/eglibc/eglibc-2.17/CVE-2016-3706.patch
@@ -0,0 +1,167 @@
+diff -aruN old/sysdeps/posix/getaddrinfo.c new/sysdeps/posix/getaddrinfo.c
+--- a/sysdeps/posix/getaddrinfo.c	2012-12-03 02:41:45.000000000 +0530
++++ b/sysdeps/posix/getaddrinfo.c	2016-09-09 20:18:58.194205415 +0530
+@@ -182,9 +182,58 @@
+   return 0;
+ }
+ 
++/* Convert struct hostent to a list of struct gaih_addrtuple objects.
++   h_name is not copied, and the struct hostent object must not be
++   deallocated prematurely.  *RESULT must be NULL or a pointer to an
++   object allocated using malloc, which is freed.  */
++static bool
++convert_hostent_to_gaih_addrtuple (const struct addrinfo *req,
++				   int family,
++				   struct hostent *h,
++				   struct gaih_addrtuple **result)
++{
++  free (*result);
++  *result = NULL;
++
++  /* Count the number of addresses in h->h_addr_list.  */
++  size_t count = 0;
++  for (char **p = h->h_addr_list; *p != NULL; ++p)
++    ++count;
++
++  /* Report no data if no addresses are available, or if the incoming
++     address size is larger than what we can store.  */
++  if (count == 0 || h->h_length > sizeof (((struct gaih_addrtuple) {}).addr))
++    return true;
++
++  struct gaih_addrtuple *array = calloc (count, sizeof (*array));
++  if (array == NULL)
++    return false;
++
++  for (size_t i = 0; i < count; ++i)
++    {
++      if (family == AF_INET && req->ai_family == AF_INET6)
++	{
++	  /* Perform address mapping. */
++	  array[i].family = AF_INET6;
++	  memcpy(array[i].addr + 3, h->h_addr_list[i], sizeof (uint32_t));
++	  array[i].addr[2] = htonl (0xffff);
++	}
++      else
++	{
++	  array[i].family = family;
++	  memcpy (array[i].addr, h->h_addr_list[i], h->h_length);
++	}
++      array[i].next = array + i + 1;
++    }
++  array[0].name = h->h_name;
++  array[count - 1].next = NULL;
++
++  *result = array;
++  return true;
++}
++
+ #define gethosts(_family, _type) \
+  {									      \
+-  int i;								      \
+   int herrno;								      \
+   struct hostent th;							      \
+   struct hostent *h;							      \
+@@ -216,37 +265,24 @@
+ 	no_data = herrno == NO_DATA;					      \
+     }									      \
+   else if (h != NULL)							      \
+-    {									      \
+-      for (i = 0; h->h_addr_list[i]; i++)				      \
++    {									      \	
++      /* Make sure that addrmem can be freed.  */			      \
++      if (!malloc_addrmem)						      \
++	addrmem = NULL;							      \
++      if (!convert_hostent_to_gaih_addrtuple (req, _family,h, &addrmem))      \								      
+ 	{								      \
+-	  if (*pat == NULL)						      \
+-	    {								      \
+-	      *pat = __alloca (sizeof (struct gaih_addrtuple));		      \
+-	      (*pat)->scopeid = 0;					      \
+-	    }								      \
+-	  uint32_t *addr = (*pat)->addr;				      \
+-	  (*pat)->next = NULL;						      \
+-	  (*pat)->name = i == 0 ? strdupa (h->h_name) : NULL;		      \
+-	  if (_family == AF_INET && req->ai_family == AF_INET6)		      \
+-	    {								      \
+-	      (*pat)->family = AF_INET6;				      \
+-	      addr[3] = *(uint32_t *) h->h_addr_list[i];		      \
+-	      addr[2] = htonl (0xffff);					      \
+-	      addr[1] = 0;						      \
+-	      addr[0] = 0;						      \
+-	    }								      \
+-	  else								      \
+-	    {								      \
+-	      (*pat)->family = _family;					      \
+-	      memcpy (addr, h->h_addr_list[i], sizeof(_type));		      \
+-	    }								      \
+-	  pat = &((*pat)->next);					      \
++	  _res.options |= old_res_options & RES_USE_INET6;		      \
++	  result = -EAI_SYSTEM;						      \
++	  goto free_and_return;						      \								      
+ 	}								      \
++      *pat = addrmem;							      \
++      /* The conversion uses malloc unconditionally.  */		      \
++      malloc_addrmem = true;						      \								      
+ 									      \
+       if (localcanon !=	NULL && canon == NULL)				      \
+ 	canon = strdupa (localcanon);					      \
+-									      \
+-      if (_family == AF_INET6 && i > 0)					      \
++									      \	
++      if (_family == AF_INET6 && *pat != NULL)				      \								      
+ 	got_ipv6 = true;						      \
+     }									      \
+  }
+@@ -609,44 +645,16 @@
+ 		{
+ 		  if (h != NULL)
+ 		    {
+-		      int i;
+-		      /* We found data, count the number of addresses.  */
+-		      for (i = 0; h->h_addr_list[i]; ++i)
+-			;
+-		      if (i > 0 && *pat != NULL)
+-			--i;
+-
+-		      if (__libc_use_alloca (alloca_used
+-					     + i * sizeof (struct gaih_addrtuple)))
+-			addrmem = alloca_account (i * sizeof (struct gaih_addrtuple),
+-						  alloca_used);
+-		      else
++		      /* We found data, convert it.  */
++		      if (!convert_hostent_to_gaih_addrtuple
++			  (req, AF_INET, h, &addrmem))
+ 			{
+-			  addrmem = malloc (i
+-					    * sizeof (struct gaih_addrtuple));
+-			  if (addrmem == NULL)
+-			    {
+-			      result = -EAI_MEMORY;
+-			      goto free_and_return;
+-			    }
+-			  malloc_addrmem = true;
+-			}
+-
+-		      /* Now convert it into the list.  */
+-		      struct gaih_addrtuple *addrfree = addrmem;
+-		      for (i = 0; h->h_addr_list[i]; ++i)
+-			{
+-			  if (*pat == NULL)
+-			    {
+-			      *pat = addrfree++;
+-			      (*pat)->scopeid = 0;
+-			    }
+-			  (*pat)->next = NULL;
+-			  (*pat)->family = AF_INET;
+-			  memcpy ((*pat)->addr, h->h_addr_list[i],
+-				  h->h_length);
+-			  pat = &((*pat)->next);
++			  result = -EAI_MEMORY;
++			  goto free_and_return;
+ 			}
++		      *pat = addrmem;
++		      /* The conversion uses malloc unconditionally.  */
++		      malloc_addrmem = true;
+ 		    }
+ 		}
+ 	      else
diff --git a/recipes/eglibc/eglibc_2.17.bbappend b/recipes/eglibc/eglibc_2.17.bbappend
index c837220..1c5cfd4 100644
--- a/recipes/eglibc/eglibc_2.17.bbappend
+++ b/recipes/eglibc/eglibc_2.17.bbappend
@@ -2,4 +2,5 @@ FILESEXTRAPATHS := "${THISDIR}/${PN}-${PV}"
 SRC_URI += "\
     file://CVE-2015-7547.patch \
     file://CVE-2016-4429.patch \
+    file://CVE-2016-3706.patch \
 "
-- 
cgit v1.1

