From 6dcf02f190a20a9e0a219ad0a883fc31129caa9c Mon Sep 17 00:00:00 2001
From: Gidon Studinski <gidons@codeaurora.org>
Date: Mon, 23 Jan 2017 11:55:53 +0200
Subject: ecm_ipa: remove redundant code

Remove ECM_IPA debugging capabilities which are no longer needed, nor used.

CRs-Fixed: 1112912
Change-Id: I20765d84ca7351c436d39d0f10b7f7a819bcc40b
Signed-off-by: Gidon Studinski <gidons@codeaurora.org>
---
 drivers/net/ethernet/msm/ecm_ipa.c | 268 +------------------------------------
 1 file changed, 3 insertions(+), 265 deletions(-)

diff --git a/drivers/net/ethernet/msm/ecm_ipa.c b/drivers/net/ethernet/msm/ecm_ipa.c
index 77490c3..80ea7ef 100644
--- a/drivers/net/ethernet/msm/ecm_ipa.c
+++ b/drivers/net/ethernet/msm/ecm_ipa.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -9,7 +9,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-
 #include <linux/debugfs.h>
 #include <linux/errno.h>
 #include <linux/etherdevice.h>
@@ -106,10 +105,6 @@ enum ecm_ipa_operation {
  * struct ecm_ipa_dev - main driver context parameters
  * @net: network interface struct implemented by this driver
  * @directory: debugfs directory for various debuging switches
- * @tx_enable: flag that enable/disable Tx path to continue to IPA
- * @rx_enable: flag that enable/disable Rx path to continue to IPA
- * @rm_enable: flag that enable/disable Resource manager request prior to Tx
- * @dma_enable: flag that allow on-the-fly DMA mode for IPA
  * @eth_ipv4_hdr_hdl: saved handle for ipv4 header-insertion table
  * @eth_ipv6_hdr_hdl: saved handle for ipv6 header-insertion table
  * @usb_to_ipa_hdl: save handle for IPA pipe operations
@@ -129,10 +124,6 @@ enum ecm_ipa_operation {
  */
 struct ecm_ipa_dev {
 	struct net_device *net;
-	u32 tx_enable;
-	u32 rx_enable;
-	u32  rm_enable;
-	bool dma_enable;
 	struct dentry *directory;
 	uint32_t eth_ipv4_hdr_hdl;
 	uint32_t eth_ipv6_hdr_hdl;
@@ -167,32 +158,16 @@ static void ecm_ipa_rm_notify(void *user_data, enum ipa_rm_event event,
 static struct net_device_stats *ecm_ipa_get_stats(struct net_device *net);
 static int ecm_ipa_create_rm_resource(struct ecm_ipa_dev *ecm_ipa_ctx);
 static void ecm_ipa_destory_rm_resource(struct ecm_ipa_dev *ecm_ipa_ctx);
-static bool rx_filter(struct sk_buff *skb);
-static bool tx_filter(struct sk_buff *skb);
-static bool rm_enabled(struct ecm_ipa_dev *ecm_ipa_ctx);
 static int resource_request(struct ecm_ipa_dev *ecm_ipa_ctx);
 static void resource_release(struct ecm_ipa_dev *ecm_ipa_ctx);
 static netdev_tx_t ecm_ipa_start_xmit(struct sk_buff *skb,
 					struct net_device *net);
-static int ecm_ipa_debugfs_stall_open(struct inode *inode,
-	struct file *file);
-static ssize_t ecm_ipa_debugfs_stall_write(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos);
 static int ecm_ipa_debugfs_atomic_open(struct inode *inode, struct file *file);
-static ssize_t ecm_ipa_debugfs_enable_write_dma(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos);
-static int ecm_ipa_debugfs_dma_open(struct inode *inode, struct file *file);
-static ssize_t ecm_ipa_debugfs_enable_write(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos);
-static ssize_t ecm_ipa_debugfs_enable_read(struct file *file,
-		char __user *ubuf, size_t count, loff_t *ppos);
 static ssize_t ecm_ipa_debugfs_atomic_read(struct file *file,
 		char __user *ubuf, size_t count, loff_t *ppos);
 static void ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx);
 static void ecm_ipa_debugfs_destroy(struct ecm_ipa_dev *ecm_ipa_ctx);
 static int ecm_ipa_ep_registers_cfg(u32 usb_to_ipa_hdl, u32 ipa_to_usb_hdl);
-static int ecm_ipa_ep_registers_dma_cfg(u32 usb_to_ipa_hdl,
-					enum ipa_client_type prod_client);
 static int ecm_ipa_set_device_ethernet_addr(u8 *dev_ethaddr,
 		u8 device_ethaddr[]);
 static enum ecm_ipa_state ecm_ipa_next_state(enum ecm_ipa_state current_state,
@@ -210,22 +185,11 @@ static const struct net_device_ops ecm_ipa_netdev_ops = {
 	.ndo_get_stats = ecm_ipa_get_stats,
 };
 
-const struct file_operations ecm_ipa_debugfs_dma_ops = {
-	.open = ecm_ipa_debugfs_dma_open,
-	.read = ecm_ipa_debugfs_enable_read,
-	.write = ecm_ipa_debugfs_enable_write_dma,
-};
-
 const struct file_operations ecm_ipa_debugfs_atomic_ops = {
 	.open = ecm_ipa_debugfs_atomic_open,
 	.read = ecm_ipa_debugfs_atomic_read,
 };
 
-const struct file_operations ecm_ipa_debugfs_stall_ops = {
-	.open = ecm_ipa_debugfs_stall_open,
-	.write = ecm_ipa_debugfs_stall_write,
-};
-
 static void ecm_ipa_msg_free_cb(void *buff, u32 len, u32 type)
 {
 	kfree(buff);
@@ -286,9 +250,6 @@ int ecm_ipa_init(struct ecm_ipa_params *params)
 	ECM_IPA_DEBUG("ecm_ipa_ctx (private) = %p\n", ecm_ipa_ctx);
 
 	ecm_ipa_ctx->net = net;
-	ecm_ipa_ctx->tx_enable = true;
-	ecm_ipa_ctx->rx_enable = true;
-	ecm_ipa_ctx->rm_enable = true;
 	ecm_ipa_ctx->outstanding_high = DEFAULT_OUTSTANDING_HIGH;
 	ecm_ipa_ctx->outstanding_low = DEFAULT_OUTSTANDING_LOW;
 	atomic_set(&ecm_ipa_ctx->outstanding_pkts, 0);
@@ -600,12 +561,6 @@ static netdev_tx_t ecm_ipa_start_xmit(struct sk_buff *skb,
 		return NETDEV_TX_BUSY;
 	}
 
-	if (unlikely(tx_filter(skb))) {
-		dev_kfree_skb_any(skb);
-		ECM_IPA_DEBUG("packet got filtered out on Tx path\n");
-		status = NETDEV_TX_OK;
-		goto out;
-	}
 	ret = resource_request(ecm_ipa_ctx);
 	if (ret) {
 		ECM_IPA_DEBUG("Waiting to resource\n");
@@ -679,11 +634,6 @@ static void ecm_ipa_packet_receive_notify(void *priv,
 
 	skb->dev = ecm_ipa_ctx->net;
 	skb->protocol = eth_type_trans(skb, ecm_ipa_ctx->net);
-	if (rx_filter(skb)) {
-		ECM_IPA_DEBUG("packet got filtered out on Rx path\n");
-		dev_kfree_skb_any(skb);
-		return;
-	}
 
 	result = netif_rx(skb);
 	if (result)
@@ -1146,42 +1096,15 @@ static void ecm_ipa_destory_rm_resource(struct ecm_ipa_dev *ecm_ipa_ctx)
 	ECM_IPA_LOG_EXIT();
 }
 
-static bool rx_filter(struct sk_buff *skb)
-{
-	struct ecm_ipa_dev *ecm_ipa_ctx = netdev_priv(skb->dev);
-	return !ecm_ipa_ctx->rx_enable;
-}
-
-static bool tx_filter(struct sk_buff *skb)
-{
-	struct ecm_ipa_dev *ecm_ipa_ctx = netdev_priv(skb->dev);
-	return !ecm_ipa_ctx->tx_enable;
-}
-
-static bool rm_enabled(struct ecm_ipa_dev *ecm_ipa_ctx)
-{
-	return ecm_ipa_ctx->rm_enable;
-}
-
 static int resource_request(struct ecm_ipa_dev *ecm_ipa_ctx)
 {
-	int result = 0;
-
-	if (!rm_enabled(ecm_ipa_ctx))
-		goto out;
-	result = ipa_rm_inactivity_timer_request_resource(
-			IPA_RM_RESOURCE_STD_ECM_PROD);
-out:
-	return result;
+	return ipa_rm_inactivity_timer_request_resource(
+		IPA_RM_RESOURCE_STD_ECM_PROD);
 }
 
 static void resource_release(struct ecm_ipa_dev *ecm_ipa_ctx)
 {
-	if (!rm_enabled(ecm_ipa_ctx))
-		goto out;
 	ipa_rm_inactivity_timer_release_resource(IPA_RM_RESOURCE_STD_ECM_PROD);
-out:
-	return;
 }
 
 /**
@@ -1254,45 +1177,6 @@ static void ecm_ipa_tx_timeout(struct net_device *net)
 	net->stats.tx_errors++;
 }
 
-static int ecm_ipa_debugfs_stall_open(struct inode *inode,
-	struct file *file)
-{
-	ECM_IPA_LOG_ENTRY();
-
-	ECM_IPA_LOG_EXIT();
-
-	return 0;
-}
-
-static ssize_t ecm_ipa_debugfs_stall_write(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos)
-{
-	u32 cmdq_cfg_mmio_phy = 0xFD4E3038;
-	void *cmdq_cfg_mmio_virt;
-	int result;
-	bool val = 0;
-
-	ECM_IPA_LOG_ENTRY();
-
-	file->private_data = &val;
-	result = ecm_ipa_debugfs_enable_write(file, buf, count, ppos);
-
-	cmdq_cfg_mmio_virt = ioremap(cmdq_cfg_mmio_phy, sizeof(u32));
-	if (!cmdq_cfg_mmio_virt) {
-		ECM_IPA_ERROR("fail on mmio for cmdq_cfg_mmio_phy=0x%x",
-			cmdq_cfg_mmio_phy);
-		return result;
-	}
-
-	iowrite32(val, cmdq_cfg_mmio_virt);
-	ECM_IPA_DEBUG("Value %d was written to cfgq", val);
-
-	ECM_IPA_LOG_EXIT();
-
-	return result;
-
-}
-
 static int ecm_ipa_debugfs_atomic_open(struct inode *inode, struct file *file)
 {
 	struct ecm_ipa_dev *ecm_ipa_ctx = inode->i_private;
@@ -1302,78 +1186,6 @@ static int ecm_ipa_debugfs_atomic_open(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static ssize_t ecm_ipa_debugfs_enable_write_dma(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos)
-{
-	struct ecm_ipa_dev *ecm_ipa_ctx = file->private_data;
-	int result;
-	ECM_IPA_LOG_ENTRY();
-	file->private_data = &ecm_ipa_ctx->dma_enable;
-	result = ecm_ipa_debugfs_enable_write(file, buf, count, ppos);
-	if (ecm_ipa_ctx->dma_enable)
-		ecm_ipa_ep_registers_dma_cfg(ecm_ipa_ctx->usb_to_ipa_hdl,
-					     ecm_ipa_ctx->ipa_to_usb_client);
-	else
-		ecm_ipa_ep_registers_cfg(ecm_ipa_ctx->usb_to_ipa_hdl,
-				ecm_ipa_ctx->usb_to_ipa_hdl);
-	ECM_IPA_LOG_EXIT();
-	return result;
-}
-
-static int ecm_ipa_debugfs_dma_open(struct inode *inode, struct file *file)
-{
-	struct ecm_ipa_dev *ecm_ipa_ctx = inode->i_private;
-	ECM_IPA_LOG_ENTRY();
-	file->private_data = ecm_ipa_ctx;
-	ECM_IPA_LOG_EXIT();
-	return 0;
-}
-
-static ssize_t ecm_ipa_debugfs_enable_write(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos)
-{
-	unsigned long missing;
-	char input;
-	bool *enable = file->private_data;
-	if (count != sizeof(input) + 1) {
-		ECM_IPA_ERROR("wrong input length(%zd)\n", count);
-		return -EINVAL;
-	}
-	if (!buf) {
-		ECM_IPA_ERROR("Bad argument\n");
-		return -EINVAL;
-	}
-	missing = copy_from_user(&input, buf, 1);
-	if (missing)
-		return -EFAULT;
-	ECM_IPA_DEBUG("input received %c\n", input);
-	*enable = input - '0';
-	ECM_IPA_DEBUG("value was set to %d\n", *enable);
-	return count;
-}
-
-static ssize_t ecm_ipa_debugfs_enable_read(struct file *file,
-		char __user *ubuf, size_t count, loff_t *ppos)
-{
-	int nbytes;
-	int size = 0;
-	int ret;
-	loff_t pos;
-	u8 enable_str[sizeof(char)*3] = {0};
-	bool *enable = file->private_data;
-	pos = *ppos;
-	nbytes = scnprintf(enable_str, sizeof(enable_str), "%d\n", *enable);
-	ret = simple_read_from_buffer(ubuf, count, ppos, enable_str, nbytes);
-	if (ret < 0) {
-		ECM_IPA_ERROR("simple_read_from_buffer problem\n");
-		return ret;
-	}
-	size += ret;
-	count -= nbytes;
-	*ppos = pos + size;
-	return size;
-}
-
 static ssize_t ecm_ipa_debugfs_atomic_read(struct file *file,
 		char __user *ubuf, size_t count, loff_t *ppos)
 {
@@ -1391,7 +1203,6 @@ static void ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx)
 {
 	const mode_t flags_read_write = S_IRUGO | S_IWUGO;
 	const mode_t flags_read_only = S_IRUGO;
-	const mode_t flags_write_only = S_IWUGO;
 	struct dentry *file;
 
 	ECM_IPA_LOG_ENTRY();
@@ -1404,24 +1215,6 @@ static void ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx)
 		ECM_IPA_ERROR("could not create debugfs directory entry\n");
 		goto fail_directory;
 	}
-	file = debugfs_create_bool("tx_enable", flags_read_write,
-			ecm_ipa_ctx->directory, &ecm_ipa_ctx->tx_enable);
-	if (!file) {
-		ECM_IPA_ERROR("could not create debugfs tx file\n");
-		goto fail_file;
-	}
-	file = debugfs_create_bool("rx_enable", flags_read_write,
-			ecm_ipa_ctx->directory, &ecm_ipa_ctx->rx_enable);
-	if (!file) {
-		ECM_IPA_ERROR("could not create debugfs rx file\n");
-		goto fail_file;
-	}
-	file = debugfs_create_bool("rm_enable", flags_read_write,
-			ecm_ipa_ctx->directory, &ecm_ipa_ctx->rm_enable);
-	if (!file) {
-		ECM_IPA_ERROR("could not create debugfs rm file\n");
-		goto fail_file;
-	}
 	file = debugfs_create_u8("outstanding_high", flags_read_write,
 			ecm_ipa_ctx->directory, &ecm_ipa_ctx->outstanding_high);
 	if (!file) {
@@ -1434,13 +1227,6 @@ static void ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx)
 		ECM_IPA_ERROR("could not create outstanding_low file\n");
 		goto fail_file;
 	}
-	file = debugfs_create_file("dma_enable", flags_read_write,
-			ecm_ipa_ctx->directory,
-			ecm_ipa_ctx, &ecm_ipa_debugfs_dma_ops);
-	if (!file) {
-		ECM_IPA_ERROR("could not create debugfs dma file\n");
-		goto fail_file;
-	}
 	file = debugfs_create_file("outstanding", flags_read_only,
 			ecm_ipa_ctx->directory,
 			ecm_ipa_ctx, &ecm_ipa_debugfs_atomic_ops);
@@ -1449,14 +1235,6 @@ static void ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx)
 		goto fail_file;
 	}
 
-	file = debugfs_create_file("stall_ipa_rx_proc", flags_write_only,
-			ecm_ipa_ctx->directory,
-			ecm_ipa_ctx, &ecm_ipa_debugfs_stall_ops);
-	if (!file) {
-		ECM_IPA_ERROR("could not create stall_ipa_rx_proc file\n");
-		goto fail_file;
-	}
-
 	ECM_IPA_DEBUG("debugfs entries were created\n");
 	ECM_IPA_LOG_EXIT();
 
@@ -1528,46 +1306,6 @@ out:
 }
 
 /**
- * ecm_ipa_ep_registers_dma_cfg() - configure the USB endpoints for ECM
- *	DMA
- * @usb_to_ipa_hdl: handle received from ipa_connect
- *
- * This function will override the previous configuration
- * which is needed for cores that does not support blocks logic
- * Note that client handles are the actual pipe index
- */
-static int ecm_ipa_ep_registers_dma_cfg(u32 usb_to_ipa_hdl,
-					enum ipa_client_type prod_client)
-{
-	int result = 0;
-	struct ipa_ep_cfg_mode cfg_mode;
-	u32 apps_to_ipa_hdl = 2;
-
-	ECM_IPA_LOG_ENTRY();
-
-	memset(&cfg_mode, 0 , sizeof(cfg_mode));
-	cfg_mode.mode = IPA_DMA;
-	cfg_mode.dst = prod_client;
-	result = ipa_cfg_ep_mode(apps_to_ipa_hdl, &cfg_mode);
-	if (result) {
-		ECM_IPA_ERROR("failed to configure Apps to IPA\n");
-		goto out;
-	}
-	memset(&cfg_mode, 0 , sizeof(cfg_mode));
-	cfg_mode.mode = IPA_DMA;
-	cfg_mode.dst = IPA_CLIENT_A5_LAN_WAN_CONS;
-	result = ipa_cfg_ep_mode(usb_to_ipa_hdl, &cfg_mode);
-	if (result) {
-		ECM_IPA_ERROR("failed to configure USB to IPA\n");
-		goto out;
-	}
-	ECM_IPA_DEBUG("end-point registers successfully configured\n");
-out:
-	ECM_IPA_LOG_EXIT();
-	return result;
-}
-
-/**
  * ecm_ipa_set_device_ethernet_addr() - set device etherenet address
  * @dev_ethaddr: device etherenet address
  *
-- 
cgit v1.1

