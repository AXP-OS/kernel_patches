From f2ba68242d79016cc07b59aa41a67b7a1d36bf9b Mon Sep 17 00:00:00 2001
From: Abhijit Kulkarni <kabhijit@codeaurora.org>
Date: Mon, 12 Sep 2016 12:41:53 -0700
Subject: msm: mdss: hide kernel addresses from unprevileged users

for printing kernel pointers which should be hidden from unprivileged
users, use %pK which evaluates whether kptr_restrict is set.

CRs-Fixed: 987021
Change-Id: Ie49eee9478f4657cfb2a994ba60da1ec4c356339
Signed-off-by: Abhijit Kulkarni <kabhijit@codeaurora.org>
---
 drivers/video/msm/mdss/mdp3.c                     | 16 ++---
 drivers/video/msm/mdss/mdp3_ppp_hwio.c            |  6 +-
 drivers/video/msm/mdss/mdss_compat_utils.c        | 18 ++---
 drivers/video/msm/mdss/mdss_debug.c               |  4 +-
 drivers/video/msm/mdss/mdss_debug_xlog.c          | 14 ++--
 drivers/video/msm/mdss/mdss_dsi.c                 | 28 ++++----
 drivers/video/msm/mdss/mdss_dsi_clk.c             |  6 +-
 drivers/video/msm/mdss/mdss_dsi_host.c            |  2 +-
 drivers/video/msm/mdss/mdss_dsi_panel.c           | 10 +--
 drivers/video/msm/mdss/mdss_fb.c                  | 12 ++--
 drivers/video/msm/mdss/mdss_hdmi_tx.c             |  6 +-
 drivers/video/msm/mdss/mdss_mdp.c                 | 12 ++--
 drivers/video/msm/mdss/mdss_mdp_intf_cmd.c        |  6 +-
 drivers/video/msm/mdss/mdss_mdp_intf_video.c      | 10 +--
 drivers/video/msm/mdss/mdss_mdp_layer.c           |  4 +-
 drivers/video/msm/mdss/mdss_mdp_overlay.c         | 10 +--
 drivers/video/msm/mdss/mdss_mdp_pipe.c            |  4 +-
 drivers/video/msm/mdss/mdss_mdp_pp.c              | 70 +++++++++----------
 drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c | 66 +++++++++---------
 drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c         | 82 +++++++++++------------
 drivers/video/msm/mdss/mdss_mdp_rotator.c         |  6 +-
 drivers/video/msm/mdss/mdss_mdp_util.c            |  9 +--
 drivers/video/msm/mdss/mdss_mdp_wb.c              | 10 +--
 drivers/video/msm/mdss/mdss_util.c                |  2 +-
 drivers/video/msm/mdss/mhl3/mhl_linux_tx.c        |  4 +-
 drivers/video/msm/mdss/mhl3/mhl_supp.c            | 14 ++--
 drivers/video/msm/mdss/mhl3/platform.c            |  8 +--
 drivers/video/msm/mdss/mhl3/si_8620_drv.c         |  4 +-
 drivers/video/msm/mdss/mhl3/si_emsc_hid.c         |  8 +--
 drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c     | 27 ++++----
 drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c     | 27 ++++----
 31 files changed, 253 insertions(+), 252 deletions(-)

diff --git a/drivers/video/msm/mdss/mdp3.c b/drivers/video/msm/mdss/mdp3.c
index 88e34c3..b5deef6 100644
--- a/drivers/video/msm/mdss/mdp3.c
+++ b/drivers/video/msm/mdss/mdp3.c
@@ -1135,7 +1135,7 @@ static int mdp3_res_init(void)
 
 	mdp3_res->ion_client = msm_ion_client_create(mdp3_res->pdev->name);
 	if (IS_ERR_OR_NULL(mdp3_res->ion_client)) {
-		pr_err("msm_ion_client_create() return error (%p)\n",
+		pr_err("msm_ion_client_create() return error (%pK)\n",
 				mdp3_res->ion_client);
 		mdp3_res->ion_client = NULL;
 		return -EINVAL;
@@ -1565,7 +1565,7 @@ void mdp3_unmap_iommu(struct ion_client *client, struct ion_handle *handle)
 	mutex_lock(&mdp3_res->iommu_lock);
 	meta = mdp3_iommu_meta_lookup(table);
 	if (!meta) {
-		WARN(1, "%s: buffer was never mapped for %p\n", __func__,
+		WARN(1, "%s: buffer was never mapped for %pK\n", __func__,
 				handle);
 		mutex_unlock(&mdp3_res->iommu_lock);
 		return;
@@ -1591,7 +1591,7 @@ static void mdp3_iommu_meta_add(struct mdp3_iommu_meta *meta)
 		} else if (meta->table > entry->table) {
 			p = &(*p)->rb_right;
 		} else {
-			pr_err("%s: handle %p already exists\n", __func__,
+			pr_err("%s: handle %pK already exists\n", __func__,
 				entry->handle);
 			BUG();
 		}
@@ -1654,7 +1654,7 @@ static int mdp3_iommu_map_iommu(struct mdp3_iommu_meta *meta,
 	ret = iommu_map_range(domain, meta->iova_addr + padding,
 			table->sgl, size, prot);
 	if (ret) {
-		pr_err("%s: could not map %pa in domain %p\n",
+		pr_err("%s: could not map %pa in domain %pK\n",
 			__func__, &meta->iova_addr, domain);
 			unmap_size = padding;
 		goto out2;
@@ -1777,12 +1777,12 @@ int mdp3_self_map_iommu(struct ion_client *client, struct ion_handle *handle,
 		}
 	} else {
 		if (iommu_meta->flags != iommu_flags) {
-			pr_err("%s: hndl %p already mapped with diff flag\n",
+			pr_err("%s: hndl %pK already mapped with diff flag\n",
 				__func__, handle);
 			ret = -EINVAL;
 			goto out_unlock;
 		} else if (iommu_meta->mapped_size != iova_length) {
-			pr_err("%s: hndl %p already mapped with diff len\n",
+			pr_err("%s: hndl %pK already mapped with diff len\n",
 				__func__, handle);
 			ret = -EINVAL;
 			goto out_unlock;
@@ -1816,7 +1816,7 @@ int mdp3_put_img(struct mdp3_img_data *data, int client)
 		fdput(data->srcp_f);
 		memset(&data->srcp_f, 0, sizeof(struct fd));
 	} else if (!IS_ERR_OR_NULL(data->srcp_dma_buf)) {
-		pr_debug("ion hdl = %p buf=0x%pa\n", data->srcp_dma_buf,
+		pr_debug("ion hdl = %pK buf=0x%pa\n", data->srcp_dma_buf,
 							&data->addr);
 		if (!iclient) {
 			pr_err("invalid ion client\n");
@@ -1919,7 +1919,7 @@ done:
 		data->addr += img->offset;
 		data->len -= img->offset;
 
-		pr_debug("mem=%d ihdl=%p buf=0x%pa len=0x%lx\n",
+		pr_debug("mem=%d ihdl=%pK buf=0x%pa len=0x%lx\n",
 			img->memory_id, data->srcp_dma_buf,
 			&data->addr, data->len);
 
diff --git a/drivers/video/msm/mdss/mdp3_ppp_hwio.c b/drivers/video/msm/mdss/mdp3_ppp_hwio.c
index e14abd0..907063c 100644
--- a/drivers/video/msm/mdss/mdp3_ppp_hwio.c
+++ b/drivers/video/msm/mdss/mdp3_ppp_hwio.c
@@ -1308,7 +1308,7 @@ int config_ppp_op_mode(struct ppp_blit_op *blit_op)
 	pr_debug("ROI(x %d,y %d,w %d, h %d) ",
 		blit_op->src.roi.x, blit_op->src.roi.y,
 		blit_op->src.roi.width, blit_op->src.roi.height);
-	pr_debug("Addr_P0 %p, Stride S0 %d Addr_P1 %p, Stride S1 %d\n",
+	pr_debug("Addr_P0 %pK, Stride S0 %d Addr_P1 %pK, Stride S1 %d\n",
 		blit_op->src.p0, blit_op->src.stride0,
 		blit_op->src.p1, blit_op->src.stride1);
 
@@ -1320,7 +1320,7 @@ int config_ppp_op_mode(struct ppp_blit_op *blit_op)
 		pr_debug("ROI(x %d,y %d, w  %d, h %d) ",
 			blit_op->bg.roi.x, blit_op->bg.roi.y,
 			blit_op->bg.roi.width, blit_op->bg.roi.height);
-		pr_debug("Addr %p, Stride S0 %d	Addr_P1 %p, Stride S1 %d\n",
+		pr_debug("Addr %pK, Stride S0 %d Addr_P1 %pK, Stride S1 %d\n",
 			blit_op->bg.p0,	blit_op->bg.stride0,
 			blit_op->bg.p1,	blit_op->bg.stride1);
 	}
@@ -1331,7 +1331,7 @@ int config_ppp_op_mode(struct ppp_blit_op *blit_op)
 	pr_debug("ROI(x %d,y %d, w %d, h %d) ",
 		blit_op->dst.roi.x, blit_op->dst.roi.y,
 		blit_op->dst.roi.width, blit_op->dst.roi.height);
-	pr_debug("Addr %p, Stride S0 %d Addr_P1 %p, Stride S1 %d\n",
+	pr_debug("Addr %pK, Stride S0 %d Addr_P1 %pK, Stride S1 %d\n",
 		blit_op->dst.p0, blit_op->dst.stride0,
 		blit_op->dst.p1, blit_op->dst.stride1);
 
diff --git a/drivers/video/msm/mdss/mdss_compat_utils.c b/drivers/video/msm/mdss/mdss_compat_utils.c
index e883f045..5ad51dd 100644
--- a/drivers/video/msm/mdss/mdss_compat_utils.c
+++ b/drivers/video/msm/mdss/mdss_compat_utils.c
@@ -150,7 +150,7 @@ static struct mdp_input_layer32 *__create_layer_list32(
 			compat_ptr(commit32->commit_v1.input_layers),
 			sizeof(struct mdp_input_layer32) * layer_count);
 	if (ret) {
-		pr_err("layer list32 copy from user failed, ptr %p\n",
+		pr_err("layer list32 copy from user failed, ptr %pK\n",
 			compat_ptr(commit32->commit_v1.input_layers));
 		kfree(layer_list32);
 		ret = -EFAULT;
@@ -182,7 +182,7 @@ static int __copy_scale_params(struct mdp_input_layer *layer,
 			sizeof(struct mdp_scale_data));
 	if (ret) {
 		kfree(scale);
-		pr_err("scale param copy from user failed, ptr %p\n",
+		pr_err("scale param copy from user failed, ptr %pK\n",
 			compat_ptr(layer32->scale));
 		ret = -EFAULT;
 	} else {
@@ -307,7 +307,7 @@ static int __compat_atomic_commit(struct fb_info *info, unsigned int cmd,
 	ret = copy_from_user(&commit32, (void __user *)argp,
 		sizeof(struct mdp_layer_commit32));
 	if (ret) {
-		pr_err("%s:copy_from_user failed, ptr %p\n", __func__,
+		pr_err("%s:copy_from_user failed, ptr %pK\n", __func__,
 			(void __user *)argp);
 		ret = -EFAULT;
 		return ret;
@@ -325,7 +325,7 @@ static int __compat_atomic_commit(struct fb_info *info, unsigned int cmd,
 				compat_ptr(commit32.commit_v1.output_layer),
 				buffer_size);
 		if (ret) {
-			pr_err("fail to copy output layer from user, ptr %p\n",
+			pr_err("fail to copy output layer from user, ptr %pK\n",
 				compat_ptr(commit32.commit_v1.output_layer));
 			ret = -EFAULT;
 			goto layer_list_err;
@@ -3418,7 +3418,7 @@ static int __copy_layer_igc_lut_data_v1_7(
 			cfg_payload32,
 			sizeof(struct mdp_igc_lut_data_v1_7_32));
 	if (ret) {
-		pr_err("copy from user failed, IGC cfg payload = %p\n",
+		pr_err("copy from user failed, IGC cfg payload = %pK\n",
 			cfg_payload32);
 		ret = -EFAULT;
 		goto exit;
@@ -3493,7 +3493,7 @@ static int __copy_layer_hist_lut_data_v1_7(
 			cfg_payload32,
 			sizeof(struct mdp_hist_lut_data_v1_7_32));
 	if (ret) {
-		pr_err("copy from user failed, hist lut cfg_payload = %p\n",
+		pr_err("copy from user failed, hist lut cfg_payload = %pK\n",
 			cfg_payload32);
 		ret = -EFAULT;
 		goto exit;
@@ -3565,7 +3565,7 @@ static int __copy_layer_pa_data_v1_7(
 			cfg_payload32,
 			sizeof(struct mdp_pa_data_v1_7_32));
 	if (ret) {
-		pr_err("copy from user failed, pa cfg_payload = %p\n",
+		pr_err("copy from user failed, pa cfg_payload = %pK\n",
 			cfg_payload32);
 		ret = -EFAULT;
 		goto exit;
@@ -3707,7 +3707,7 @@ static int __copy_layer_pp_info_pcc_params(
 			compat_ptr(pp_info32->pcc_cfg_data.cfg_payload),
 			sizeof(struct mdp_pcc_data_v1_7));
 		if (ret) {
-			pr_err("compat copy of PCC cfg payload failed, ptr %p\n",
+			pr_err("compat copy of PCC cfg payload failed, ptr %pK\n",
 				compat_ptr(
 				pp_info32->pcc_cfg_data.cfg_payload));
 			ret = -EFAULT;
@@ -3741,7 +3741,7 @@ static int __copy_layer_pp_info_params(struct mdp_input_layer *layer,
 			compat_ptr(layer32->pp_info),
 			sizeof(struct mdp_overlay_pp_params32));
 	if (ret) {
-		pr_err("pp info copy from user failed, pp_info %p\n",
+		pr_err("pp info copy from user failed, pp_info %pK\n",
 			compat_ptr(layer32->pp_info));
 		ret = -EFAULT;
 		goto exit;
diff --git a/drivers/video/msm/mdss/mdss_debug.c b/drivers/video/msm/mdss/mdss_debug.c
index a16063b..a2912e6 100644
--- a/drivers/video/msm/mdss/mdss_debug.c
+++ b/drivers/video/msm/mdss/mdss_debug.c
@@ -1317,7 +1317,7 @@ static inline struct mdss_mdp_misr_map *mdss_misr_get_map(u32 block_id,
 		return NULL;
 	}
 
-	pr_debug("MISR Module(%d) CTRL(0x%x) SIG(0x%x) intf_base(0x%p)\n",
+	pr_debug("MISR Module(%d) CTRL(0x%x) SIG(0x%x) intf_base(0x%pK)\n",
 			block_id, map->ctrl_reg, map->value_reg, intf_base);
 	return map;
 }
@@ -1360,7 +1360,7 @@ int mdss_misr_set(struct mdss_data_type *mdata,
 	bool use_mdp_up_misr = false;
 
 	if (!mdata || !req || !ctl) {
-		pr_err("Invalid input params: mdata = %p req = %p ctl = %p",
+		pr_err("Invalid input params: mdata = %pK req = %pK ctl = %pK",
 			mdata, req, ctl);
 		return -EINVAL;
 	}
diff --git a/drivers/video/msm/mdss/mdss_debug_xlog.c b/drivers/video/msm/mdss/mdss_debug_xlog.c
index c9a4073..795ff55 100644
--- a/drivers/video/msm/mdss/mdss_debug_xlog.c
+++ b/drivers/video/msm/mdss/mdss_debug_xlog.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -253,7 +253,7 @@ static void mdss_dump_debug_bus(u32 bus_dump_flag,
 
 		if (*dump_mem) {
 			dump_addr = *dump_mem;
-			pr_info("%s: start_addr:0x%p end_addr:0x%p\n",
+			pr_info("%s: start_addr:0x%pK end_addr:0x%pK\n",
 				__func__, dump_addr, dump_addr + list_size);
 		} else {
 			in_mem = false;
@@ -371,7 +371,7 @@ static void mdss_dump_vbif_debug_bus(u32 bus_dump_flag,
 
 		if (*dump_mem) {
 			dump_addr = *dump_mem;
-			pr_info("%s: start_addr:0x%p end_addr:0x%p\n",
+			pr_info("%s: start_addr:0x%pK end_addr:0x%pK\n",
 				__func__, dump_addr, dump_addr + list_size);
 		} else {
 			in_mem = false;
@@ -431,7 +431,7 @@ static void mdss_dump_reg(const char *dump_name, u32 reg_dump_flag,
 
 		if (*dump_mem) {
 			dump_addr = *dump_mem;
-			pr_info("%s: start_addr:0x%p end_addr:0x%p reg_addr=0x%p\n",
+			pr_info("%s: start_addr:0x%pK end_addr:0x%pK reg_addr=0x%pK\n",
 				dump_name, dump_addr, dump_addr + (u32)len * 16,
 				addr);
 		} else {
@@ -450,7 +450,7 @@ static void mdss_dump_reg(const char *dump_name, u32 reg_dump_flag,
 		xc = readl_relaxed(addr+0xc);
 
 		if (in_log)
-			pr_info("%p : %08x %08x %08x %08x\n", addr, x0, x4, x8,
+			pr_info("%pK : %08x %08x %08x %08x\n", addr, x0, x4, x8,
 				xc);
 
 		if (dump_addr && in_mem) {
@@ -486,7 +486,7 @@ static void mdss_dump_reg_by_ranges(struct mdss_debug_base *dbg,
 			len = get_dump_range(&xlog_node->offset,
 				dbg->max_offset);
 			addr = dbg->base + xlog_node->offset.start;
-			pr_debug("%s: range_base=0x%p start=0x%x end=0x%x\n",
+			pr_debug("%s: range_base=0x%pK start=0x%x end=0x%x\n",
 				xlog_node->range_name,
 				addr, xlog_node->offset.start,
 				xlog_node->offset.end);
@@ -496,7 +496,7 @@ static void mdss_dump_reg_by_ranges(struct mdss_debug_base *dbg,
 	} else {
 		/* If there is no list to dump ranges, dump all registers */
 		pr_info("Ranges not found, will dump full registers");
-		pr_info("base:0x%p len:0x%zu\n", dbg->base, dbg->max_offset);
+		pr_info("base:0x%pK len:0x%zu\n", dbg->base, dbg->max_offset);
 		addr = dbg->base;
 		len = dbg->max_offset;
 		mdss_dump_reg((const char *)dbg->name, reg_dump_flag, addr,
diff --git a/drivers/video/msm/mdss/mdss_dsi.c b/drivers/video/msm/mdss/mdss_dsi.c
index a39d2f3..6933388 100644
--- a/drivers/video/msm/mdss/mdss_dsi.c
+++ b/drivers/video/msm/mdss/mdss_dsi.c
@@ -1185,7 +1185,7 @@ static int mdss_dsi_off(struct mdss_panel_data *pdata, int power_state)
 	mutex_lock(&ctrl_pdata->mutex);
 	panel_info = &ctrl_pdata->panel_data.panel_info;
 
-	pr_debug("%s+: ctrl=%p ndx=%d power_state=%d\n",
+	pr_debug("%s+: ctrl=%pK ndx=%d power_state=%d\n",
 		__func__, ctrl_pdata, ctrl_pdata->ndx, power_state);
 
 	if (power_state == panel_info->panel_power_state) {
@@ -1369,7 +1369,7 @@ int mdss_dsi_on(struct mdss_panel_data *pdata)
 		mdss_dsi_validate_debugfs_info(ctrl_pdata);
 
 	cur_power_state = pdata->panel_info.panel_power_state;
-	pr_debug("%s+: ctrl=%p ndx=%d cur_power_state=%d\n", __func__,
+	pr_debug("%s+: ctrl=%pK ndx=%d cur_power_state=%d\n", __func__,
 		ctrl_pdata, ctrl_pdata->ndx, cur_power_state);
 
 	pinfo = &pdata->panel_info;
@@ -1547,7 +1547,7 @@ static int mdss_dsi_unblank(struct mdss_panel_data *pdata)
 				panel_data);
 	mipi  = &pdata->panel_info.mipi;
 
-	pr_debug("%s+: ctrl=%p ndx=%d cur_power_state=%d ctrl_state=%x\n",
+	pr_debug("%s+: ctrl=%pK ndx=%d cur_power_state=%d ctrl_state=%x\n",
 			__func__, ctrl_pdata, ctrl_pdata->ndx,
 		pdata->panel_info.panel_power_state, ctrl_pdata->ctrl_state);
 
@@ -1618,7 +1618,7 @@ static int mdss_dsi_blank(struct mdss_panel_data *pdata, int power_state)
 				panel_data);
 	mipi = &pdata->panel_info.mipi;
 
-	pr_debug("%s+: ctrl=%p ndx=%d power_state=%d\n",
+	pr_debug("%s+: ctrl=%pK ndx=%d power_state=%d\n",
 		__func__, ctrl_pdata, ctrl_pdata->ndx, power_state);
 
 	mdss_dsi_clk_ctrl(ctrl_pdata, ctrl_pdata->dsi_clk_handle,
@@ -1687,7 +1687,7 @@ static int mdss_dsi_post_panel_on(struct mdss_panel_data *pdata)
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s+: ctrl=%p ndx=%d\n", __func__,
+	pr_debug("%s+: ctrl=%pK ndx=%d\n", __func__,
 				ctrl_pdata, ctrl_pdata->ndx);
 
 	mdss_dsi_clk_ctrl(ctrl_pdata, ctrl_pdata->dsi_clk_handle,
@@ -1721,7 +1721,7 @@ int mdss_dsi_cont_splash_on(struct mdss_panel_data *pdata)
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s+: ctrl=%p ndx=%d\n", __func__,
+	pr_debug("%s+: ctrl=%pK ndx=%d\n", __func__,
 				ctrl_pdata, ctrl_pdata->ndx);
 
 	WARN((ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT),
@@ -2998,8 +2998,8 @@ static int mdss_dsi_get_bridge_chip_params(struct mdss_panel_info *pinfo,
 	u32 temp_val = 0;
 
 	if (!ctrl_pdata || !pdev || !pinfo) {
-		pr_err("%s: Invalid Params ctrl_pdata=%p, pdev=%p\n", __func__,
-			ctrl_pdata, pdev);
+		pr_err("%s: Invalid Params ctrl_pdata=%pK, pdev=%pK\n",
+			 __func__, ctrl_pdata, pdev);
 		rc = -EINVAL;
 		goto end;
 	}
@@ -3321,7 +3321,7 @@ static int mdss_dsi_res_init(struct platform_device *pdev)
 		mdss_dsi_res->shared_data = devm_kzalloc(&pdev->dev,
 				sizeof(struct dsi_shared_data),
 				GFP_KERNEL);
-		pr_debug("%s Allocated shared_data=%p\n", __func__,
+		pr_debug("%s Allocated shared_data=%pK\n", __func__,
 				mdss_dsi_res->shared_data);
 		if (!mdss_dsi_res->shared_data) {
 			pr_err("%s Unable to alloc mem for shared_data\n",
@@ -3386,7 +3386,7 @@ static int mdss_dsi_res_init(struct platform_device *pdev)
 				rc = -ENOMEM;
 				goto mem_fail;
 			}
-			pr_debug("%s Allocated ctrl_pdata[%d]=%p\n",
+			pr_debug("%s Allocated ctrl_pdata[%d]=%pK\n",
 				__func__, i, mdss_dsi_res->ctrl_pdata[i]);
 			mdss_dsi_res->ctrl_pdata[i]->shared_data =
 				mdss_dsi_res->shared_data;
@@ -3396,7 +3396,7 @@ static int mdss_dsi_res_init(struct platform_device *pdev)
 	}
 
 	mdss_dsi_res->pdev = pdev;
-	pr_debug("%s: Setting up mdss_dsi_res=%p\n", __func__, mdss_dsi_res);
+	pr_debug("%s: Setting up mdss_dsi_res=%pK\n", __func__, mdss_dsi_res);
 
 	return 0;
 
@@ -3723,11 +3723,11 @@ int mdss_dsi_retrieve_ctrl_resources(struct platform_device *pdev, int mode,
 		pr_debug("%s:%d unable to remap dsi phy regulator resources\n",
 			       __func__, __LINE__);
 	else
-		pr_info("%s: phy_regulator_base=%p phy_regulator_size=%x\n",
+		pr_info("%s: phy_regulator_base=%pK phy_regulator_size=%x\n",
 			__func__, ctrl->phy_regulator_io.base,
 			ctrl->phy_regulator_io.len);
 
-	pr_info("%s: ctrl_base=%p ctrl_size=%x phy_base=%p phy_size=%x\n",
+	pr_info("%s: ctrl_base=%pK ctrl_size=%x phy_base=%pK phy_size=%x\n",
 		__func__, ctrl->ctrl_base, ctrl->reg_size, ctrl->phy_io.base,
 		ctrl->phy_io.len);
 
@@ -3871,7 +3871,7 @@ static int mdss_dsi_parse_ctrl_params(struct platform_device *ctrl_pdev,
 	data = of_get_property(ctrl_pdev->dev.of_node,
 		"qcom,display-id", &len);
 	if (!data || len <= 0)
-		pr_err("%s:%d Unable to read qcom,display-id, data=%p,len=%d\n",
+		pr_err("%s:%d Unable to read qcom,display-id, data=%pK,len=%d\n",
 			__func__, __LINE__, data, len);
 	else
 		snprintf(ctrl_pdata->panel_data.panel_info.display_id,
diff --git a/drivers/video/msm/mdss/mdss_dsi_clk.c b/drivers/video/msm/mdss/mdss_dsi_clk.c
index bac8391..e92f6df 100644
--- a/drivers/video/msm/mdss/mdss_dsi_clk.c
+++ b/drivers/video/msm/mdss/mdss_dsi_clk.c
@@ -732,7 +732,7 @@ int mdss_dsi_clk_req_state(void *client, enum mdss_dsi_clk_type clk,
 
 	if (!client || !clk || clk > (MDSS_DSI_CORE_CLK | MDSS_DSI_LINK_CLK) ||
 	    state > MDSS_DSI_CLK_EARLY_GATE) {
-		pr_err("Invalid params, client = %p, clk = 0x%x, state = %d\n",
+		pr_err("Invalid params, client = %pK, clk = 0x%x, state = %d\n",
 		       client, clk, state);
 		return -EINVAL;
 	}
@@ -830,7 +830,7 @@ int mdss_dsi_clk_set_link_rate(void *client, enum mdss_dsi_link_clk_type clk,
 	struct mdss_dsi_clk_mngr *mngr;
 
 	if (!client || (clk > MDSS_DSI_LINK_CLK_MAX)) {
-		pr_err("Invalid params, client = %p, clk = 0x%x", client, clk);
+		pr_err("Invalid params, client = %pK, clk = 0x%x", client, clk);
 		return -EINVAL;
 	}
 
@@ -929,7 +929,7 @@ int mdss_dsi_clk_force_toggle(void *client, u32 clk)
 	struct mdss_dsi_clk_mngr *mngr;
 
 	if (!client || !clk || clk >= MDSS_DSI_CLKS_MAX) {
-		pr_err("Invalid params, client = %p, clk = 0x%x\n",
+		pr_err("Invalid params, client = %pK, clk = 0x%x\n",
 		       client, clk);
 		return -EINVAL;
 	}
diff --git a/drivers/video/msm/mdss/mdss_dsi_host.c b/drivers/video/msm/mdss/mdss_dsi_host.c
index 66bbff5..f6fbd66 100644
--- a/drivers/video/msm/mdss/mdss_dsi_host.c
+++ b/drivers/video/msm/mdss/mdss_dsi_host.c
@@ -102,7 +102,7 @@ void mdss_dsi_ctrl_init(struct device *ctrl_dev,
 	if (ctrl->mdss_util->register_irq(ctrl->dsi_hw))
 		pr_err("%s: mdss_register_irq failed.\n", __func__);
 
-	pr_debug("%s: ndx=%d base=%p\n", __func__, ctrl->ndx, ctrl->ctrl_base);
+	pr_debug("%s: ndx=%d base=%pK\n", __func__, ctrl->ndx, ctrl->ctrl_base);
 
 	init_completion(&ctrl->dma_comp);
 	init_completion(&ctrl->mdp_comp);
diff --git a/drivers/video/msm/mdss/mdss_dsi_panel.c b/drivers/video/msm/mdss/mdss_dsi_panel.c
index 2428af7..06dc0ec 100644
--- a/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -721,7 +721,7 @@ static int mdss_dsi_post_panel_on(struct mdss_panel_data *pdata)
 	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s: ctrl=%p ndx=%d\n", __func__, ctrl, ctrl->ndx);
+	pr_debug("%s: ctrl=%pK ndx=%d\n", __func__, ctrl, ctrl->ndx);
 
 	pinfo = &pdata->panel_info;
 	if (pinfo->dcs_cmd_by_left && ctrl->ndx != DSI_CTRL_LEFT)
@@ -760,7 +760,7 @@ static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s: ctrl=%p ndx=%d\n", __func__, ctrl, ctrl->ndx);
+	pr_debug("%s: ctrl=%pK ndx=%d\n", __func__, ctrl, ctrl->ndx);
 
 	if (pinfo->dcs_cmd_by_left) {
 		if (ctrl->ndx != DSI_CTRL_LEFT)
@@ -795,7 +795,7 @@ static int mdss_dsi_panel_low_power_config(struct mdss_panel_data *pdata,
 	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s: ctrl=%p ndx=%d enable=%d\n", __func__, ctrl, ctrl->ndx,
+	pr_debug("%s: ctrl=%pK ndx=%d enable=%d\n", __func__, ctrl, ctrl->ndx,
 		enable);
 
 	/* Any panel specific low power commands/config */
@@ -2066,7 +2066,7 @@ static int mdss_dsi_panel_timing_from_dt(struct device_node *np,
 
 	if (np->name) {
 		pt->timing.name = kstrdup(np->name, GFP_KERNEL);
-		pr_info("%s: found new timing \"%s\" (%p)\n", __func__,
+		pr_info("%s: found new timing \"%s\" (%pK)\n", __func__,
 				np->name, &pt->timing);
 	}
 
@@ -2400,7 +2400,7 @@ static int mdss_panel_parse_dt(struct device_node *np,
 		bridge_chip_name = of_get_property(np,
 			"qcom,bridge-name", &len);
 		if (!bridge_chip_name || len <= 0) {
-			pr_err("%s:%d Unable to read qcom,bridge_name, data=%p,len=%d\n",
+			pr_err("%s:%d Unable to read qcom,bridge_name, data=%pK,len=%d\n",
 				__func__, __LINE__, bridge_chip_name, len);
 			rc = -EINVAL;
 			goto error;
diff --git a/drivers/video/msm/mdss/mdss_fb.c b/drivers/video/msm/mdss/mdss_fb.c
index 570471d..3b68ee2 100644
--- a/drivers/video/msm/mdss/mdss_fb.c
+++ b/drivers/video/msm/mdss/mdss_fb.c
@@ -2029,7 +2029,7 @@ int mdss_fb_alloc_fb_ion_memory(struct msm_fb_data_type *mfd, size_t fb_size)
 		rc = PTR_ERR(vaddr);
 		goto err_unmap;
 	}
-	pr_debug("alloc 0x%zuB vaddr = %p for fb%d\n", fb_size,
+	pr_debug("alloc 0x%zuB vaddr = %pK for fb%d\n", fb_size,
 			vaddr, mfd->index);
 
 	mfd->fbi->screen_base = (char *) vaddr;
@@ -2128,7 +2128,7 @@ static int mdss_fb_fbmem_ion_mmap(struct fb_info *info,
 				vma->vm_page_prot =
 					pgprot_writecombine(vma->vm_page_prot);
 
-			pr_debug("vma=%p, addr=%x len=%ld\n",
+			pr_debug("vma=%pK, addr=%x len=%ld\n",
 					vma, (unsigned int)addr, len);
 			pr_debug("vm_start=%x vm_end=%x vm_page_prot=%ld\n",
 					(unsigned int)vma->vm_start,
@@ -2295,7 +2295,7 @@ static int mdss_fb_alloc_fbmem_iommu(struct msm_fb_data_type *mfd, int dom)
 		return -ERANGE;
 	}
 
-	pr_debug("alloc 0x%zxB @ (%pa phys) (0x%p virt) (%pa iova) for fb%d\n",
+	pr_debug("alloc 0x%zxB @ (%pa phys) (0x%pK virt) (%pa iova) for fb%d\n",
 		 size, &phys, virt, &mfd->iova, mfd->index);
 
 	mfd->fbi->screen_base = virt;
@@ -2583,7 +2583,7 @@ static int mdss_fb_open(struct fb_info *info, int user)
 	}
 
 	mfd->ref_cnt++;
-	pr_debug("mfd refcount:%d file:%p\n", mfd->ref_cnt, info->file);
+	pr_debug("mfd refcount:%d file:%pK\n", mfd->ref_cnt, info->file);
 
 	return 0;
 
@@ -2648,7 +2648,7 @@ static int mdss_fb_release_all(struct fb_info *info, bool release_all)
 		pr_warn("file node not found or wrong ref cnt: release all:%d refcnt:%d\n",
 			release_all, mfd->ref_cnt);
 
-	pr_debug("current process=%s pid=%d mfd->ref=%d file:%p\n",
+	pr_debug("current process=%s pid=%d mfd->ref=%d file:%pK\n",
 		task->comm, current->tgid, mfd->ref_cnt, info->file);
 
 	if (!mfd->ref_cnt || release_all) {
@@ -4242,7 +4242,7 @@ static int mdss_fb_atomic_commit_ioctl(struct fb_info *info,
 			ret = copy_from_user(scale, layer->scale,
 					sizeof(struct mdp_scale_data));
 			if (ret) {
-				pr_err("layer list copy from user failed, scale = %p\n",
+				pr_err("layer list copy from user failed, scale = %pK\n",
 						layer->scale);
 				kfree(scale);
 				scale = NULL;
diff --git a/drivers/video/msm/mdss/mdss_hdmi_tx.c b/drivers/video/msm/mdss/mdss_hdmi_tx.c
index 9ce7812..b234d1e 100644
--- a/drivers/video/msm/mdss/mdss_hdmi_tx.c
+++ b/drivers/video/msm/mdss/mdss_hdmi_tx.c
@@ -1458,7 +1458,7 @@ static int hdmi_tx_sysfs_create(struct hdmi_tx_ctrl *hdmi_ctrl,
 		return rc;
 	}
 	hdmi_ctrl->kobj = &fbi->dev->kobj;
-	DEV_DBG("%s: sysfs group %p\n", __func__, hdmi_ctrl->kobj);
+	DEV_DBG("%s: sysfs group %pK\n", __func__, hdmi_ctrl->kobj);
 
 	return 0;
 } /* hdmi_tx_sysfs_create */
@@ -4790,7 +4790,7 @@ static int hdmi_tx_init_resource(struct hdmi_tx_ctrl *hdmi_ctrl)
 			DEV_DBG("%s: '%s' remap failed or not available\n",
 				__func__, hdmi_tx_io_name(i));
 		}
-		DEV_INFO("%s: '%s': start = 0x%p, len=0x%x\n", __func__,
+		DEV_INFO("%s: '%s': start = 0x%pK, len=0x%x\n", __func__,
 			hdmi_tx_io_name(i), pdata->io[i].base,
 			pdata->io[i].len);
 	}
@@ -5298,7 +5298,7 @@ static int hdmi_tx_get_dt_data(struct platform_device *pdev,
 
 	data = of_get_property(pdev->dev.of_node, "qcom,display-id", &len);
 	if (!data || len <= 0)
-		pr_err("%s:%d Unable to read qcom,display-id, data=%p,len=%d\n",
+		pr_err("%s:%d Unable to read qcom,display-id, data=%pK,len=%d\n",
 			__func__, __LINE__, data, len);
 	else
 		snprintf(hdmi_ctrl->panel_data.panel_info.display_id,
diff --git a/drivers/video/msm/mdss/mdss_mdp.c b/drivers/video/msm/mdss/mdss_mdp.c
index e7301ae..2b0bcec 100644
--- a/drivers/video/msm/mdss/mdss_mdp.c
+++ b/drivers/video/msm/mdss/mdss_mdp.c
@@ -481,7 +481,7 @@ struct reg_bus_client *mdss_reg_bus_vote_client_create(char *client_name)
 	strlcpy(client->name, client_name, MAX_CLIENT_NAME_LEN);
 	client->usecase_ndx = VOTE_INDEX_DISABLE;
 	client->id = id;
-	pr_debug("bus vote client %s created:%p id :%d\n", client_name,
+	pr_debug("bus vote client %s created:%pK id :%d\n", client_name,
 		client, id);
 	id++;
 	list_add(&client->list, &mdss_res->reg_bus_clist);
@@ -495,7 +495,7 @@ void mdss_reg_bus_vote_client_destroy(struct reg_bus_client *client)
 	if (!client) {
 		pr_err("reg bus vote: invalid client handle\n");
 	} else {
-		pr_debug("bus vote client %s destroyed:%p id:%u\n",
+		pr_debug("bus vote client %s destroyed:%pK id:%u\n",
 			client->name, client, client->id);
 		mutex_lock(&mdss_res->reg_bus_lock);
 		list_del_init(&client->list);
@@ -1561,7 +1561,7 @@ static u32 mdss_mdp_res_init(struct mdss_data_type *mdata)
 
 	mdata->iclient = msm_ion_client_create(mdata->pdev->name);
 	if (IS_ERR_OR_NULL(mdata->iclient)) {
-		pr_err("msm_ion_client_create() return error (%p)\n",
+		pr_err("msm_ion_client_create() return error (%pK)\n",
 				mdata->iclient);
 		mdata->iclient = NULL;
 	}
@@ -2028,7 +2028,7 @@ static int mdss_mdp_probe(struct platform_device *pdev)
 	if (rc)
 		pr_debug("unable to map MDSS VBIF non-realtime base\n");
 	else
-		pr_debug("MDSS VBIF NRT HW Base addr=%p len=0x%x\n",
+		pr_debug("MDSS VBIF NRT HW Base addr=%pK len=0x%x\n",
 			mdata->vbif_nrt_io.base, mdata->vbif_nrt_io.len);
 
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
@@ -2923,7 +2923,7 @@ static int mdss_mdp_cdm_addr_setup(struct mdss_data_type *mdata,
 		head[i].base = (mdata->mdss_io.base) + cdm_offsets[i];
 		atomic_set(&head[i].kref.refcount, 0);
 		mutex_init(&head[i].lock);
-		pr_debug("%s: cdm off (%d) = %p\n", __func__, i, head[i].base);
+		pr_debug("%s: cdm off (%d) = %pK\n", __func__, i, head[i].base);
 	}
 
 	mdata->cdm_off = head;
@@ -2990,7 +2990,7 @@ static int mdss_mdp_dsc_addr_setup(struct mdss_data_type *mdata,
 	for (i = 0; i < len; i++) {
 		head[i].num = i;
 		head[i].base = (mdata->mdss_io.base) + dsc_offsets[i];
-		pr_debug("dsc off (%d) = %p\n", i, head[i].base);
+		pr_debug("dsc off (%d) = %pK\n", i, head[i].base);
 	}
 
 	mdata->dsc_off = head;
diff --git a/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c b/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
index ba13444..cd1f02b 100644
--- a/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
+++ b/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
@@ -1549,7 +1549,7 @@ static int mdss_mdp_cmd_wait4pingpong(struct mdss_mdp_ctl *ctl, void *arg)
 	MDSS_XLOG(ctl->num, atomic_read(&ctx->koff_cnt), ctl->roi_bkup.w,
 			ctl->roi_bkup.h);
 
-	pr_debug("%s: intf_num=%d ctx=%p koff_cnt=%d\n", __func__,
+	pr_debug("%s: intf_num=%d ctx=%pK koff_cnt=%d\n", __func__,
 			ctl->intf_num, ctx, atomic_read(&ctx->koff_cnt));
 
 	rc = wait_event_timeout(ctx->pp_waitq,
@@ -1777,7 +1777,7 @@ int mdss_mdp_cmd_set_autorefresh_mode(struct mdss_mdp_ctl *mctl, int frame_cnt)
 	struct mdss_panel_info *pinfo;
 
 	if (!mctl || !mctl->is_master || !mctl->panel_data) {
-		pr_err("invalid ctl mctl:%p pdata:%p\n",
+		pr_err("invalid ctl mctl:%pK pdata:%pK\n",
 			mctl, mctl ? mctl->panel_data : 0);
 		return -ENODEV;
 	}
@@ -2782,7 +2782,7 @@ static int mdss_mdp_cmd_ctx_setup(struct mdss_mdp_ctl *ctl,
 
 	ctx->intf_stopped = 0;
 
-	pr_debug("%s: ctx=%p num=%d aux=%d\n", __func__, ctx,
+	pr_debug("%s: ctx=%pK num=%d aux=%d\n", __func__, ctx,
 		default_pp_num, aux_pp_num);
 	MDSS_XLOG(ctl->num, atomic_read(&ctx->koff_cnt));
 
diff --git a/drivers/video/msm/mdss/mdss_mdp_intf_video.c b/drivers/video/msm/mdss/mdss_mdp_intf_video.c
index 6924e64..b0fc8fc 100644
--- a/drivers/video/msm/mdss/mdss_mdp_intf_video.c
+++ b/drivers/video/msm/mdss/mdss_mdp_intf_video.c
@@ -123,7 +123,7 @@ int mdss_mdp_video_addr_setup(struct mdss_data_type *mdata,
 
 	for (i = 0; i < count; i++) {
 		head[i].base = mdata->mdss_io.base + offsets[i];
-		pr_debug("adding Video Intf #%d offset=0x%x virt=%p\n", i,
+		pr_debug("adding Video Intf #%d offset=0x%x virt=%pK\n", i,
 				offsets[i], head[i].base);
 		head[i].ref_cnt = 0;
 		head[i].intf_num = i + MDSS_MDP_INTF0;
@@ -520,7 +520,7 @@ static int mdss_mdp_video_intfs_stop(struct mdss_mdp_ctl *ctl,
 		pr_err("Intf %d not in use\n", (inum + MDSS_MDP_INTF0));
 		return -ENODEV;
 	}
-	pr_debug("stop ctl=%d video Intf #%d base=%p", ctl->num, ctx->intf_num,
+	pr_debug("stop ctl=%d video Intf #%d base=%pK", ctl->num, ctx->intf_num,
 			ctx->base);
 
 	ret = mdss_mdp_video_ctx_stop(ctl, pinfo, ctx);
@@ -538,7 +538,7 @@ static int mdss_mdp_video_intfs_stop(struct mdss_mdp_ctl *ctl,
 			pr_err("Intf %d not in use\n", (inum + MDSS_MDP_INTF0));
 			return -ENODEV;
 		}
-		pr_debug("stop ctl=%d video Intf #%d base=%p", ctl->num,
+		pr_debug("stop ctl=%d video Intf #%d base=%pK", ctl->num,
 				sctx->intf_num, sctx->base);
 
 		ret = mdss_mdp_video_ctx_stop(ctl, pinfo, sctx);
@@ -1535,7 +1535,7 @@ static int mdss_mdp_video_intfs_setup(struct mdss_mdp_ctl *ctl,
 					(inum + MDSS_MDP_INTF0));
 			return -EBUSY;
 		}
-		pr_debug("video Intf #%d base=%p", ctx->intf_num, ctx->base);
+		pr_debug("video Intf #%d base=%pK", ctx->intf_num, ctx->base);
 		ctx->ref_cnt++;
 	} else {
 		pr_err("Invalid intf number: %d\n", (inum + MDSS_MDP_INTF0));
@@ -1568,7 +1568,7 @@ static int mdss_mdp_video_intfs_setup(struct mdss_mdp_ctl *ctl,
 					(inum + MDSS_MDP_INTF0));
 			return -EBUSY;
 		}
-		pr_debug("video Intf #%d base=%p", ctx->intf_num, ctx->base);
+		pr_debug("video Intf #%d base=%pK", ctx->intf_num, ctx->base);
 		ctx->ref_cnt++;
 
 		ctl->intf_ctx[SLAVE_CTX] = ctx;
diff --git a/drivers/video/msm/mdss/mdss_mdp_layer.c b/drivers/video/msm/mdss/mdss_mdp_layer.c
index 2e8008d..0615625 100644
--- a/drivers/video/msm/mdss/mdss_mdp_layer.c
+++ b/drivers/video/msm/mdss/mdss_mdp_layer.c
@@ -446,7 +446,7 @@ static int __configure_pipe_params(struct msm_fb_data_type *mfd,
 	mixer = mdss_mdp_mixer_get(mdp5_data->ctl, mixer_mux);
 	pipe->src_fmt = mdss_mdp_get_format_params(layer->buffer.format);
 	if (!pipe->src_fmt || !mixer) {
-		pr_err("invalid layer format:%d or mixer:%p\n",
+		pr_err("invalid layer format:%d or mixer:%pK\n",
 				layer->buffer.format, pipe->mixer_left);
 		ret = -EINVAL;
 		goto end;
@@ -1354,7 +1354,7 @@ validate_exit:
 			}
 		} else {
 			pipe->file = file;
-			pr_debug("file pointer attached with pipe is %p\n",
+			pr_debug("file pointer attached with pipe is %pK\n",
 				file);
 		}
 	}
diff --git a/drivers/video/msm/mdss/mdss_mdp_overlay.c b/drivers/video/msm/mdss/mdss_mdp_overlay.c
index 495b28f..c01968c 100644
--- a/drivers/video/msm/mdss/mdss_mdp_overlay.c
+++ b/drivers/video/msm/mdss/mdss_mdp_overlay.c
@@ -1080,7 +1080,7 @@ struct mdss_mdp_data *mdss_mdp_overlay_buf_alloc(struct msm_fb_data_type *mfd,
 	list_move_tail(&buf->buf_list, &mdp5_data->bufs_used);
 	list_add_tail(&buf->pipe_list, &pipe->buf_queue);
 
-	pr_debug("buffer alloc: %p\n", buf);
+	pr_debug("buffer alloc: %pK\n", buf);
 
 	return buf;
 }
@@ -1134,7 +1134,7 @@ void mdss_mdp_overlay_buf_free(struct msm_fb_data_type *mfd,
 	buf->last_freed = local_clock();
 	buf->state = MDP_BUF_STATE_UNUSED;
 
-	pr_debug("buffer freed: %p\n", buf);
+	pr_debug("buffer freed: %pK\n", buf);
 
 	list_move_tail(&buf->buf_list, &mdp5_data->bufs_pool);
 }
@@ -1474,7 +1474,7 @@ static int __overlay_queue_pipes(struct msm_fb_data_type *mfd)
 		if (buf) {
 			switch (buf->state) {
 			case MDP_BUF_STATE_READY:
-				pr_debug("pnum=%d buf=%p first buffer ready\n",
+				pr_debug("pnum=%d buf=%pK first buffer ready\n",
 						pipe->num, buf);
 				break;
 			case MDP_BUF_STATE_ACTIVE:
@@ -1494,7 +1494,7 @@ static int __overlay_queue_pipes(struct msm_fb_data_type *mfd)
 				}
 				break;
 			default:
-				pr_err("invalid state of buf %p=%d\n",
+				pr_err("invalid state of buf %pK=%d\n",
 						buf, buf->state);
 				BUG();
 				break;
@@ -2160,7 +2160,7 @@ static int __mdss_mdp_overlay_release_all(struct msm_fb_data_type *mfd,
 	u32 unset_ndx = 0;
 	int cnt = 0;
 
-	pr_debug("releasing all resources for fb%d file:%p\n",
+	pr_debug("releasing all resources for fb%d file:%pK\n",
 		mfd->index, file);
 
 	mutex_lock(&mdp5_data->ov_lock);
diff --git a/drivers/video/msm/mdss/mdss_mdp_pipe.c b/drivers/video/msm/mdss/mdss_mdp_pipe.c
index b14dd17..f7fbb7f 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pipe.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pipe.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -2278,7 +2278,7 @@ int mdss_mdp_pipe_queue_data(struct mdss_mdp_pipe *pipe,
 	}
 
 	if (src_data == NULL) {
-		pr_debug("src_data=%p pipe num=%dx\n",
+		pr_debug("src_data=%pK pipe num=%dx\n",
 				src_data, pipe->num);
 		goto update_nobuf;
 	}
diff --git a/drivers/video/msm/mdss/mdss_mdp_pp.c b/drivers/video/msm/mdss/mdss_mdp_pp.c
index 580d10b..6d59502 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pp.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pp.c
@@ -1096,7 +1096,7 @@ static int pp_rgb_pipe_setup(struct mdss_mdp_pipe *pipe, u32 *op)
 	int ret = 0;
 
 	if (!pipe) {
-		pr_err("invalid param pipe %p\n", pipe);
+		pr_err("invalid param pipe %pK\n", pipe);
 		return -EINVAL;
 	}
 	if (pipe->flags & MDP_OVERLAY_PP_CFG_EN &&
@@ -1114,7 +1114,7 @@ static int pp_dma_pipe_setup(struct mdss_mdp_pipe *pipe, u32 *op)
 	int ret = 0;
 
 	if (!pipe) {
-		pr_err("invalid param pipe %p\n", pipe);
+		pr_err("invalid param pipe %pK\n", pipe);
 		return -EINVAL;
 	}
 	if (pipe->flags & MDP_OVERLAY_PP_CFG_EN &&
@@ -1435,7 +1435,7 @@ void mdss_mdp_pipe_pp_clear(struct mdss_mdp_pipe *pipe)
 	struct pp_hist_col_info *hist_info;
 
 	if (!pipe) {
-		pr_err("Invalid pipe context passed, %p\n",
+		pr_err("Invalid pipe context passed, %pK\n",
 			pipe);
 		return;
 	}
@@ -1582,7 +1582,7 @@ static int pp_mixer_setup(struct mdss_mdp_mixer *mixer)
 	struct mdss_data_type *mdata = mdss_mdp_get_mdata();
 
 	if (!mixer || !mixer->ctl || !mixer->ctl->mfd || !mdata) {
-		pr_err("invalid parameters, mixer %p ctl %p mfd %p mdata %p\n",
+		pr_err("invalid parameters, mixer %pK ctl %pK mfd %pK mdata %pK\n",
 			mixer, (mixer ? mixer->ctl : NULL),
 			(mixer ? (mixer->ctl ? mixer->ctl->mfd : NULL) : NULL),
 			mdata);
@@ -2200,7 +2200,7 @@ int mdss_mdp_pp_resume(struct msm_fb_data_type *mfd)
 	struct mdp_pa_v2_cfg_data *pa_v2_cache_cfg = NULL;
 
 	if (!mfd) {
-		pr_err("invalid input: mfd = 0x%p\n", mfd);
+		pr_err("invalid input: mfd = 0x%pK\n", mfd);
 		return -EINVAL;
 	}
 
@@ -2290,7 +2290,7 @@ int mdss_mdp_pp_resume(struct msm_fb_data_type *mfd)
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK.\n",
 			ret, ad);
 		return ret;
 	}
@@ -2431,7 +2431,7 @@ static int mdss_mdp_pp_dt_parse(struct device *dev)
 			ret = 0;
 		}
 	} else {
-		pr_err("invalid dev %p mdata %p\n", dev, mdata);
+		pr_err("invalid dev %pK mdata %pK\n", dev, mdata);
 		ret = -EINVAL;
 	}
 bail_out:
@@ -2570,7 +2570,7 @@ int mdss_mdp_pp_overlay_init(struct msm_fb_data_type *mfd)
 	struct mdss_data_type *mdata = mdss_mdp_get_mdata();
 
 	if (!mfd || !mdata) {
-		pr_err("Invalid mfd %p mdata %p\n", mfd, mdata);
+		pr_err("Invalid mfd %pK mdata %pK\n", mfd, mdata);
 		return -EPERM;
 	}
 
@@ -2586,7 +2586,7 @@ int mdss_mdp_pp_default_overlay_config(struct msm_fb_data_type *mfd,
 	int ret = 0;
 
 	if (!mfd || !pdata) {
-		pr_err("Invalid parameters mfd %p pdata %p\n", mfd, pdata);
+		pr_err("Invalid parameters mfd %pK pdata %pK\n", mfd, pdata);
 		return -EINVAL;
 	}
 
@@ -2639,7 +2639,7 @@ static int pp_ad_calc_bl(struct msm_fb_data_type *mfd, int bl_in, int *bl_out,
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
 			ret, ad);
 		return ret;
 	}
@@ -2655,7 +2655,7 @@ static int pp_ad_calc_bl(struct msm_fb_data_type *mfd, int bl_in, int *bl_out,
 
 	if (!ad->bl_mfd || !ad->bl_mfd->panel_info ||
 		!ad->bl_att_lut) {
-		pr_err("Invalid ad info: bl_mfd = 0x%p, ad->bl_mfd->panel_info = 0x%p, bl_att_lut = 0x%p\n",
+		pr_err("Invalid ad info: bl_mfd = 0x%pK, ad->bl_mfd->panel_info = 0x%pK, bl_att_lut = 0x%pK\n",
 			ad->bl_mfd,
 			(!ad->bl_mfd) ? NULL : ad->bl_mfd->panel_info,
 			ad->bl_att_lut);
@@ -3147,7 +3147,7 @@ int mdss_mdp_pcc_config(struct msm_fb_data_type *mfd,
 		if (pp_ops[PCC].pp_get_config) {
 			addr = mdss_mdp_get_dspp_addr_off(disp_num);
 			if (IS_ERR_OR_NULL(addr)) {
-				pr_err("invalid dspp base_addr %p\n",
+				pr_err("invalid dspp base_addr %pK\n",
 					addr);
 				ret = -EINVAL;
 				goto pcc_clk_off;
@@ -3835,7 +3835,7 @@ int mdss_mdp_hist_lut_config(struct msm_fb_data_type *mfd,
 		mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_ON);
 		base_addr = mdss_mdp_get_dspp_addr_off(dspp_num);
 		if (IS_ERR_OR_NULL(base_addr)) {
-			pr_err("invalid base addr %p\n",
+			pr_err("invalid base addr %pK\n",
 				base_addr);
 			ret = -EINVAL;
 			goto hist_lut_clk_off;
@@ -4063,7 +4063,7 @@ int mdss_mdp_gamut_config(struct msm_fb_data_type *mfd,
 		if (pp_ops[GAMUT].pp_get_config) {
 			addr = mdss_mdp_get_dspp_addr_off(disp_num);
 			if (IS_ERR_OR_NULL(addr)) {
-				pr_err("invalid dspp base addr %p\n",
+				pr_err("invalid dspp base addr %pK\n",
 				       addr);
 				ret = -EINVAL;
 				goto gamut_clk_off;
@@ -4249,7 +4249,7 @@ static int pp_hist_enable(struct pp_hist_col_info *hist_info,
 	spin_lock_irqsave(&hist_info->hist_lock, flag);
 	if (hist_info->col_en) {
 		spin_unlock_irqrestore(&hist_info->hist_lock, flag);
-		pr_err("%s Hist collection has already been enabled %p\n",
+		pr_err("%s Hist collection has already been enabled %pK\n",
 			__func__, hist_info->base);
 		ret = -EBUSY;
 		goto exit;
@@ -4405,7 +4405,7 @@ static int pp_hist_disable(struct pp_hist_col_info *hist_info)
 	spin_lock_irqsave(&hist_info->hist_lock, flag);
 	if (hist_info->col_en == false) {
 		spin_unlock_irqrestore(&hist_info->hist_lock, flag);
-		pr_debug("Histogram already disabled (%p)\n", hist_info->base);
+		pr_debug("Histogram already disabled (%pK)\n", hist_info->base);
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -4508,7 +4508,7 @@ int mdss_mdp_hist_intr_req(struct mdss_intr *intr, u32 bits, bool en)
 	unsigned long flag;
 	int ret = 0;
 	if (!intr) {
-		pr_err("NULL addr passed, %p\n", intr);
+		pr_err("NULL addr passed, %pK\n", intr);
 		return -EINVAL;
 	}
 
@@ -5086,7 +5086,7 @@ static int mdss_mdp_get_ad(struct msm_fb_data_type *mfd,
 
 	*ret_ad = NULL;
 	if (!mfd) {
-		pr_err("invalid parameter mfd %p\n", mfd);
+		pr_err("invalid parameter mfd %pK\n", mfd);
 		return -EINVAL;
 	}
 	mdata = mfd_to_mdata(mfd);
@@ -5133,7 +5133,7 @@ static int pp_ad_invalidate_input(struct msm_fb_data_type *mfd)
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
 			ret, ad);
 		return ret;
 	}
@@ -5168,7 +5168,7 @@ int mdss_mdp_ad_config(struct msm_fb_data_type *mfd,
 			mfd->index);
 		return ret;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
 			ret, ad);
 		return ret;
 	}
@@ -5285,7 +5285,7 @@ int mdss_mdp_ad_input(struct msm_fb_data_type *mfd,
 			mfd->index);
 		return ret;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
 			ret, ad);
 		return ret;
 	}
@@ -5638,7 +5638,7 @@ static int mdss_mdp_ad_ipc_reset(struct msm_fb_data_type *mfd)
 	struct mdss_ad_info *ad;
 
 	if (!mfd) {
-		pr_err("mfd = 0x%p\n", mfd);
+		pr_err("mfd = 0x%pK\n", mfd);
 		return -EINVAL;
 	}
 
@@ -5648,7 +5648,7 @@ static int mdss_mdp_ad_ipc_reset(struct msm_fb_data_type *mfd)
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
 			ret, ad);
 		return ret;
 	}
@@ -5672,13 +5672,13 @@ static int mdss_mdp_ad_setup(struct msm_fb_data_type *mfd)
 	u32 width;
 
 	if (!mfd) {
-		pr_err("mfd = 0x%p\n", mfd);
+		pr_err("mfd = 0x%pK\n", mfd);
 		return -EINVAL;
 	}
 
 	ctl = mfd_to_ctl(mfd);
 	if (!ctl) {
-		pr_err("ctl = 0x%p\n", ctl);
+		pr_err("ctl = 0x%pK\n", ctl);
 		return -EINVAL;
 	}
 	sctl = mdss_mdp_get_split_ctl(ctl);
@@ -5689,7 +5689,7 @@ static int mdss_mdp_ad_setup(struct msm_fb_data_type *mfd)
 			mfd->index);
 		return 0;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK\n",
 			ret, ad);
 		return ret;
 	}
@@ -5873,7 +5873,7 @@ static void pp_ad_calc_worker(struct work_struct *work)
 	}
 	mdp5_data = mfd_to_mdp5_data(ad->mfd);
 	if (!mdp5_data) {
-		pr_err("mdp5_data = 0x%p\n", mdp5_data);
+		pr_err("mdp5_data = 0x%pK\n", mdp5_data);
 		mutex_unlock(&ad->lock);
 		return;
 	}
@@ -5881,7 +5881,7 @@ static void pp_ad_calc_worker(struct work_struct *work)
 	ctl = mfd_to_ctl(ad->mfd);
 	mdata = mfd_to_mdata(ad->mfd);
 	if (!ctl || !mdata || ad->calc_hw_num >= mdata->nad_cfgs) {
-		pr_err("ctl = 0x%p, mdata = 0x%p, ad->calc_hw_num = %d, mdata->nad_cfg = %d\n",
+		pr_err("ctl = 0x%pK, mdata = 0x%pK, ad->calc_hw_num = %d, mdata->nad_cfg = %d\n",
 			ctl, mdata, ad->calc_hw_num,
 			(!mdata ? 0 : mdata->nad_cfgs));
 		mutex_unlock(&ad->lock);
@@ -6492,7 +6492,7 @@ static int sspp_cache_location(u32 pipe_type, enum pp_config_block *block)
 	int ret = 0;
 
 	if (!block) {
-		pr_err("invalid params %p\n", block);
+		pr_err("invalid params %pK\n", block);
 		return -EINVAL;
 	}
 	switch (pipe_type) {
@@ -6521,7 +6521,7 @@ int mdss_mdp_pp_sspp_config(struct mdss_mdp_pipe *pipe)
 	int ret = 0;
 
 	if (!pipe) {
-		pr_err("invalid params, pipe %p\n", pipe);
+		pr_err("invalid params, pipe %pK\n", pipe);
 		return -EINVAL;
 	}
 
@@ -6643,7 +6643,7 @@ static int pp_update_pcc_pipe_setup(struct mdss_mdp_pipe *pipe, u32 location)
 	char __iomem *pipe_base = NULL;
 
 	if (!pipe) {
-		pr_err("invalid param pipe %p\n", pipe);
+		pr_err("invalid param pipe %pK\n", pipe);
 		return -EINVAL;
 	}
 
@@ -6695,7 +6695,7 @@ int mdss_mdp_pp_get_version(struct mdp_pp_feature_version *version)
 	u32 ver_info = mdp_pp_legacy;
 
 	if (!version) {
-		pr_err("invalid param version %p\n", version);
+		pr_err("invalid param version %pK\n", version);
 		ret = -EINVAL;
 		goto exit_version;
 	}
@@ -6776,7 +6776,7 @@ int mdss_mdp_copy_layer_pp_info(struct mdp_input_layer *layer)
 	uint32_t ops;
 
 	if (!layer) {
-		pr_err("invalid layer pointer passed %p\n", layer);
+		pr_err("invalid layer pointer passed %pK\n", layer);
 		return -EFAULT;
 	}
 
@@ -6788,7 +6788,7 @@ int mdss_mdp_copy_layer_pp_info(struct mdp_input_layer *layer)
 	ret = copy_from_user(pp_info, layer->pp_info,
 			sizeof(struct mdp_overlay_pp_params));
 	if (ret) {
-		pr_err("layer list copy from user failed, pp_info = %p\n",
+		pr_err("layer list copy from user failed, pp_info = %pK\n",
 			layer->pp_info);
 		ret = -EFAULT;
 		goto exit_pp_info;
@@ -6921,7 +6921,7 @@ static int pp_mfd_ad_release_all(struct msm_fb_data_type *mfd)
 	int ret = 0;
 
 	if (!mdata || !mfd) {
-		pr_err("invalid params mdata %p mfd %p\n", mdata, mfd);
+		pr_err("invalid params mdata %pK mfd %pK\n", mdata, mfd);
 		return -EINVAL;
 	}
 	if (!mdata->ad_calc_wq)
diff --git a/drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c b/drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c
index 7769a8f..5fe7e48 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pp_cache_config.c
@@ -103,7 +103,7 @@ static int pp_hist_lut_cache_params_v1_7(struct mdp_hist_lut_data *config,
 	int ret = 0;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -113,7 +113,7 @@ static int pp_hist_lut_cache_params_v1_7(struct mdp_hist_lut_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 
@@ -165,7 +165,7 @@ static int pp_hist_lut_cache_params_pipe_v1_7(struct mdp_hist_lut_data *config,
 	int ret = 0;
 
 	if (!config || !pipe) {
-		pr_err("Invalid param config %p pipe %p\n",
+		pr_err("Invalid param config %pK pipe %pK\n",
 			config, pipe);
 		return -EINVAL;
 	}
@@ -236,7 +236,7 @@ int pp_hist_lut_cache_params(struct mdp_hist_lut_data *config,
 	int ret = 0;
 
 	if (!config || !res_cache) {
-		pr_err("invalid param config %p res_cache %p\n",
+		pr_err("invalid param config %pK res_cache %pK\n",
 			config, res_cache);
 		return -EINVAL;
 	}
@@ -245,7 +245,7 @@ int pp_hist_lut_cache_params(struct mdp_hist_lut_data *config,
 		return -EINVAL;
 	}
 	if (!res_cache->mdss_pp_res && !res_cache->pipe_res) {
-		pr_err("NULL payload for block %d mdss_pp_res %p pipe_res %p\n",
+		pr_err("NULL payload for block %d mdss_pp_res %pK pipe_res %pK\n",
 			res_cache->block, res_cache->mdss_pp_res,
 			res_cache->pipe_res);
 		return -EINVAL;
@@ -286,7 +286,7 @@ int pp_dither_cache_params_v1_7(struct mdp_dither_cfg_data *config,
 	struct mdp_dither_data_v1_7 *v17_cache_data = NULL, v17_usr_config;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -296,7 +296,7 @@ int pp_dither_cache_params_v1_7(struct mdp_dither_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 
@@ -358,7 +358,7 @@ int pp_dither_cache_params(struct mdp_dither_cfg_data *config,
 {
 	int ret = 0;
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %pi pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -387,7 +387,7 @@ static int pp_gamut_cache_params_v1_7(struct mdp_gamut_cfg_data *config,
 	int ret = 0, i = 0;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -398,7 +398,7 @@ static int pp_gamut_cache_params_v1_7(struct mdp_gamut_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 	res_cache = mdss_pp_res->pp_data_res;
@@ -555,7 +555,7 @@ int pp_gamut_cache_params(struct mdp_gamut_cfg_data *config,
 {
 	int ret = 0;
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -578,7 +578,7 @@ static int pp_pcc_cache_params_pipe_v1_7(struct mdp_pcc_cfg_data *config,
 	struct mdp_pcc_data_v1_7 *v17_cache_data = NULL, v17_usr_config;
 
 	if (!pipe || !config) {
-		pr_err("invalid params pipe %p config %p\n", pipe, config);
+		pr_err("invalid params pipe %pK config %pK\n", pipe, config);
 		return -EINVAL;
 	}
 
@@ -636,7 +636,7 @@ static int pp_pcc_cache_params_v1_7(struct mdp_pcc_cfg_data *config,
 	struct mdp_pcc_data_v1_7 *v17_cache_data, v17_usr_config;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -647,7 +647,7 @@ static int pp_pcc_cache_params_v1_7(struct mdp_pcc_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 
@@ -687,7 +687,7 @@ int pp_pcc_cache_params(struct mdp_pcc_cfg_data *config,
 {
 	int ret = 0;
 	if (!config || !res_cache) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, res_cache);
 		return -EINVAL;
 	}
@@ -696,7 +696,7 @@ int pp_pcc_cache_params(struct mdp_pcc_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!res_cache->mdss_pp_res && !res_cache->pipe_res) {
-		pr_err("NULL payload for block %d mdss_pp_res %p pipe_res %p\n",
+		pr_err("NULL payload for block %d mdss_pp_res %pK pipe_res %pK\n",
 			res_cache->block, res_cache->mdss_pp_res,
 			res_cache->pipe_res);
 		return -EINVAL;
@@ -735,7 +735,7 @@ static int pp_igc_lut_cache_params_v1_7(struct mdp_igc_lut_data *config,
 	struct mdp_igc_lut_data_v1_7 *v17_cache_data, v17_usr_config;
 	u32 disp_num;
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -745,7 +745,7 @@ static int pp_igc_lut_cache_params_v1_7(struct mdp_igc_lut_data *config,
 		return -EINVAL;
 	}
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
+		pr_err("invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 	res_cache = mdss_pp_res->pp_data_res;
@@ -781,7 +781,7 @@ static int pp_igc_lut_cache_params_v1_7(struct mdp_igc_lut_data *config,
 		}
 		if (copy_from_kernel && (!v17_usr_config.c0_c1_data ||
 		    !v17_usr_config.c2_data)) {
-			pr_err("copy from kernel invalid params c0_c1_data %p c2_data %p\n",
+			pr_err("copy from kernel invalid params c0_c1_data %pK c2_data %pK\n",
 				v17_usr_config.c0_c1_data,
 				v17_usr_config.c2_data);
 			ret = -EINVAL;
@@ -837,7 +837,7 @@ static int pp_igc_lut_cache_params_pipe_v1_7(struct mdp_igc_lut_data *config,
 	struct mdp_igc_lut_data_v1_7 *v17_cache_data = NULL, v17_usr_config;
 	int ret = 0, fix_up = 0, i = 0;
 	if (!config || !pipe) {
-		pr_err("invalid param config %p pipe %p\n",
+		pr_err("invalid param config %pK pipe %pK\n",
 			config, pipe);
 		return -EINVAL;
 	}
@@ -865,7 +865,7 @@ static int pp_igc_lut_cache_params_pipe_v1_7(struct mdp_igc_lut_data *config,
 		if (!v17_usr_config.c0_c1_data ||
 		    !v17_usr_config.c2_data ||
 		    v17_usr_config.len != IGC_LUT_ENTRIES) {
-			pr_err("invalid c0_c1data %p c2_data %p tbl len %d\n",
+			pr_err("invalid c0_c1data %pK c2_data %pK tbl len %d\n",
 					v17_usr_config.c0_c1_data,
 					v17_usr_config.c2_data,
 					v17_usr_config.len);
@@ -959,7 +959,7 @@ int pp_igc_lut_cache_params(struct mdp_igc_lut_data *config,
 {
 	int ret = 0;
 	if (!config || !res_cache) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, res_cache);
 		return -EINVAL;
 	}
@@ -968,7 +968,7 @@ int pp_igc_lut_cache_params(struct mdp_igc_lut_data *config,
 		return -EINVAL;
 	}
 	if (!res_cache->mdss_pp_res && !res_cache->pipe_res) {
-		pr_err("NULL payload for block %d mdss_pp_res %p pipe_res %p\n",
+		pr_err("NULL payload for block %d mdss_pp_res %pK pipe_res %pK\n",
 			res_cache->block, res_cache->mdss_pp_res,
 			res_cache->pipe_res);
 		ret = -EINVAL;
@@ -1103,7 +1103,7 @@ int pp_pgc_lut_cache_params(struct mdp_pgc_lut_data *config,
 {
 	int ret = 0;
 	if (!config || !mdss_pp_res) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -1128,7 +1128,7 @@ static int pp_pa_cache_params_v1_7(struct mdp_pa_v2_cfg_data *config,
 	int disp_num, ret = 0;
 
 	if (!config || !mdss_pp_res) {
-		pr_err("Invalid param config %p pp_res %p\n",
+		pr_err("Invalid param config %pK pp_res %pK\n",
 			config, mdss_pp_res);
 		return -EINVAL;
 	}
@@ -1140,7 +1140,7 @@ static int pp_pa_cache_params_v1_7(struct mdp_pa_v2_cfg_data *config,
 	}
 
 	if (!mdss_pp_res->pp_data_res) {
-		pr_err("Invalid pp_data_res %p\n", mdss_pp_res->pp_data_res);
+		pr_err("Invalid pp_data_res %pK\n", mdss_pp_res->pp_data_res);
 		return -EINVAL;
 	}
 
@@ -1228,7 +1228,7 @@ static int pp_pa_cache_params_pipe_v1_7(struct mdp_pa_v2_cfg_data *config,
 	int ret = 0;
 
 	if (!config || !pipe) {
-		pr_err("Invalid param config %p pipe %p\n",
+		pr_err("Invalid param config %pK pipe %pK\n",
 			config, pipe);
 		return -EINVAL;
 	}
@@ -1284,7 +1284,7 @@ int pp_pa_cache_params(struct mdp_pa_v2_cfg_data *config,
 {
 	int ret = 0;
 	if (!config || !res_cache) {
-		pr_err("invalid param config %p pp_res %p\n",
+		pr_err("invalid param config %pK pp_res %pK\n",
 			config, res_cache);
 		return -EINVAL;
 	}
@@ -1293,7 +1293,7 @@ int pp_pa_cache_params(struct mdp_pa_v2_cfg_data *config,
 		return -EINVAL;
 	}
 	if (!res_cache->mdss_pp_res && !res_cache->pipe_res) {
-		pr_err("NULL payload for block %d mdss_pp_res %p pipe_res %p\n",
+		pr_err("NULL payload for block %d mdss_pp_res %pK pipe_res %pK\n",
 			res_cache->block, res_cache->mdss_pp_res,
 			res_cache->pipe_res);
 		return -EINVAL;
@@ -1344,7 +1344,7 @@ int pp_copy_layer_igc_payload(struct mdp_overlay_pp_params *pp_info)
 				pp_info->igc_cfg.cfg_payload,
 				sizeof(struct mdp_igc_lut_data_v1_7));
 		if (ret) {
-			pr_err("layer list copy from user failed, IGC cfg payload = %p\n",
+			pr_err("layer list copy from user failed, IGC cfg payload = %pK\n",
 				pp_info->igc_cfg.cfg_payload);
 			ret = -EFAULT;
 			kfree(cfg_payload);
@@ -1382,7 +1382,7 @@ int pp_copy_layer_hist_lut_payload(struct mdp_overlay_pp_params *pp_info)
 				pp_info->hist_lut_cfg.cfg_payload,
 				sizeof(struct mdp_hist_lut_data_v1_7));
 		if (ret) {
-			pr_err("layer list copy from user failed, Hist LUT cfg payload = %p\n",
+			pr_err("layer list copy from user failed, Hist LUT cfg payload = %pK\n",
 				pp_info->hist_lut_cfg.cfg_payload);
 			ret = -EFAULT;
 			kfree(cfg_payload);
@@ -1420,7 +1420,7 @@ int pp_copy_layer_pa_payload(struct mdp_overlay_pp_params *pp_info)
 				pp_info->pa_v2_cfg_data.cfg_payload,
 				sizeof(struct mdp_pa_data_v1_7));
 		if (ret) {
-			pr_err("layer list copy from user failed, PA cfg payload = %p\n",
+			pr_err("layer list copy from user failed, PA cfg payload = %pK\n",
 				pp_info->pa_v2_cfg_data.cfg_payload);
 			ret = -EFAULT;
 			kfree(cfg_payload);
@@ -1458,7 +1458,7 @@ int pp_copy_layer_pcc_payload(struct mdp_overlay_pp_params *pp_info)
 				pp_info->pcc_cfg_data.cfg_payload,
 				sizeof(struct mdp_pcc_data_v1_7));
 		if (ret) {
-			pr_err("layer list copy from user failed, PCC cfg payload = %p\n",
+			pr_err("layer list copy from user failed, PCC cfg payload = %pK\n",
 				pp_info->pcc_cfg_data.cfg_payload);
 			ret = -EFAULT;
 			kfree(cfg_payload);
diff --git a/drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c b/drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c
index fe88fe6..bc19b5b 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pp_v1_7.c
@@ -245,7 +245,7 @@ static void pp_gamut_clock_gating_en(char __iomem *base_addr);
 void *pp_get_driver_ops(struct mdp_pp_driver_ops *ops)
 {
 	if (!ops) {
-		pr_err("PP driver ops invalid %p\n", ops);
+		pr_err("PP driver ops invalid %pK\n", ops);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -307,7 +307,7 @@ static void pp_opmode_config(int location, struct pp_sts_type *pp_sts,
 		u32 *opmode, int side)
 {
 	if (!pp_sts || !opmode) {
-		pr_err("Invalid pp_sts %p or opmode %p\n", pp_sts, opmode);
+		pr_err("Invalid pp_sts %pK or opmode %pK\n", pp_sts, opmode);
 		return;
 	}
 	switch (location) {
@@ -361,7 +361,7 @@ static int pp_hist_lut_get_config(char __iomem *base_addr, void *cfg_data,
 	struct mdp_hist_lut_data *lut_cfg_data = NULL;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %p cfg_data %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK\n",
 		       base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -373,7 +373,7 @@ static int pp_hist_lut_get_config(char __iomem *base_addr, void *cfg_data,
 	}
 	if (lut_cfg_data->version != mdp_hist_lut_v1_7 ||
 		!lut_cfg_data->cfg_payload) {
-		pr_err("invalid hist_lut version %d payload %p\n",
+		pr_err("invalid hist_lut version %d payload %pK\n",
 		       lut_cfg_data->version, lut_cfg_data->cfg_payload);
 		return -EINVAL;
 	}
@@ -438,7 +438,7 @@ static int pp_hist_lut_set_config(char __iomem *base_addr,
 	char __iomem *hist_addr = NULL, *swap_addr = NULL;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -464,12 +464,12 @@ static int pp_hist_lut_set_config(char __iomem *base_addr,
 	}
 	lut_data = lut_cfg_data->cfg_payload;
 	if (!lut_data) {
-		pr_err("invalid hist_lut cfg_payload %p\n", lut_data);
+		pr_err("invalid hist_lut cfg_payload %pK\n", lut_data);
 		return -EINVAL;
 	}
 
 	if (lut_data->len != ENHIST_LUT_ENTRIES || !lut_data->data) {
-		pr_err("invalid hist_lut len %d data %p\n",
+		pr_err("invalid hist_lut len %d data %pK\n",
 		       lut_data->len, lut_data->data);
 		return -EINVAL;
 	}
@@ -533,7 +533,7 @@ static int pp_dither_set_config(char __iomem *base_addr,
 	uint32_t *pdata = NULL;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -560,7 +560,7 @@ static int pp_dither_set_config(char __iomem *base_addr,
 
 	dither_data = dither_cfg_data->cfg_payload;
 	if (!dither_data) {
-		pr_err("invalid payload for dither %p\n", dither_data);
+		pr_err("invalid payload for dither %pK\n", dither_data);
 		return -EINVAL;
 	}
 
@@ -608,7 +608,7 @@ static int pp_hist_get_config(char __iomem *base_addr, void *cfg_data,
 	struct pp_hist_col_info *hist_info = NULL;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %p cfg_data %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK\n",
 		       base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -646,7 +646,7 @@ static int pp_get_hist_offset(u32 block, u32 *ctl_off)
 	int ret = 0;
 
 	if (!ctl_off) {
-		pr_err("invalid params ctl_off %p\n", ctl_off);
+		pr_err("invalid params ctl_off %pK\n", ctl_off);
 		return -EINVAL;
 	}
 	switch (block) {
@@ -667,7 +667,7 @@ static int pp_get_hist_offset(u32 block, u32 *ctl_off)
 static int pp_get_hist_isr(u32 *isr_mask)
 {
 	if (!isr_mask) {
-		pr_err("invalid params isr_mask %p\n", isr_mask);
+		pr_err("invalid params isr_mask %pK\n", isr_mask);
 		return -EINVAL;
 	}
 
@@ -693,7 +693,7 @@ static int pp_gamut_get_config(char __iomem *base_addr, void *cfg_data,
 	u32 clk_gate_disable = 0;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %p cfg_data %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK\n",
 		       base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -831,7 +831,7 @@ static int pp_gamut_set_config(char __iomem *base_addr,
 	struct mdp_gamut_data_v1_7 *gamut_data = NULL;
 	char __iomem *base_addr_scale = base_addr;
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -853,7 +853,7 @@ static int pp_gamut_set_config(char __iomem *base_addr,
 	gamut_data = (struct mdp_gamut_data_v1_7 *)
 		      gamut_cfg_data->cfg_payload;
 	if (!gamut_data) {
-		pr_err("invalid payload for gamut %p\n", gamut_data);
+		pr_err("invalid payload for gamut %pK\n", gamut_data);
 		return -EINVAL;
 	}
 
@@ -872,7 +872,7 @@ static int pp_gamut_set_config(char __iomem *base_addr,
 	for (i = 0; i < MDP_GAMUT_TABLE_NUM_V1_7; i++) {
 		if (!gamut_data->c0_data[i] || !gamut_data->c1_c2_data[i]
 		    || (gamut_data->tbl_size[i] != tbl_sz)) {
-			pr_err("invalid param for c0 %p c1c2 %p table %d size %d expected sz %d\n",
+			pr_err("invalid param for c0 %pK c1c2 %pK table %d size %d expected sz %d\n",
 			       gamut_data->c0_data[i],
 			       gamut_data->c1_c2_data[i], i,
 			       gamut_data->tbl_size[i], tbl_sz);
@@ -883,7 +883,7 @@ static int pp_gamut_set_config(char __iomem *base_addr,
 		    (!gamut_data->scale_off_data[i] ||
 		    (gamut_data->tbl_scale_off_sz[i] !=
 		    MDP_GAMUT_SCALE_OFF_SZ))) {
-			pr_err("invalid param for scale table %p for c%d size %d expected size%d\n",
+			pr_err("invalid param for scale table %pK for c%d size %d expected size%d\n",
 				gamut_data->scale_off_data[i], i,
 				gamut_data->tbl_scale_off_sz[i],
 				MDP_GAMUT_SCALE_OFF_SZ);
@@ -948,7 +948,7 @@ static int pp_pcc_set_config(char __iomem *base_addr,
 	u32 opmode = 0;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %p cfg_data %p pp_sts %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts %pK\n",
 			base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -963,7 +963,7 @@ static int pp_pcc_set_config(char __iomem *base_addr,
 	}
 	pcc_data = pcc_cfg_data->cfg_payload;
 	if (!pcc_data) {
-		pr_err("invalid payload for pcc %p\n", pcc_data);
+		pr_err("invalid payload for pcc %pK\n", pcc_data);
 		return -EINVAL;
 	}
 
@@ -1033,7 +1033,7 @@ static int pp_pcc_get_config(char __iomem *base_addr, void *cfg_data,
 	struct mdp_pcc_data_v1_7 pcc_data;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %p cfg_data %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK\n",
 		       base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -1230,7 +1230,7 @@ static void pp_pa_set_six_zone(char __iomem *base_addr,
 
 	if (!pa_data->six_zone_len || !pa_data->six_zone_curve_p0 ||
 	    !pa_data->six_zone_curve_p1) {
-		pr_err("Invalid six zone data: len %d curve_p0 %p curve_p1 %p\n",
+		pr_err("Invalid six zone data: len %d curve_p0 %pK curve_p1 %pK\n",
 		       pa_data->six_zone_len,
 		       pa_data->six_zone_curve_p0,
 		       pa_data->six_zone_curve_p1);
@@ -1348,7 +1348,7 @@ static int pp_pa_set_config(char __iomem *base_addr,
 	int ret = 0;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -1373,7 +1373,7 @@ static int pp_pa_set_config(char __iomem *base_addr,
 
 	pa_data = pa_cfg_data->cfg_payload;
 	if (!pa_data) {
-		pr_err("invalid payload for pa %p\n", pa_data);
+		pr_err("invalid payload for pa %pK\n", pa_data);
 		return -EINVAL;
 	}
 
@@ -1622,7 +1622,7 @@ static int pp_pa_get_config(char __iomem *base_addr, void *cfg_data,
 	char __iomem *pa_hold_addr = NULL;
 
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %p cfg_data %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK\n",
 		      base_addr, cfg_data);
 		return -EINVAL;
 	}
@@ -1755,7 +1755,7 @@ static int pp_igc_set_config(char __iomem *base_addr,
 	u32 data;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -1763,7 +1763,7 @@ static int pp_igc_set_config(char __iomem *base_addr,
 	lut_cfg_data = (struct mdp_igc_lut_data *) cfg_data;
 	if (lut_cfg_data->version != mdp_igc_v1_7 ||
 	    !lut_cfg_data->cfg_payload) {
-		pr_err("invalid igc version %d payload %p\n",
+		pr_err("invalid igc version %d payload %pK\n",
 		       lut_cfg_data->version, lut_cfg_data->cfg_payload);
 		return -EINVAL;
 	}
@@ -1782,7 +1782,7 @@ static int pp_igc_set_config(char __iomem *base_addr,
 	lut_data = lut_cfg_data->cfg_payload;
 	if (lut_data->len != IGC_LUT_ENTRIES || !lut_data->c0_c1_data ||
 	    !lut_data->c2_data) {
-		pr_err("invalid lut len %d c0_c1_data %p  c2_data %p\n",
+		pr_err("invalid lut len %d c0_c1_data %pK  c2_data %pK\n",
 		       lut_data->len, lut_data->c0_c1_data, lut_data->c2_data);
 		return -EINVAL;
 	}
@@ -1849,7 +1849,7 @@ static int pp_igc_get_config(char __iomem *base_addr, void *cfg_data,
 	u32 data = 0, sz = 0;
 
 	if (!base_addr || !cfg_data || block_type != DSPP) {
-		pr_err("invalid params base_addr %p cfg_data %p block_type %d\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK block_type %d\n",
 		      base_addr, cfg_data, block_type);
 		return -EINVAL;
 	}
@@ -1861,7 +1861,7 @@ static int pp_igc_get_config(char __iomem *base_addr, void *cfg_data,
 	if (lut_cfg_data->version != mdp_igc_v1_7 ||
 	    !lut_cfg_data->cfg_payload ||
 	    lut_cfg_data->block > IGC_MASK_MAX) {
-		pr_err("invalid igc version %d payload %p block %d\n",
+		pr_err("invalid igc version %d payload %pK block %d\n",
 		       lut_cfg_data->version, lut_cfg_data->cfg_payload,
 		       lut_cfg_data->block);
 		ret = -EINVAL;
@@ -1926,7 +1926,7 @@ static int pp_pgc_set_config(char __iomem *base_addr,
 	struct mdp_pgc_lut_data_v1_7  *pgc_data_v17 = NULL;
 
 	if (!base_addr || !cfg_data || !pp_sts) {
-		pr_err("invalid params base_addr %p cfg_data %p pp_sts_type %p\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK pp_sts_type %pK\n",
 		      base_addr, cfg_data, pp_sts);
 		return -EINVAL;
 	}
@@ -1952,13 +1952,13 @@ static int pp_pgc_set_config(char __iomem *base_addr,
 
 	pgc_data_v17 = (struct mdp_pgc_lut_data_v1_7 *) pgc_data->cfg_payload;
 	if (!pgc_data_v17) {
-		pr_err("invalid payload for GC %p\n", pgc_data_v17);
+		pr_err("invalid payload for GC %pK\n", pgc_data_v17);
 		return -EINVAL;
 	}
 
 	if (pgc_data_v17->len != PGC_LUT_ENTRIES || !pgc_data_v17->c0_data ||
 	    !pgc_data_v17->c1_data || !pgc_data_v17->c2_data) {
-		pr_err("Invalid params entries %d c0_data %p c1_data %p c2_data %p\n",
+		pr_err("Invalid params entries %d c0_data %pK c1_data %pK c2_data %pK\n",
 			pgc_data_v17->len, pgc_data_v17->c0_data,
 			pgc_data_v17->c1_data, pgc_data_v17->c2_data);
 		return -EINVAL;
@@ -2011,7 +2011,7 @@ static int pp_pgc_get_config(char __iomem *base_addr, void *cfg_data,
 	struct mdp_pgc_lut_data *pgc_data = NULL;
 	struct mdp_pgc_lut_data_v1_7  *pgc_data_v17 = NULL;
 	if (!base_addr || !cfg_data) {
-		pr_err("invalid params base_addr %p cfg_data %p block_type %d\n",
+		pr_err("invalid params base_addr %pK cfg_data %pK block_type %d\n",
 		      base_addr, cfg_data, block_type);
 		return -EINVAL;
 	}
@@ -2019,7 +2019,7 @@ static int pp_pgc_get_config(char __iomem *base_addr, void *cfg_data,
 	pgc_data_v17 = (struct mdp_pgc_lut_data_v1_7 *)
 			pgc_data->cfg_payload;
 	if (pgc_data->version != mdp_pgc_v1_7 || !pgc_data_v17) {
-		pr_err("invalid pgc version %d payload %p\n",
+		pr_err("invalid pgc version %d payload %pK\n",
 			pgc_data->version, pgc_data_v17);
 		return -EINVAL;
 	}
@@ -2081,7 +2081,7 @@ static int pp_pgc_get_config(char __iomem *base_addr, void *cfg_data,
 static int pp_pcc_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %p\n", version);
+		pr_err("invalid param version %pK\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_pcc_v1_7;
@@ -2091,7 +2091,7 @@ static int pp_pcc_get_version(u32 *version)
 static int pp_igc_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %p\n", version);
+		pr_err("invalid param version %pK\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_igc_v1_7;
@@ -2101,7 +2101,7 @@ static int pp_igc_get_version(u32 *version)
 static int pp_pgc_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %p\n", version);
+		pr_err("invalid param version %pK\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_pgc_v1_7;
@@ -2111,7 +2111,7 @@ static int pp_pgc_get_version(u32 *version)
 static int pp_pa_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %p\n", version);
+		pr_err("invalid param version %pK\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_pa_v1_7;
@@ -2121,7 +2121,7 @@ static int pp_pa_get_version(u32 *version)
 static int pp_gamut_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %p\n", version);
+		pr_err("invalid param version %pK\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_gamut_v1_7;
@@ -2131,7 +2131,7 @@ static int pp_gamut_get_version(u32 *version)
 static int pp_dither_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %p\n", version);
+		pr_err("invalid param version %pK\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_dither_v1_7;
@@ -2141,7 +2141,7 @@ static int pp_dither_get_version(u32 *version)
 static int pp_hist_lut_get_version(u32 *version)
 {
 	if (!version) {
-		pr_err("invalid param version %p\n", version);
+		pr_err("invalid param version %pK\n", version);
 		return -EINVAL;
 	}
 	*version = mdp_hist_lut_v1_7;
diff --git a/drivers/video/msm/mdss/mdss_mdp_rotator.c b/drivers/video/msm/mdss/mdss_mdp_rotator.c
index ac957a09..e5307da 100644
--- a/drivers/video/msm/mdss/mdss_mdp_rotator.c
+++ b/drivers/video/msm/mdss/mdss_mdp_rotator.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -190,11 +190,11 @@ static struct mdss_mdp_rot_pipe *mdss_mdp_rot_mgr_acquire_pipe(
 			(free_rot_pipe->previous_session != rot);
 
 		rot_pipe = free_rot_pipe;
-		pr_debug("find a free pipe %p\n", rot_pipe->pipe);
+		pr_debug("find a free pipe %pK\n", rot_pipe->pipe);
 	} else {
 		rot_pipe = busy_rot_pipe;
 		if (rot_pipe)
-			pr_debug("find a busy pipe %p\n", rot_pipe->pipe);
+			pr_debug("find a busy pipe %pK\n", rot_pipe->pipe);
 	}
 
 	if (rot_pipe)
diff --git a/drivers/video/msm/mdss/mdss_mdp_util.c b/drivers/video/msm/mdss/mdss_mdp_util.c
index fba7c86..af4920cd 100644
--- a/drivers/video/msm/mdss/mdss_mdp_util.c
+++ b/drivers/video/msm/mdss/mdss_mdp_util.c
@@ -1052,7 +1052,7 @@ static int mdss_mdp_put_img(struct mdss_mdp_img_data *data, bool rotator,
 		pr_debug("pmem buf=0x%pa\n", &data->addr);
 		memset(&data->srcp_f, 0, sizeof(struct fd));
 	} else if (!IS_ERR_OR_NULL(data->srcp_dma_buf)) {
-		pr_debug("ion hdl=%p buf=0x%pa\n", data->srcp_dma_buf,
+		pr_debug("ion hdl=%pK buf=0x%pa\n", data->srcp_dma_buf,
 							&data->addr);
 		if (!iclient) {
 			pr_err("invalid ion client\n");
@@ -1211,8 +1211,9 @@ static int mdss_mdp_get_img(struct msmfb_data *img,
 		data->addr += data->offset;
 		data->len -= data->offset;
 
-		pr_debug("mem=%d ihdl=%p buf=0x%pa len=0x%lx\n", img->memory_id,
-			 data->srcp_dma_buf, &data->addr, data->len);
+		pr_debug("mem=%d ihdl=%pK buf=0x%pa len=0x%lx\n",
+			 img->memory_id, data->srcp_dma_buf,
+			 &data->addr, data->len);
 	} else {
 		mdss_mdp_put_img(data, rotator, dir);
 		return ret ? : -EOVERFLOW;
@@ -1267,7 +1268,7 @@ static int mdss_mdp_map_buffer(struct mdss_mdp_img_data *data, bool rotator,
 		data->addr += data->offset;
 		data->len -= data->offset;
 
-		pr_debug("ihdl=%p buf=0x%pa len=0x%lx\n",
+		pr_debug("ihdl=%pK buf=0x%pa len=0x%lx\n",
 			 data->srcp_dma_buf, &data->addr, data->len);
 	} else {
 		mdss_mdp_put_img(data, rotator, dir);
diff --git a/drivers/video/msm/mdss/mdss_mdp_wb.c b/drivers/video/msm/mdss/mdss_mdp_wb.c
index c9b6945..993b8d6 100644
--- a/drivers/video/msm/mdss/mdss_mdp_wb.c
+++ b/drivers/video/msm/mdss/mdss_mdp_wb.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -95,7 +95,7 @@ struct mdss_mdp_data *mdss_mdp_wb_debug_buffer(struct msm_fb_data_type *mfd)
 		ihdl = ion_alloc(iclient, img_size, SZ_4K,
 				 ION_HEAP(ION_SF_HEAP_ID), 0);
 		if (IS_ERR_OR_NULL(ihdl)) {
-			pr_err("unable to alloc fbmem from ion (%p)\n", ihdl);
+			pr_err("unable to alloc fbmem from ion (%pK)\n", ihdl);
 			return NULL;
 		}
 
@@ -122,7 +122,7 @@ struct mdss_mdp_data *mdss_mdp_wb_debug_buffer(struct msm_fb_data_type *mfd)
 			img->len = img_size;
 		}
 
-		pr_debug("ihdl=%p virt=%p phys=0x%pa iova=0x%pa size=%u\n",
+		pr_debug("ihdl=%pK virt=%pK phys=0x%pa iova=0x%pa size=%u\n",
 			 ihdl, videomemory, &mdss_wb_mem, &img->addr, img_size);
 	}
 	return &mdss_wb_buffer;
@@ -437,7 +437,7 @@ static struct mdss_mdp_wb_data *get_user_node(struct msm_fb_data_type *mfd,
 		list_for_each_entry(node, &wb->register_queue, registered_entry)
 			if ((node->buf_data.p[0].srcp_ihdl == ihdl) &&
 				    (node->buf_info.offset == data->offset)) {
-				pr_debug("found fd=%d hdl=%p off=%x addr=%pa\n",
+				pr_debug("found fd=%d hdl=%pK off=%x addr=%pa\n",
 						data->memory_id, ihdl,
 						data->offset,
 						&node->buf_data.p[0].addr);
@@ -513,7 +513,7 @@ static void mdss_mdp_wb_free_node(struct mdss_mdp_wb_data *node)
 	if (node->user_alloc) {
 		buf = &node->buf_data.p[0];
 
-		pr_debug("free user mem_id=%d ihdl=%p, offset=%u addr=0x%pa\n",
+		pr_debug("free user mem_id=%d ihdl=%pK, offset=%u addr=0x%pa\n",
 				node->buf_info.memory_id,
 				buf->srcp_ihdl,
 				node->buf_info.offset,
diff --git a/drivers/video/msm/mdss/mdss_util.c b/drivers/video/msm/mdss/mdss_util.c
index 3a9ff9b..2f9dd44 100644
--- a/drivers/video/msm/mdss/mdss_util.c
+++ b/drivers/video/msm/mdss/mdss_util.c
@@ -33,7 +33,7 @@ int mdss_register_irq(struct mdss_hw *hw)
 	if (!mdss_irq_handlers[hw->hw_ndx])
 		mdss_irq_handlers[hw->hw_ndx] = hw;
 	else
-		pr_err("panel %d's irq at %p is already registered\n",
+		pr_err("panel %d's irq at %pK is already registered\n",
 			hw->hw_ndx, hw->irq_handler);
 	spin_unlock_irqrestore(&mdss_lock, irq_flags);
 
diff --git a/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c b/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
index 1514f02..d3dc874 100644
--- a/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
+++ b/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
@@ -1,7 +1,7 @@
 /*
  * SiI8620 Linux Driver
  *
- * Copyright (C) 2013-2014 Silicon Image, Inc.
+ * Copyright (C) 2013-2014, 2016 Silicon Image, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -5599,7 +5599,7 @@ static int is_timer_handle_valid(struct mhl_dev_context *dev_context,
 	}
 
 	if (timer != timer_handle) {
-		MHL_TX_DBG_WARN("Invalid timer handle %p received\n",
+		MHL_TX_DBG_WARN("Invalid timer handle %pK received\n",
 				timer_handle);
 		return -EINVAL;
 	}
diff --git a/drivers/video/msm/mdss/mhl3/mhl_supp.c b/drivers/video/msm/mdss/mhl3/mhl_supp.c
index 7055d8cd..de0e207 100644
--- a/drivers/video/msm/mdss/mhl3/mhl_supp.c
+++ b/drivers/video/msm/mdss/mhl3/mhl_supp.c
@@ -1,7 +1,7 @@
 /*
  * SiI8620 Linux Driver
  *
- * Copyright (C) 2013-2014 Silicon Image, Inc.
+ * Copyright (C) 2013-2014, 2016 Silicon Image, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -185,7 +185,7 @@ static struct cbus_req *get_free_cbus_queue_entry_impl(
 	req->function = function;
 	req->line = line;
 	req->sequence = dev_context->sequence++;
-	/*MHL_TX_DBG_ERR(,"q %d get:0x%p %s:%d\n",
+	/*MHL_TX_DBG_ERR(,"q %d get:0x%pK %s:%d\n",
 		req->sequence,req,function,line); */
 	return req;
 }
@@ -197,7 +197,7 @@ static void return_cbus_queue_entry_impl(struct mhl_dev_context *dev_context,
 					 struct cbus_req *pReq,
 					 const char *function, int line)
 {
-	/* MHL_TX_DBG_ERR(,"q ret:0x%p %s:%d\n",pReq,function,line); */
+	/* MHL_TX_DBG_ERR(,"q ret:0x%pK %s:%d\n",pReq,function,line); */
 	list_add(&pReq->link, &dev_context->cbus_free_list);
 
 }
@@ -372,7 +372,7 @@ static struct block_req *start_new_block_marshalling_req_impl(
 	    sizeof(payload->as_bytes) -
 	    sizeof(struct SI_PACK_THIS_STRUCT standard_transport_header_t);
 	dev_context->block_protocol.marshalling_req = req;
-	MHL_TX_DBG_WARN("q %d get:0x%p %s:%d\n", req->sequence, req, function,
+	MHL_TX_DBG_WARN("q %d get:0x%pK %s:%d\n", req->sequence, req, function,
 			line);
 	return req;
 }
@@ -384,7 +384,7 @@ static void return_block_queue_entry_impl(struct mhl_dev_context *dev_context,
 					  struct block_req *pReq,
 					  const char *function, int line)
 {
-	/* MHL_TX_DBG_ERR(,"q ret:0x%p %s:%d\n",pReq,function,line); */
+	/* MHL_TX_DBG_ERR(,"q ret:0x%pK %s:%d\n",pReq,function,line); */
 	list_add(&pReq->link, &dev_context->block_protocol.free_list);
 
 }
@@ -1283,7 +1283,7 @@ void si_mhl_tx_drive_states(struct mhl_dev_context *dev_context)
 	if (req == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("req: %p\n", req);
+	MHL_TX_DBG_INFO("req: %pK\n", req);
 	/* coordinate write burst requests and grants. */
 	if (MHL_MSC_MSG == req->command) {
 		dev_context->msc_msg_last_data = req->msg_data[1];
@@ -1298,7 +1298,7 @@ void si_mhl_tx_drive_states(struct mhl_dev_context *dev_context)
 		}
 	}
 
-	MHL_TX_DBG_INFO("req: %p\n", req);
+	MHL_TX_DBG_INFO("req: %pK\n", req);
 	if (req) {
 		uint8_t ret_val;
 		dev_context->current_cbus_req = req;
diff --git a/drivers/video/msm/mdss/mhl3/platform.c b/drivers/video/msm/mdss/mhl3/platform.c
index c0e5174..16ce64e 100644
--- a/drivers/video/msm/mdss/mhl3/platform.c
+++ b/drivers/video/msm/mdss/mhl3/platform.c
@@ -1,7 +1,7 @@
 /*
  * SiI8620 Linux Driver
  *
- * Copyright (C) 2013-2014 Silicon Image, Inc.
+ * Copyright (C) 2013-2014, 2016 Silicon Image, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -1590,7 +1590,7 @@ static int __devinit si_8620_mhl_tx_i2c_probe(struct i2c_client *client,
 {
 	int ret;
 
-	pr_info("%s(), i2c_device_id = %p\n", __func__, id);
+	pr_info("%s(), i2c_device_id = %pK\n", __func__, id);
 
 #if defined(SIMG_USE_DTS)
 	/*
@@ -1844,7 +1844,7 @@ static int __devinit si_8620_mhl_tx_spi_probe(struct spi_device *spi)
 {
 	int ret;
 
-	pr_info("%s(), spi = %p\n", __func__, spi);
+	pr_info("%s(), spi = %pK\n", __func__, spi);
 	spi->bits_per_word = 8;
 	spi_dev = spi;
 	spi_bus_num = spi->master->bus_num;
@@ -2161,7 +2161,7 @@ static void __exit si_8620_exit(void)
 		for (idx = 0; idx < ARRAY_SIZE(device_addresses); idx++) {
 			MHL_TX_DBG_INFO("\n");
 			if (device_addresses[idx].client != NULL) {
-				MHL_TX_DBG_INFO("unregistering device:%p\n",
+				MHL_TX_DBG_INFO("unregistering device:%pK\n",
 						device_addresses[idx].client);
 				i2c_unregister_device(device_addresses[idx].
 						      client);
diff --git a/drivers/video/msm/mdss/mhl3/si_8620_drv.c b/drivers/video/msm/mdss/mhl3/si_8620_drv.c
index dd71f1b..9d68f28 100644
--- a/drivers/video/msm/mdss/mhl3/si_8620_drv.c
+++ b/drivers/video/msm/mdss/mhl3/si_8620_drv.c
@@ -2367,7 +2367,7 @@ int si_mhl_tx_drv_get_edid_fifo_partial_block(struct drv_hw_context *hw_context,
 	offset = EDID_BLOCK_SIZE * (hw_context->edid_fifo_block_number & 0x01);
 	offset += start;
 
-	MHL_TX_DBG_INFO("%p %p\n", hw_context, edid_buf);
+	MHL_TX_DBG_INFO("%pK %pK\n", hw_context, edid_buf);
 	if (EDID_BLOCK_SIZE == (offset + length))
 		hw_context->edid_fifo_block_number++;
 
@@ -2401,7 +2401,7 @@ int si_mhl_tx_drv_get_edid_fifo_next_block(struct drv_hw_context *hw_context,
 
 	offset = EDID_BLOCK_SIZE * (hw_context->edid_fifo_block_number & 0x01);
 
-	MHL_TX_DBG_INFO("%p %p\n", hw_context, edid_buf);
+	MHL_TX_DBG_INFO("%pK %pK\n", hw_context, edid_buf);
 	hw_context->edid_fifo_block_number++;
 
 #ifdef MANUAL_EDID_FETCH
diff --git a/drivers/video/msm/mdss/mhl3/si_emsc_hid.c b/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
index 17d33c9..52acb26 100644
--- a/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
+++ b/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
@@ -1,8 +1,8 @@
 /*
  * MHL3 HID Tunneling implementation
  *
- * Copyright (c) 2013-2014 Lee Mulcahy <william.mulcahy@siliconimage.com>
- * Copyright (c) 2013-2014 Silicon Image, Inc
+ * Copyright (c) 2013-2014, 2016 Lee Mulcahy <william.mulcahy@siliconimage.com>
+ * Copyright (c) 2013-2014, 2016 Silicon Image, Inc
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -461,7 +461,7 @@ static int mhl3_send_ack(struct mhl3_hid_data *mhid, uint8_t reason)
 		return -ENODEV;
 
 	MHL3_HID_DBG_WARN("%s - HID_ACK reason code: %02X\n", __func__, reason);
-	MHL3_HID_DBG_ERR("mhid->mdev: %p\n", mhid->mdev);
+	MHL3_HID_DBG_ERR("mhid->mdev: %pK\n", mhid->mdev);
 	mhid->out_data[0] = MHL3_HID_ACK;
 	mhid->out_data[1] = reason;
 
@@ -1089,7 +1089,7 @@ mhid_cleanup:
 	mhl3_send_ack(mhid, HID_ACK_NODEV);
 
 	mhid->flags |= HID_FLAGS_WQ_CANCEL;
-	MHL3_HID_DBG_ERR("WORK QUEUE function FAIL - mhid: %p\n", mhid);
+	MHL3_HID_DBG_ERR("WORK QUEUE function FAIL - mhid: %pK\n", mhid);
 	mhl3_disconnect_and_destroy_hid_device(mhid);
 
 	/*
diff --git a/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c b/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
index 13d2a08..573684a1 100644
--- a/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
+++ b/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
@@ -1,7 +1,7 @@
 /*
  * SiI8620 Linux Driver
  *
- * Copyright (C) 2013-2014 Silicon Image, Inc.
+ * Copyright (C) 2013-2014, 2016 Silicon Image, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -80,10 +80,11 @@ static void destroy_mouse(struct mhl_dev_context *dev_context)
 	if (dev_context->mdt_devs.dev_mouse == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering mouse: %p\n",
+	MHL_TX_DBG_INFO("Unregistering mouse: %pK\n",
 			dev_context->mdt_devs.dev_mouse);
 	input_unregister_device(dev_context->mdt_devs.dev_mouse);
-	MHL_TX_DBG_INFO("Freeing mouse: %p\n", dev_context->mdt_devs.dev_mouse);
+	MHL_TX_DBG_INFO("Freeing mouse: %pK\n",
+			 dev_context->mdt_devs.dev_mouse);
 	input_free_device(dev_context->mdt_devs.dev_mouse);
 	dev_context->mdt_devs.dev_mouse = NULL;
 }
@@ -93,10 +94,10 @@ static void destroy_keyboard(struct mhl_dev_context *dev_context)
 	if (dev_context->mdt_devs.dev_keyboard == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering keyboard: %p\n",
+	MHL_TX_DBG_INFO("Unregistering keyboard: %pK\n",
 			dev_context->mdt_devs.dev_keyboard);
 	input_unregister_device(dev_context->mdt_devs.dev_keyboard);
-	MHL_TX_DBG_INFO("Freeing keyboard: %p\n",
+	MHL_TX_DBG_INFO("Freeing keyboard: %pK\n",
 			dev_context->mdt_devs.dev_keyboard);
 	input_free_device(dev_context->mdt_devs.dev_keyboard);
 	dev_context->mdt_devs.dev_keyboard = NULL;
@@ -107,10 +108,10 @@ static void destroy_touchscreen(struct mhl_dev_context *dev_context)
 	if (dev_context->mdt_devs.dev_touchscreen == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering mouse: %p\n",
+	MHL_TX_DBG_INFO("Unregistering mouse: %pK\n",
 			dev_context->mdt_devs.dev_touchscreen);
 	input_unregister_device(dev_context->mdt_devs.dev_touchscreen);
-	MHL_TX_DBG_INFO("Freeing mouse: %p\n",
+	MHL_TX_DBG_INFO("Freeing mouse: %pK\n",
 			dev_context->mdt_devs.dev_touchscreen);
 	input_free_device(dev_context->mdt_devs.dev_touchscreen);
 	dev_context->mdt_devs.dev_touchscreen = NULL;
@@ -130,7 +131,7 @@ int init_mdt_keyboard(struct mhl_dev_context *dev_context)
 		MHL_TX_DBG_ERR("Not enough memory\n");
 		return -ENOMEM;
 	}
-	MHL_TX_DBG_INFO("Allocated keyboard: %p\n", dev_keyboard);
+	MHL_TX_DBG_INFO("Allocated keyboard: %pK\n", dev_keyboard);
 
 	set_bit(EV_KEY, dev_keyboard->evbit);
 	set_bit(EV_REP, dev_keyboard->evbit);
@@ -158,7 +159,7 @@ int init_mdt_keyboard(struct mhl_dev_context *dev_context)
 		return error;
 	}
 
-	MHL_TX_DBG_INFO("Registered keyboard: %p\n", dev_keyboard);
+	MHL_TX_DBG_INFO("Registered keyboard: %pK\n", dev_keyboard);
 
 	dev_context->mdt_devs.dev_keyboard = dev_keyboard;
 
@@ -175,7 +176,7 @@ int init_mdt_mouse(struct mhl_dev_context *dev_context)
 		MHL_TX_DBG_ERR("Not enough memory\n");
 		return -ENOMEM;
 	}
-	MHL_TX_DBG_INFO("Allocated mouse: %p\n", dev_mouse);
+	MHL_TX_DBG_INFO("Allocated mouse: %pK\n", dev_mouse);
 
 	set_bit(EV_REL, dev_mouse->evbit);
 	set_bit(EV_KEY, dev_mouse->evbit);
@@ -208,7 +209,7 @@ int init_mdt_mouse(struct mhl_dev_context *dev_context)
 		return error;
 	}
 
-	MHL_TX_DBG_INFO("Registered mouse: %p\n", dev_mouse);
+	MHL_TX_DBG_INFO("Registered mouse: %pK\n", dev_mouse);
 
 	dev_context->mdt_devs.dev_mouse = dev_mouse;
 
@@ -226,7 +227,7 @@ int init_mdt_touchscreen(struct mhl_dev_context *dev_context)
 		return -ENOMEM;
 	}
 
-	MHL_TX_DBG_INFO("Allocated touch screen: %p\n", dev_touchscreen);
+	MHL_TX_DBG_INFO("Allocated touch screen: %pK\n", dev_touchscreen);
 
 #if !defined(SINGLE_TOUCH) && defined(KERNEL_2_6_38_AND_LATER)
 	input_mt_init_slots(dev_touchscreen, MAX_TOUCH_CONTACTS);
@@ -301,7 +302,7 @@ int init_mdt_touchscreen(struct mhl_dev_context *dev_context)
 		input_free_device(dev_touchscreen);
 		return error;
 	}
-	MHL_TX_DBG_INFO("Registered touchscreen: %p\n", dev_touchscreen);
+	MHL_TX_DBG_INFO("Registered touchscreen: %pK\n", dev_touchscreen);
 
 	dev_context->mdt_devs.dev_touchscreen = dev_touchscreen;
 
diff --git a/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c b/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
index fd6918f..0e7a35c 100644
--- a/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
+++ b/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
@@ -1,7 +1,7 @@
 /*
  * SiI8620 Linux Driver
  *
- * Copyright (C) 2013-2014 Silicon Image, Inc.
+ * Copyright (C) 2013-2014, 2016 Silicon Image, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -1118,7 +1118,7 @@ static void tx_prune_dtd_list(struct edid_3d_data_t *mhl_edid_3d_data,
 			if ((0 != p_desc->dtd.pixel_clock_low) ||
 				(0 != p_desc->dtd.pixel_clock_high)) {
 				MHL_TX_EDID_INFO(
-					"pix clock non-zero p_desc:%p", p_desc)
+					"pix clock non-zero p_desc:%pK", p_desc)
 				if ((0 == p_desc->dtd.horz_active_7_0) &&
 				    (0 == p_desc->dtd.horz_active_blanking_high.
 					horz_active_11_8)) {
@@ -1133,7 +1133,7 @@ static void tx_prune_dtd_list(struct edid_3d_data_t *mhl_edid_3d_data,
 						 * one by one
 						 */
 						MHL_TX_EDID_INFO(
-						"p_desc:%p p_next_desc:%p\n",
+						"p_desc:%pK p_next_desc:%pK\n",
 						p_desc, p_next_desc)
 						*p_desc++ = *p_next_desc++;
 					}
@@ -1144,7 +1144,7 @@ static void tx_prune_dtd_list(struct edid_3d_data_t *mhl_edid_3d_data,
 					p_desc = p_holder;
 				} else {
 					p_desc++;
-					MHL_TX_EDID_INFO("p_desc:%p\n", p_desc)
+					MHL_TX_EDID_INFO("p_desc:%pK\n", p_desc)
 				}
 			}
 		}
@@ -1446,7 +1446,7 @@ static bool si_mhl_tx_parse_detailed_timing_descriptor(
 			 * Mark this mode for pruning by setting
 			 * horizontal active to zero
 			 */
-			MHL_TX_DBG_ERR("%smark for pruning%s %p\n",
+			MHL_TX_DBG_ERR("%smark for pruning%s %pK\n",
 				ANSI_ESC_YELLOW_TEXT,
 				ANSI_ESC_RESET_TEXT,
 				p_desc);
@@ -1500,7 +1500,7 @@ static uint8_t si_mhl_tx_parse_861_long_descriptors(
 				++mhl_edid_3d_data->parse_data.
 				    num_cea_861_timing_dtds;
 			} else if (valid) {
-				MHL_TX_EDID_INFO("stopping at %p\n",
+				MHL_TX_EDID_INFO("stopping at %pK\n",
 					p_data_u.p_long_descriptors)
 				break;
 			}
@@ -1600,7 +1600,7 @@ static void prune_hdmi_vsdb_vic_list(
 		HDMI_VIC_len = inner_loop_limit;
 	p_CEA_extension->byte_offset_to_18_byte_descriptors -=
 	    num_HDMI_VICs_pruned;
-	MHL_TX_EDID_INFO("%p\n", mhl_edid_3d_data->parse_data.p_HDMI_vsdb);
+	MHL_TX_EDID_INFO("%pK\n", mhl_edid_3d_data->parse_data.p_HDMI_vsdb);
 	if (mhl_edid_3d_data->parse_data.p_HDMI_vsdb) {
 		mhl_edid_3d_data->parse_data.p_HDMI_vsdb->
 		    header.fields.length_following_header -=
@@ -1722,8 +1722,7 @@ static void prune_svd_list(
 					   ("\n\nInvalid extension size\n\n"));
 				while (pb_src < pb_limit) {
 					MHL_TX_EDID_INFO(
-					    "moving data up %p(0x%02X) "
-					    "<- %p(0x%02X)\n",
+					    "moving data up %pK(0x%02X)<- %pK(0x%02X)\n",
 					    pb_dest, (uint16_t)*pb_dest,
 					    pb_src, (uint16_t)*pb_src);
 					*pb_dest++ = *pb_src++;
@@ -3123,7 +3122,7 @@ void si_mhl_tx_process_hev_vic_burst(struct edid_3d_data_t *mhl_edid_3d_data,
 				     ANSI_ESC_RED_TEXT, ANSI_ESC_RESET_TEXT);
 				return;
 			} else {
-				MHL_TX_DBG_WARN(" %d %p\n", hev_index,
+				MHL_TX_DBG_WARN(" %d %pK\n", hev_index,
 					mhl_edid_3d_data->hev_vic_list)
 				mhl_edid_3d_data->hev_vic_info.
 				    num_items_allocated =
@@ -3136,7 +3135,7 @@ void si_mhl_tx_process_hev_vic_burst(struct edid_3d_data_t *mhl_edid_3d_data,
 		MHL_TX_DBG_ERR("bogus write burst, no hev_vic_list\n")
 		return;
 	}
-	MHL_TX_DBG_WARN(" %d %p\n", hev_index, mhl_edid_3d_data->hev_vic_list)
+	MHL_TX_DBG_WARN(" %d %pK\n", hev_index, mhl_edid_3d_data->hev_vic_list)
 	if (NULL == mhl_edid_3d_data->hev_vic_list) {
 		MHL_TX_DBG_ERR("%s no place to put HEV_VIC burst%s\n",
 			       ANSI_ESC_RED_TEXT, ANSI_ESC_RESET_TEXT);
@@ -3155,7 +3154,7 @@ void si_mhl_tx_process_hev_vic_burst(struct edid_3d_data_t *mhl_edid_3d_data,
 		     burst_id_HEV_VIC,
 		     (union video_burst_descriptor_u *) &p_burst->
 		     video_descriptors[i])) {
-			MHL_TX_DBG_INFO(" %d %p\n",
+			MHL_TX_DBG_INFO(" %d %pK\n",
 				hev_index, mhl_edid_3d_data->hev_vic_list)
 			mhl_edid_3d_data->hev_vic_list[hev_index].
 			    mhl3_hev_vic_descriptor =
@@ -4036,7 +4035,7 @@ static uint8_t parse_861_block(struct edid_3d_data_t *mhl_edid_3d_data,
 
 	mhl_edid_3d_data->parse_data.p_HDMI_vsdb = NULL;
 
-	MHL_TX_EDID_INFO("tag:place holder EDID block:%p\n", p_EDID_block_data);
+	MHL_TX_EDID_INFO("tag:place holdr EDID block:%pK\n", p_EDID_block_data);
 	if (EDID_EXTENSION_BLOCK_MAP == p_CEA_extension->tag) {
 		struct block_map_t *p_block_map;
 		int i;
@@ -4123,7 +4122,7 @@ void si_mhl_tx_handle_atomic_hw_edid_read_complete(
 		     mhl_edid_3d_data->parse_data.num_EDID_extensions;
 		     ++counter) {
 			MHL_TX_EDID_INFO
-			    (" counter:%d tag:place holder EDID block:%p\n",
+			    (" counter:%d tag:place holder EDID block:%pK\n",
 			     counter,
 			     &mhl_edid_3d_data->
 			     EDID_block_data[EDID_BLOCK_SIZE * counter]);
-- 
cgit v1.1

