From 7092494f44f15cde7213a0256bbfa16721df928c Mon Sep 17 00:00:00 2001
From: Ben Romberger <bromberg@codeaurora.org>
Date: Wed, 18 May 2016 17:15:50 -0700
Subject: [PATCH] ASoC: msm: qdsp6v2: Change audio drivers to use %pK

Change all qdsp6v2 audio driver to use %pK instead
of %p. %pK hides addresses when the users doesn't
have kernel permissions. If address information
is needed echo 0 > /proc/sys/kernel/kptr_restrict.

Change-Id: I101bb5142863b866a9f4e62b45b363920bb6a5bf
Signed-off-by: Ben Romberger <bromberg@codeaurora.org>
Signed-off-by: Surendar karka <sukark@codeaurora.org>
[haggertk]: Port to klte kernel sources
CVE-2016-8410
Signed-off-by: Kevin F. Haggerty <haggertk@lineageos.org>
---
 arch/arm/mach-msm/qdsp6v2/amrwb_in.c        |   2 +-
 arch/arm/mach-msm/qdsp6v2/apr.c             |  10 +-
 arch/arm/mach-msm/qdsp6v2/audio_aac.c       |   4 +-
 arch/arm/mach-msm/qdsp6v2/audio_amrnb.c     |   4 +-
 arch/arm/mach-msm/qdsp6v2/audio_amrwb.c     |   4 +-
 arch/arm/mach-msm/qdsp6v2/audio_amrwbplus.c |   4 +-
 arch/arm/mach-msm/qdsp6v2/audio_evrc.c      |   4 +-
 arch/arm/mach-msm/qdsp6v2/audio_lpa.c       |  26 +--
 arch/arm/mach-msm/qdsp6v2/audio_mp3.c       |   4 +-
 arch/arm/mach-msm/qdsp6v2/audio_qcelp.c     |   4 +-
 arch/arm/mach-msm/qdsp6v2/audio_utils.c     |   2 +-
 arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c | 188 ++++++++++----------
 arch/arm/mach-msm/qdsp6v2/audio_wma.c       |   4 +-
 arch/arm/mach-msm/qdsp6v2/audio_wmapro.c    |   2 +-
 arch/arm/mach-msm/qdsp6v2/dsp_debug.c       |   2 +-
 arch/arm/mach-msm/qdsp6v2/msm_audio_ion.c   |  30 ++--
 arch/arm/mach-msm/qdsp6v2/pcm_in.c          |   2 +-
 arch/arm/mach-msm/qdsp6v2/q6audio_v1_aio.c  |  20 +--
 arch/arm/mach-msm/qdsp6v2/q6audio_v2_aio.c  |  20 +--
 arch/arm/mach-msm/qdsp6v2/q6core.c          |   6 +-
 20 files changed, 171 insertions(+), 171 deletions(-)

diff --git a/arch/arm/mach-msm/qdsp6v2/amrwb_in.c b/arch/arm/mach-msm/qdsp6v2/amrwb_in.c
index ea3fe5b8406..b2253935eb8 100644
--- a/arch/arm/mach-msm/qdsp6v2/amrwb_in.c
+++ b/arch/arm/mach-msm/qdsp6v2/amrwb_in.c
@@ -195,7 +195,7 @@ static int amrwb_in_open(struct inode *inode, struct file *file)
 				(void *)audio);
 
 	if (!audio->ac) {
-		pr_err("%s:audio[%p]: Could not allocate memory for audio"
+		pr_err("%s:audio[%pK]: Could not allocate memory for audio"
 			"client\n", __func__, audio);
 		kfree(audio->enc_cfg);
 		kfree(audio);
diff --git a/arch/arm/mach-msm/qdsp6v2/apr.c b/arch/arm/mach-msm/qdsp6v2/apr.c
index d3119bccff6..e213b5cec8d 100644
--- a/arch/arm/mach-msm/qdsp6v2/apr.c
+++ b/arch/arm/mach-msm/qdsp6v2/apr.c
@@ -341,7 +341,7 @@ void apr_cb_func(void *buf, int len, void *priv)
 	pr_debug("\n*****************\n");
 
 	if (!buf || len <= APR_HDR_SIZE) {
-		pr_err("APR: Improper apr pkt received:%p %d\n", buf, len);
+		pr_err("APR: Improper apr pkt received:%pK %d\n", buf, len);
 		return;
 	}
 	hdr = buf;
@@ -425,7 +425,7 @@ void apr_cb_func(void *buf, int len, void *priv)
 		return;
 	}
 	pr_debug("svc_idx = %d\n", i);
-	pr_debug("%x %x %x %p %p\n", c_svc->id, c_svc->dest_id,
+	pr_debug("%x %x %x %pK %pK\n", c_svc->id, c_svc->dest_id,
 		 c_svc->client_id, c_svc->fn, c_svc->priv);
 	data.payload_size = hdr->pkt_size - hdr_size;
 	data.opcode = hdr->opcode;
@@ -489,7 +489,7 @@ static void apr_reset_deregister(struct work_struct *work)
 			container_of(work, struct apr_reset_work, work);
 
 	handle = apr_reset->handle;
-	pr_debug("%s:handle[%p]\n", __func__, handle);
+	pr_debug("%s:handle[%pK]\n", __func__, handle);
 	apr_deregister(handle);
 	kfree(apr_reset);
 }
@@ -522,7 +522,7 @@ int apr_deregister(void *handle)
 		client[dest_id][client_id].svc_cnt--;
 		if (!client[dest_id][client_id].svc_cnt) {
 			svc->need_reset = 0x0;
-			pr_debug("%s: service is reset %p\n", __func__, svc);
+			pr_debug("%s: service is reset %pK\n", __func__, svc);
 		}
 	}
 
@@ -550,7 +550,7 @@ void apr_reset(void *handle)
 
 	if (!handle)
 		return;
-	pr_debug("%s: handle[%p]\n", __func__, handle);
+	pr_debug("%s: handle[%pK]\n", __func__, handle);
 
 	if (apr_reset_workqueue == NULL) {
 		pr_err("%s: apr_reset_workqueue is NULL\n", __func__);
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_aac.c b/arch/arm/mach-msm/qdsp6v2/audio_aac.c
index d95c3565672..856f682f901 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_aac.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_aac.c
@@ -182,10 +182,10 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 		if (rc)
-			pr_err("%s[%p]:Failed in utils_ioctl: %d\n",
+			pr_err("%s[%pK]:Failed in utils_ioctl: %d\n",
 				__func__, audio, rc);
 	}
 	return rc;
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_amrnb.c b/arch/arm/mach-msm/qdsp6v2/audio_amrnb.c
index 5d572939959..26240ec410c 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_amrnb.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_amrnb.c
@@ -30,7 +30,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	switch (cmd) {
 	case AUDIO_START: {
-		pr_debug("%s[%p]: AUDIO_START session_id[%d]\n", __func__,
+		pr_debug("%s[%pK]: AUDIO_START session_id[%d]\n", __func__,
 						audio, audio->ac->session);
 		if (audio->feedback == NON_TUNNEL_MODE) {
 			/* Configure PCM output block */
@@ -59,7 +59,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 	}
 	return rc;
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_amrwb.c b/arch/arm/mach-msm/qdsp6v2/audio_amrwb.c
index d2728b7c670..9b5bca64e3c 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_amrwb.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_amrwb.c
@@ -31,7 +31,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	switch (cmd) {
 	case AUDIO_START: {
-		pr_debug("%s[%p]: AUDIO_START session_id[%d]\n", __func__,
+		pr_debug("%s[%pK]: AUDIO_START session_id[%d]\n", __func__,
 						audio, audio->ac->session);
 		if (audio->feedback == NON_TUNNEL_MODE) {
 			/* Configure PCM output block */
@@ -62,7 +62,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 	}
 	return rc;
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_amrwbplus.c b/arch/arm/mach-msm/qdsp6v2/audio_amrwbplus.c
index 8169914fc3b..c1a386f7c2d 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_amrwbplus.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_amrwbplus.c
@@ -50,7 +50,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	switch (cmd) {
 	case AUDIO_START: {
-		pr_err("%s[%p]: AUDIO_START session_id[%d]\n", __func__,
+		pr_err("%s[%pK]: AUDIO_START session_id[%d]\n", __func__,
 			audio, audio->ac->session);
 		if (audio->feedback == NON_TUNNEL_MODE) {
 			/* Configure PCM output block */
@@ -134,7 +134,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 	}
 	return rc;
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_evrc.c b/arch/arm/mach-msm/qdsp6v2/audio_evrc.c
index 2de2178936a..83c26001298 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_evrc.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_evrc.c
@@ -33,7 +33,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	switch (cmd) {
 	case AUDIO_START: {
-		pr_debug("%s[%p]: AUDIO_START session_id[%d]\n", __func__,
+		pr_debug("%s[%pK]: AUDIO_START session_id[%d]\n", __func__,
 						audio, audio->ac->session);
 		if (audio->feedback == NON_TUNNEL_MODE) {
 			/* Configure PCM output block */
@@ -64,7 +64,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 	}
 	return rc;
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_lpa.c b/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
index afdfd6d9304..3fffe215d52 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
@@ -441,9 +441,9 @@ static int audlpa_ion_check(struct audio *audio,
 	list_for_each_entry(region_elt, &audio->ion_region_queue, list) {
 		if (CONTAINS(region_elt, &t) || CONTAINS(&t, region_elt) ||
 		    OVERLAPS(region_elt, &t)) {
-			pr_err("%s[%p]:region (vaddr %p len %ld)"
+			pr_err("%s[%pK]:region (vaddr %pK len %ld)"
 			" clashes with registered region"
-			" (vaddr %p paddr %p len %ld)\n",
+			" (vaddr %pK paddr %pK len %ld)\n",
 			__func__, audio, vaddr, len,
 			region_elt->vaddr,
 			(void *)region_elt->paddr, region_elt->len);
@@ -465,7 +465,7 @@ static int audlpa_ion_add(struct audio *audio,
 	unsigned long ionflag;
 	void *temp_ptr;
 
-	pr_debug("%s[%p]:\n", __func__, audio);
+	pr_debug("%s[%pK]:\n", __func__, audio);
 	region = kmalloc(sizeof(*region), GFP_KERNEL);
 
 	if (!region) {
@@ -512,14 +512,14 @@ static int audlpa_ion_add(struct audio *audio,
 	region->kvaddr = kvaddr;
 	region->len = len;
 	region->ref_cnt = 0;
-	pr_debug("%s[%p]:add region paddr %lx vaddr %p, len %lu kvaddr %lx\n",
+	pr_debug("%s[%pK]:add region paddr %lx vaddr %pK, len %lu kvaddr %lx\n",
 		__func__, audio,
 		region->paddr, region->vaddr, region->len, region->kvaddr);
 	list_add_tail(&region->list, &audio->ion_region_queue);
 
 	rc = q6asm_memory_map(audio->ac, (uint32_t)paddr, IN, (uint32_t)len, 1);
 	if (rc < 0) {
-		pr_err("%s[%p]: memory map failed\n", __func__, audio);
+		pr_err("%s[%pK]: memory map failed\n", __func__, audio);
 		goto ion_error;
 	} else {
 		goto end;
@@ -549,7 +549,7 @@ static int audlpa_ion_remove(struct audio *audio,
 		if (region != NULL && (region->fd == info->fd) &&
 			(region->vaddr == info->vaddr)) {
 			if (region->ref_cnt) {
-				pr_debug("%s[%p]:region %p in use ref_cnt %d\n",
+				pr_debug("%s[%pK]:region %pK in use ref_cnt %d\n",
 					__func__, audio, region,
 					region->ref_cnt);
 				break;
@@ -557,7 +557,7 @@ static int audlpa_ion_remove(struct audio *audio,
 			rc = q6asm_memory_unmap(audio->ac,
 				(uint32_t) region->paddr, IN);
 			if (rc < 0)
-				pr_err("%s[%p]: memory unmap failed\n",
+				pr_err("%s[%pK]: memory unmap failed\n",
 					__func__, audio);
 
 			list_del(&region->list);
@@ -595,14 +595,14 @@ static int audlpa_ion_lookup_vaddr(struct audio *audio, void *addr,
 	}
 
 	if (match_count > 1) {
-		pr_err("%s[%p]:multiple hits for vaddr %p, len %ld\n",
+		pr_err("%s[%pK]:multiple hits for vaddr %pK, len %ld\n",
 			 __func__, audio, addr, len);
 		list_for_each_entry(region_elt, &audio->ion_region_queue,
 					list) {
 		if (addr >= region_elt->vaddr &&
 			addr < region_elt->vaddr + region_elt->len &&
 			addr + len <= region_elt->vaddr + region_elt->len)
-			pr_err("\t%s[%p]:%p, %ld --> %p\n",
+			pr_err("\t%s[%pK]:%pK, %ld --> %pK\n",
 				__func__, audio,
 					region_elt->vaddr,
 					region_elt->len,
@@ -620,7 +620,7 @@ static unsigned long audlpa_ion_fixup(struct audio *audio, void *addr,
 
 	ret = audlpa_ion_lookup_vaddr(audio, addr, len, &region);
 	if (ret) {
-		pr_err("%s[%p]:lookup (%p, %ld) failed\n",
+		pr_err("%s[%pK]:lookup (%pK, %ld) failed\n",
 			__func__, audio, addr, len);
 		return 0;
 	}
@@ -1101,10 +1101,10 @@ static void audlpa_unmap_ion_region(struct audio *audio)
 	struct list_head *ptr, *next;
 	int rc = -EINVAL;
 
-	pr_debug("%s[%p]:\n", __func__, audio);
+	pr_debug("%s[%pK]:\n", __func__, audio);
 	list_for_each_safe(ptr, next, &audio->ion_region_queue) {
 		region = list_entry(ptr, struct audlpa_ion_region, list);
-		pr_debug("%s[%p]: phy_address = 0x%lx\n",
+		pr_debug("%s[%pK]: phy_address = 0x%lx\n",
 			__func__, audio, region->paddr);
 		if (region != NULL) {
 			rc = q6asm_memory_unmap(audio->ac,
@@ -1386,7 +1386,7 @@ static int audio_open(struct inode *inode, struct file *file)
 		pr_err("Unable to create ION client\n");
 		goto err;
 	}
-	pr_debug("Allocating ION clinet in audio_open %p", audio->client);
+	pr_debug("Allocating ION clinet in audio_open %pK", audio->client);
 done:
 	return rc;
 err:
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_mp3.c b/arch/arm/mach-msm/qdsp6v2/audio_mp3.c
index 9132486ef6c..1105ed4ba3d 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_mp3.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_mp3.c
@@ -30,7 +30,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	int rc = 0;
 	switch (cmd) {
 	case AUDIO_START: {
-		pr_debug("%s[%p]: AUDIO_START session_id[%d]\n", __func__,
+		pr_debug("%s[%pK]: AUDIO_START session_id[%d]\n", __func__,
 						audio, audio->ac->session);
 		if (audio->feedback == NON_TUNNEL_MODE) {
 			/* Configure PCM output block */
@@ -66,7 +66,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 	}
 	return rc;
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_qcelp.c b/arch/arm/mach-msm/qdsp6v2/audio_qcelp.c
index acfcb654abe..ec06083ba16 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_qcelp.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_qcelp.c
@@ -33,7 +33,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	switch (cmd) {
 	case AUDIO_START: {
-		pr_debug("%s[%p]: AUDIO_START session_id[%d]\n", __func__,
+		pr_debug("%s[%pK]: AUDIO_START session_id[%d]\n", __func__,
 						audio, audio->ac->session);
 		if (audio->feedback == NON_TUNNEL_MODE) {
 			/* Configure PCM output block */
@@ -64,7 +64,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 	}
 	return rc;
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_utils.c b/arch/arm/mach-msm/qdsp6v2/audio_utils.c
index 7ccc0e385aa..818c5b067fa 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_utils.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_utils.c
@@ -495,7 +495,7 @@ ssize_t audio_in_read(struct file *file,
 			count -= bytes_to_copy;
 			buf += bytes_to_copy;
 		} else {
-			pr_err("%s:session id %d: short read data[%p] bytesavail[%d]bytesrequest[%d]\n",
+			pr_err("%s:session id %d: short read data[%pK] bytesavail[%d]bytesrequest[%d]\n",
 				__func__,
 				audio->ac->session,
 				data, size, count);
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c b/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
index eb4ef548747..fe19c957210 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
@@ -75,7 +75,7 @@ int insert_eos_buf(struct q6audio_aio *audio,
 		struct audio_aio_buffer_node *buf_node)
 {
 	struct dec_meta_out *eos_buf = buf_node->kvaddr;
-	pr_debug("%s[%p]:insert_eos_buf\n", __func__, audio);
+	pr_debug("%s[%pK]:insert_eos_buf\n", __func__, audio);
 	eos_buf->num_of_frames = 0xFFFFFFFF;
 	eos_buf->meta_out_dsp[0].offset_to_frame = 0x0;
 	eos_buf->meta_out_dsp[0].nflags = AUDIO_DEC_EOS_SET;
@@ -123,14 +123,14 @@ static int audio_aio_ion_lookup_vaddr(struct q6audio_aio *audio, void *addr,
 	}
 
 	if (match_count > 1) {
-		pr_err("%s[%p]:multiple hits for vaddr %p, len %ld\n",
+		pr_err("%s[%pK]:multiple hits for vaddr %pK, len %ld\n",
 			__func__, audio, addr, len);
 		list_for_each_entry(region_elt, &audio->ion_region_queue,
 					list) {
 			if (addr >= region_elt->vaddr &&
 			addr < region_elt->vaddr + region_elt->len &&
 			addr + len <= region_elt->vaddr + region_elt->len)
-				pr_err("\t%s[%p]:%p, %ld --> %p\n",
+				pr_err("\t%s[%pK]:%pK, %ld --> %pK\n",
 					__func__, audio,
 					region_elt->vaddr,
 					region_elt->len,
@@ -150,7 +150,7 @@ static unsigned long audio_aio_ion_fixup(struct q6audio_aio *audio, void *addr,
 
 	ret = audio_aio_ion_lookup_vaddr(audio, addr, len, &region);
 	if (ret) {
-		pr_err("%s[%p]:lookup (%p, %ld) failed\n",
+		pr_err("%s[%pK]:lookup (%pK, %ld) failed\n",
 				__func__, audio, addr, len);
 		return 0;
 	}
@@ -158,7 +158,7 @@ static unsigned long audio_aio_ion_fixup(struct q6audio_aio *audio, void *addr,
 		region->ref_cnt++;
 	else
 		region->ref_cnt--;
-	pr_debug("%s[%p]:found region %p ref_cnt %d\n",
+	pr_debug("%s[%pK]:found region %pK ref_cnt %d\n",
 			__func__, audio, region, region->ref_cnt);
 	paddr = region->paddr + (addr - region->vaddr);
 	/* provide kernel virtual address for accessing meta information */
@@ -171,26 +171,26 @@ static int audio_aio_pause(struct q6audio_aio  *audio)
 {
 	int rc = -EINVAL;
 
-	pr_debug("%s[%p], enabled = %d\n", __func__, audio,
+	pr_debug("%s[%pK], enabled = %d\n", __func__, audio,
 			audio->enabled);
 	if (audio->enabled) {
 		rc = q6asm_cmd(audio->ac, CMD_PAUSE);
 		if (rc < 0)
-			pr_err("%s[%p]: pause cmd failed rc=%d\n",
+			pr_err("%s[%pK]: pause cmd failed rc=%d\n",
 				__func__, audio, rc);
 
 		if (rc == 0) {
 			/* Send suspend only if pause was successful */
 			rc = q6asm_cmd(audio->ac, CMD_SUSPEND);
 			if (rc < 0)
-				pr_err("%s[%p]: suspend cmd failed rc=%d\n",
+				pr_err("%s[%pK]: suspend cmd failed rc=%d\n",
 					__func__, audio, rc);
 		} else
-			pr_err("%s[%p]: not sending suspend since pause failed\n",
+			pr_err("%s[%pK]: not sending suspend since pause failed\n",
 				__func__, audio);
 
 	} else
-		pr_err("%s[%p]: Driver not enabled\n", __func__, audio);
+		pr_err("%s[%pK]: Driver not enabled\n", __func__, audio);
 	return rc;
 }
 
@@ -204,7 +204,7 @@ static int audio_aio_flush(struct q6audio_aio  *audio)
 		if (!(audio->drv_status & ADRV_STATUS_PAUSE)) {
 			rc = audio_aio_pause(audio);
 			if (rc < 0)
-				pr_err("%s[%p}: pause cmd failed rc=%d\n",
+				pr_err("%s[%pK]: pause cmd failed rc=%d\n",
 					__func__, audio,
 					rc);
 			else
@@ -212,13 +212,13 @@ static int audio_aio_flush(struct q6audio_aio  *audio)
 		}
 		rc = q6asm_cmd(audio->ac, CMD_FLUSH);
 		if (rc < 0)
-			pr_err("%s[%p]: flush cmd failed rc=%d\n",
+			pr_err("%s[%pK]: flush cmd failed rc=%d\n",
 				__func__, audio, rc);
 		/* Not in stop state, reenable the stream */
 		if (audio->stopped == 0) {
 			rc = audio_aio_enable(audio);
 			if (rc)
-				pr_err("%s[%p]:audio re-enable failed\n",
+				pr_err("%s[%pK]:audio re-enable failed\n",
 					__func__, audio);
 			else {
 				audio->enabled = 1;
@@ -227,9 +227,9 @@ static int audio_aio_flush(struct q6audio_aio  *audio)
 			}
 		}
 	}
-	pr_debug("%s[%p]:in_bytes %d\n",
+	pr_debug("%s[%pK]:in_bytes %d\n",
 			__func__, audio, atomic_read(&audio->in_bytes));
-	pr_debug("%s[%p]:in_samples %d\n",
+	pr_debug("%s[%pK]:in_samples %d\n",
 			__func__, audio, atomic_read(&audio->in_samples));
 	atomic_set(&audio->in_bytes, 0);
 	atomic_set(&audio->in_samples, 0);
@@ -242,7 +242,7 @@ static int audio_aio_outport_flush(struct q6audio_aio *audio)
 
 	rc = q6asm_cmd(audio->ac, CMD_OUT_FLUSH);
 	if (rc < 0)
-		pr_err("%s[%p}: output port flush cmd failed rc=%d\n",
+		pr_err("%s[%pK]: output port flush cmd failed rc=%d\n",
 			__func__, audio, rc);
 	return rc;
 }
@@ -270,19 +270,19 @@ void audio_aio_async_write_ack(struct q6audio_aio *audio, uint32_t token,
 	if (token == used_buf->token) {
 		list_del(&used_buf->list);
 		spin_unlock_irqrestore(&audio->dsp_lock, flags);
-		pr_debug("%s[%p]:consumed buffer\n", __func__, audio);
+		pr_debug("%s[%pK]:consumed buffer\n", __func__, audio);
 		event_payload.aio_buf = used_buf->buf;
 		audio_aio_post_event(audio, AUDIO_EVENT_WRITE_DONE,
 					event_payload);
 		kfree(used_buf);
 		if (list_empty(&audio->out_queue) &&
 			(audio->drv_status & ADRV_STATUS_FSYNC)) {
-			pr_debug("%s[%p]: list is empty, reached EOS in Tunnel\n",
+			pr_debug("%s[%pK]: list is empty, reached EOS in Tunnel\n",
 				 __func__, audio);
 			wake_up(&audio->write_wait);
 		}
 	} else {
-		pr_err("%s[%p]:expected=%lx ret=%x\n",
+		pr_err("%s[%pK]:expected=%lx ret=%x\n",
 			__func__, audio, used_buf->token, token);
 		spin_unlock_irqrestore(&audio->dsp_lock, flags);
 	}
@@ -296,13 +296,13 @@ void audio_aio_async_out_flush(struct q6audio_aio *audio)
 	union msm_audio_event_payload payload;
 	unsigned long flags;
 
-	pr_debug("%s[%p}\n", __func__, audio);
+	pr_debug("%s[%pK]\n", __func__, audio);
 	/* EOS followed by flush, EOS response not guranteed, free EOS i/p
 	buffer */
 	spin_lock_irqsave(&audio->dsp_lock, flags);
 
 	if (audio->eos_flag && (audio->eos_write_payload.aio_buf.buf_addr)) {
-		pr_debug("%s[%p]: EOS followed by flush received,acknowledge"\
+		pr_debug("%s[%pK]: EOS followed by flush received,acknowledge"\
 			" eos i/p buffer immediately\n", __func__, audio);
 		audio_aio_post_event(audio, AUDIO_EVENT_WRITE_DONE,
 				audio->eos_write_payload);
@@ -316,7 +316,7 @@ void audio_aio_async_out_flush(struct q6audio_aio *audio)
 		payload.aio_buf = buf_node->buf;
 		audio_aio_post_event(audio, AUDIO_EVENT_WRITE_DONE, payload);
 		kfree(buf_node);
-		pr_debug("%s[%p]: Propagate WRITE_DONE during flush\n",
+		pr_debug("%s[%pK]: Propagate WRITE_DONE during flush\n",
 				__func__, audio);
 	}
 }
@@ -327,14 +327,14 @@ void audio_aio_async_in_flush(struct q6audio_aio *audio)
 	struct list_head *ptr, *next;
 	union msm_audio_event_payload payload;
 
-	pr_debug("%s[%p]\n", __func__, audio);
+	pr_debug("%s[%pK]\n", __func__, audio);
 	list_for_each_safe(ptr, next, &audio->in_queue) {
 		buf_node = list_entry(ptr, struct audio_aio_buffer_node, list);
 		list_del(&buf_node->list);
 		/* Forcefull send o/p eos buffer after flush, if no eos response
 		 * received by dsp even after sending eos command */
 		if ((audio->eos_rsp != 1) && audio->eos_flag) {
-			pr_debug("%s[%p]: send eos on o/p buffer during flush\n",
+			pr_debug("%s[%pK]: send eos on o/p buffer during flush\n",
 				 __func__, audio);
 			payload.aio_buf = buf_node->buf;
 			payload.aio_buf.data_len =
@@ -347,7 +347,7 @@ void audio_aio_async_in_flush(struct q6audio_aio *audio)
 		}
 		audio_aio_post_event(audio, AUDIO_EVENT_READ_DONE, payload);
 		kfree(buf_node);
-		pr_debug("%s[%p]: Propagate READ_DONE during flush\n",
+		pr_debug("%s[%pK]: Propagate READ_DONE during flush\n",
 				__func__, audio);
 	}
 }
@@ -365,19 +365,19 @@ int audio_aio_disable(struct q6audio_aio *audio)
 	if (audio->opened) {
 		audio->enabled = 0;
 		audio->opened = 0;
-		pr_debug("%s[%p]: inbytes[%d] insamples[%d]\n", __func__,
+		pr_debug("%s[%pK]: inbytes[%d] insamples[%d]\n", __func__,
 			audio, atomic_read(&audio->in_bytes),
 			atomic_read(&audio->in_samples));
 		/* Close the session */
 		rc = q6asm_cmd(audio->ac, CMD_CLOSE);
 		if (rc < 0)
-			pr_err("%s[%p]:Failed to close the session rc=%d\n",
+			pr_err("%s[%pK]:Failed to close the session rc=%d\n",
 				__func__, audio, rc);
 		audio->stopped = 1;
 		wake_up(&audio->write_wait);
 		wake_up(&audio->cmd_wait);
 	}
-	pr_debug("%s[%p]:enabled[%d]\n", __func__, audio, audio->enabled);
+	pr_debug("%s[%pK]:enabled[%d]\n", __func__, audio, audio->enabled);
 	return rc;
 }
 
@@ -426,16 +426,16 @@ static void audio_aio_unmap_ion_region(struct q6audio_aio *audio)
 	struct list_head *ptr, *next;
 	int rc = -EINVAL;
 
-	pr_debug("%s[%p]:\n", __func__, audio);
+	pr_debug("%s[%pK]:\n", __func__, audio);
 	list_for_each_safe(ptr, next, &audio->ion_region_queue) {
 		region = list_entry(ptr, struct audio_aio_ion_region, list);
-		pr_debug("%s[%p]: phy_address = 0x%lx\n",
+		pr_debug("%s[%pK]: phy_address = 0x%lx\n",
 				__func__, audio, region->paddr);
 		if (region != NULL) {
 			rc = q6asm_memory_unmap(audio->ac,
 						(uint32_t)region->paddr, IN);
 			if (rc < 0)
-				pr_err("%s[%p]: memory unmap failed\n",
+				pr_err("%s[%pK]: memory unmap failed\n",
 					__func__, audio);
 		}
 	}
@@ -452,20 +452,20 @@ static void audio_aio_listner(u32 evt_id, union auddev_evt_data *evt_payload,
 	switch (evt_id) {
 	case AUDDEV_EVT_STREAM_VOL_CHG:
 		audio->volume = evt_payload->session_vol;
-		pr_debug("%s[%p]: AUDDEV_EVT_STREAM_VOL_CHG, stream vol %d, enabled = %d\n",
+		pr_debug("%s[%pK]: AUDDEV_EVT_STREAM_VOL_CHG, stream vol %d, enabled = %d\n",
 			__func__, audio, audio->volume, audio->enabled);
 		if (audio->enabled == 1) {
 			if (audio->ac) {
 				rc = q6asm_set_volume(audio->ac, audio->volume);
 				if (rc < 0) {
-					pr_err("%s[%p]: Send Volume command failed rc=%d\n",
+					pr_err("%s[%pK]: Send Volume command failed rc=%d\n",
 						__func__, audio, rc);
 				}
 			}
 		}
 		break;
 	default:
-		pr_err("%s[%p]:ERROR:wrong event\n", __func__, audio);
+		pr_err("%s[%pK]:ERROR:wrong event\n", __func__, audio);
 		break;
 	}
 }
@@ -482,7 +482,7 @@ int register_volume_listener(struct q6audio_aio *audio)
 					audio_aio_listner,
 					(void *)audio);
 	if (rc < 0) {
-		pr_err("%s[%p]: Event listener failed\n", __func__, audio);
+		pr_err("%s[%pK]: Event listener failed\n", __func__, audio);
 		rc = -EACCES;
 	}
 	return rc;
@@ -500,7 +500,7 @@ int enable_volume_ramp(struct q6audio_aio *audio)
 
 	if (audio->ac == NULL)
 		return -EINVAL;
-	pr_debug("%s[%p]\n", __func__, audio);
+	pr_debug("%s[%pK]\n", __func__, audio);
 	softpause.enable = SOFT_PAUSE_ENABLE;
 	softpause.period = SOFT_PAUSE_PERIOD;
 	softpause.step = SOFT_PAUSE_STEP;
@@ -560,7 +560,7 @@ int enable_volume_ramp(struct q6audio_aio *audio)
 int audio_aio_release(struct inode *inode, struct file *file)
 {
 	struct q6audio_aio *audio = file->private_data;
-	pr_debug("%s[%p]\n", __func__, audio);
+	pr_debug("%s[%pK]\n", __func__, audio);
 	mutex_lock(&audio->lock);
 	mutex_lock(&audio->read_lock);
 	mutex_lock(&audio->write_lock);
@@ -609,56 +609,56 @@ int audio_aio_fsync(struct file *file, loff_t start, loff_t end, int datasync)
 	audio->drv_status |= ADRV_STATUS_FSYNC;
 	mutex_unlock(&audio->lock);
 
-	pr_debug("%s[%p]:\n", __func__, audio);
+	pr_debug("%s[%pK]:\n", __func__, audio);
 
 	audio->eos_rsp = 0;
 
-	pr_debug("%s[%p]Wait for write done from DSP\n", __func__, audio);
+	pr_debug("%s[%pK]Wait for write done from DSP\n", __func__, audio);
 	rc = wait_event_interruptible(audio->write_wait,
 					(list_empty(&audio->out_queue)) ||
 					audio->wflush || audio->stopped);
 
 	if (audio->stopped || audio->wflush) {
-		pr_debug("%s[%p]: Audio Flushed or Stopped,this is not EOS\n"
+		pr_debug("%s[%pK]: Audio Flushed or Stopped,this is not EOS\n"
 			, __func__, audio);
 		audio->wflush = 0;
 		rc = -EBUSY;
 	}
 
 	if (rc < 0) {
-		pr_err("%s[%p]: wait event for list_empty failed, rc = %d\n",
+		pr_err("%s[%pK]: wait event for list_empty failed, rc = %d\n",
 			__func__, audio, rc);
 		goto done;
 	}
 
 	rc = q6asm_cmd(audio->ac, CMD_EOS);
-	pr_debug("%s[%p]: EOS cmd sent to DSP\n", __func__, audio);
+	pr_debug("%s[%pK]: EOS cmd sent to DSP\n", __func__, audio);
 
 	if (rc < 0)
-		pr_err("%s[%p]: q6asm_cmd failed, rc = %d",
+		pr_err("%s[%pK]: q6asm_cmd failed, rc = %d",
 			__func__, audio, rc);
 
-	pr_debug("%s[%p]: wait for RENDERED_EOS from DSP\n"
+	pr_debug("%s[%pK]: wait for RENDERED_EOS from DSP\n"
 		, __func__, audio);
 	rc = wait_event_interruptible(audio->write_wait,
 					(audio->eos_rsp || audio->wflush ||
 					audio->stopped));
 
 	if (rc < 0) {
-		pr_err("%s[%p]: wait event for eos_rsp failed, rc = %d\n",
+		pr_err("%s[%pK]: wait event for eos_rsp failed, rc = %d\n",
 			__func__, audio, rc);
 		goto done;
 	}
 
 	if (audio->stopped || audio->wflush) {
 		audio->wflush = 0;
-		pr_debug("%s[%p]: Audio Flushed or Stopped,this is not EOS\n"
+		pr_debug("%s[%pK]: Audio Flushed or Stopped,this is not EOS\n"
 			, __func__, audio);
 		rc = -EBUSY;
 	}
 
 	if (audio->eos_rsp == 1)
-		pr_debug("%s[%p]: EOS\n", __func__, audio);
+		pr_debug("%s[%pK]: EOS\n", __func__, audio);
 
 
 done:
@@ -727,21 +727,21 @@ static long audio_aio_process_event_req(struct q6audio_aio *audio,
 		usr_evt.event_payload = drv_evt->payload;
 		list_add_tail(&drv_evt->list, &audio->free_event_queue);
 	} else {
-		pr_err("%s[%p]:Unexpected path\n", __func__, audio);
+		pr_err("%s[%pK]:Unexpected path\n", __func__, audio);
 		spin_unlock_irqrestore(&audio->event_queue_lock, flags);
 		return -EPERM;
 	}
 	spin_unlock_irqrestore(&audio->event_queue_lock, flags);
 
 	if (drv_evt->event_type == AUDIO_EVENT_WRITE_DONE) {
-		pr_debug("%s[%p]:posted AUDIO_EVENT_WRITE_DONE to user\n",
+		pr_debug("%s[%pK]:posted AUDIO_EVENT_WRITE_DONE to user\n",
 			__func__, audio);
 		mutex_lock(&audio->write_lock);
 		audio_aio_ion_fixup(audio, drv_evt->payload.aio_buf.buf_addr,
 		drv_evt->payload.aio_buf.buf_len, 0, 0);
 		mutex_unlock(&audio->write_lock);
 	} else if (drv_evt->event_type == AUDIO_EVENT_READ_DONE) {
-		pr_debug("%s[%p]:posted AUDIO_EVENT_READ_DONE to user\n",
+		pr_debug("%s[%pK]:posted AUDIO_EVENT_READ_DONE to user\n",
 			__func__, audio);
 		mutex_lock(&audio->read_lock);
 		audio_aio_ion_fixup(audio, drv_evt->payload.aio_buf.buf_addr,
@@ -753,7 +753,7 @@ static long audio_aio_process_event_req(struct q6audio_aio *audio,
 	 * Once EOS indicated
 	 */
 	if (audio->eos_rsp && !list_empty(&audio->in_queue)) {
-		pr_debug("%s[%p]:Send flush command to release read buffers"\
+		pr_debug("%s[%pK]:Send flush command to release read buffers"\
 			" held up in DSP\n", __func__, audio);
 		audio_aio_flush(audio);
 	}
@@ -773,7 +773,7 @@ static int audio_aio_ion_check(struct q6audio_aio *audio,
 	list_for_each_entry(region_elt, &audio->ion_region_queue, list) {
 		if (CONTAINS(region_elt, &t) || CONTAINS(&t, region_elt) ||
 			OVERLAPS(region_elt, &t)) {
-			pr_err("%s[%p]:region (vaddr %p len %ld) clashes with registered region (vaddr %p paddr %p len %ld)\n",
+			pr_err("%s[%pK]:region (vaddr %pK len %ld) clashes with registered region (vaddr %pK paddr %pK len %ld)\n",
 				__func__, audio, vaddr, len,
 				region_elt->vaddr,
 				(void *)region_elt->paddr, region_elt->len);
@@ -795,7 +795,7 @@ static int audio_aio_ion_add(struct q6audio_aio *audio,
 	unsigned long ionflag;
 	void *kvaddr = NULL;
 
-	pr_debug("%s[%p]:\n", __func__, audio);
+	pr_debug("%s[%pK]:\n", __func__, audio);
 	region = kmalloc(sizeof(*region), GFP_KERNEL);
 
 	if (!region) {
@@ -824,14 +824,14 @@ static int audio_aio_ion_add(struct q6audio_aio *audio,
 	region->kvaddr = (unsigned long)kvaddr;
 	region->len = len;
 	region->ref_cnt = 0;
-	pr_debug("%s[%p]:add region paddr %lx vaddr %p, len %lu kvaddr %lx\n",
+	pr_debug("%s[%pK]:add region paddr %lx vaddr %pK, len %lu kvaddr %lx\n",
 		__func__, audio,
 		region->paddr, region->vaddr, region->len, region->kvaddr);
 	list_add_tail(&region->list, &audio->ion_region_queue);
 	rc = q6asm_memory_map(audio->ac, (uint32_t) paddr, IN, (uint32_t) len,
 				1);
 	if (rc < 0) {
-		pr_err("%s[%p]: memory map failed\n", __func__, audio);
+		pr_err("%s[%pK]: memory map failed\n", __func__, audio);
 		goto mmap_error;
 	} else {
 		goto end;
@@ -853,7 +853,7 @@ static int audio_aio_ion_remove(struct q6audio_aio *audio,
 	struct list_head *ptr, *next;
 	int rc = -EINVAL;
 
-	pr_debug("%s[%p]:info fd %d vaddr %p\n",
+	pr_debug("%s[%pK]:info fd %d vaddr %pK\n",
 		__func__, audio, info->fd, info->vaddr);
 
 	list_for_each_safe(ptr, next, &audio->ion_region_queue) {
@@ -862,17 +862,17 @@ static int audio_aio_ion_remove(struct q6audio_aio *audio,
 		if ((region->fd == info->fd) &&
 			(region->vaddr == info->vaddr)) {
 			if (region->ref_cnt) {
-				pr_debug("%s[%p]:region %p in use ref_cnt %d\n",
+				pr_debug("%s[%pK]:region %pK in use ref_cnt %d\n",
 					__func__, audio, region,
 					region->ref_cnt);
 				break;
 			}
-			pr_debug("%s[%p]:remove region fd %d vaddr %p\n",
+			pr_debug("%s[%pK]:remove region fd %d vaddr %pK\n",
 				__func__, audio, info->fd, info->vaddr);
 			rc = q6asm_memory_unmap(audio->ac,
 						(uint32_t) region->paddr, IN);
 			if (rc < 0)
-				pr_err("%s[%p]: memory unmap failed\n",
+				pr_err("%s[%pK]: memory unmap failed\n",
 					__func__, audio);
 
 			list_del(&region->list);
@@ -895,15 +895,15 @@ static void audio_aio_async_write(struct q6audio_aio *audio,
 	struct audio_aio_write_param param;
 
 	if (!audio || !buf_node) {
-		pr_err("%s NULL pointer audio=[0x%p], buf_node=[0x%p]\n",
+		pr_err("%s NULL pointer audio=[0x%pK], buf_node=[0x%pK]\n",
 			__func__, audio, buf_node);
 		return;
 	}
-	pr_debug("%s[%p]: Send write buff %p phy %lx len %d meta_enable = %d\n",
+	pr_debug("%s[%pK]: Send write buff %pK phy %lx len %d meta_enable = %d\n",
 		__func__, audio, buf_node, buf_node->paddr,
 		buf_node->buf.data_len,
 		audio->buf_cfg.meta_info_enable);
-	pr_debug("%s[%p]: flags = 0x%x\n", __func__, audio,
+	pr_debug("%s[%pK]: flags = 0x%x\n", __func__, audio,
 		buf_node->meta_info.meta_in.nflags);
 
 	ac = audio->ac;
@@ -932,7 +932,7 @@ static void audio_aio_async_write(struct q6audio_aio *audio,
 	buf_node->token = param.paddr;
 	rc = q6asm_async_write(ac, &param);
 	if (rc < 0)
-		pr_err("%s[%p]:failed\n", __func__, audio);
+		pr_err("%s[%pK]:failed\n", __func__, audio);
 }
 
 void audio_aio_post_event(struct q6audio_aio *audio, int type,
@@ -950,7 +950,7 @@ void audio_aio_post_event(struct q6audio_aio *audio, int type,
 	} else {
 		e_node = kmalloc(sizeof(struct audio_aio_event), GFP_ATOMIC);
 		if (!e_node) {
-			pr_err("%s[%p]:No mem to post event %d\n",
+			pr_err("%s[%pK]:No mem to post event %d\n",
 				__func__, audio, type);
 			spin_unlock_irqrestore(&audio->event_queue_lock, flags);
 			return;
@@ -972,7 +972,7 @@ static void audio_aio_async_read(struct q6audio_aio *audio,
 	struct audio_aio_read_param param;
 	int rc;
 
-	pr_debug("%s[%p]: Send read buff %p phy %lx len %d\n",
+	pr_debug("%s[%pK]: Send read buff %pK phy %lx len %d\n",
 		__func__, audio, buf_node,
 		buf_node->paddr, buf_node->buf.buf_len);
 	ac = audio->ac;
@@ -986,7 +986,7 @@ static void audio_aio_async_read(struct q6audio_aio *audio,
 	buf_node->token = param.paddr;
 	rc = q6asm_async_read(ac, &param);
 	if (rc < 0)
-		pr_err("%s[%p]:failed\n", __func__, audio);
+		pr_err("%s[%pK]:failed\n", __func__, audio);
 }
 
 static int audio_aio_buf_add(struct q6audio_aio *audio, unsigned dir,
@@ -1006,7 +1006,7 @@ static int audio_aio_buf_add(struct q6audio_aio *audio, unsigned dir,
 		return -EFAULT;
 	}
 
-	pr_debug("%s[%p]:node %p dir %x buf_addr %p buf_len %d data_len %d\n",
+	pr_debug("%s[%pK]:node %pK dir %x buf_addr %pK buf_len %d data_len %d\n",
 		 __func__, audio, buf_node, dir, buf_node->buf.buf_addr,
 		buf_node->buf.buf_len, buf_node->buf.data_len);
 	buf_node->paddr = audio_aio_ion_fixup(audio, buf_node->buf.buf_addr,
@@ -1031,7 +1031,7 @@ static int audio_aio_buf_add(struct q6audio_aio *audio, unsigned dir,
 		} else if (buf_node->meta_info.meta_in.nflags
 				   & AUDIO_DEC_EOS_SET) {
 			if (!audio->wflush) {
-				pr_debug("%s[%p]:Send EOS cmd at i/p\n",
+				pr_debug("%s[%pK]:Send EOS cmd at i/p\n",
 					__func__, audio);
 				/* Driver will forcefully post writedone event
 				 * once eos ack recived from DSP
@@ -1077,7 +1077,7 @@ static int audio_aio_buf_add(struct q6audio_aio *audio, unsigned dir,
 			event_payload.aio_buf = buf_node->buf;
 			event_payload.aio_buf.data_len =
 				insert_eos_buf(audio, buf_node);
-			pr_debug("%s[%p]: propagate READ_DONE as EOS done\n",\
+			pr_debug("%s[%pK]: propagate READ_DONE as EOS done\n",\
 				__func__, audio);
 			audio_aio_post_event(audio, AUDIO_EVENT_READ_DONE,
 					event_payload);
@@ -1095,7 +1095,7 @@ void audio_aio_ioport_reset(struct q6audio_aio *audio)
 		 * abort due to flush
 		 */
 		if (audio->drv_status & ADRV_STATUS_FSYNC) {
-			pr_debug("%s[%p]:fsync in progress\n", __func__, audio);
+			pr_debug("%s[%pK]:fsync in progress\n", __func__, audio);
 			audio->drv_ops.out_flush(audio);
 		} else
 			audio->drv_ops.out_flush(audio);
@@ -1122,13 +1122,13 @@ int audio_aio_open(struct q6audio_aio *audio, struct file *file)
 
 	/* Only AIO interface */
 	if (file->f_flags & O_NONBLOCK) {
-		pr_debug("%s[%p]:set to aio interface\n", __func__, audio);
+		pr_debug("%s[%pK]:set to aio interface\n", __func__, audio);
 		audio->drv_status |= ADRV_STATUS_AIO_INTF;
 		audio->drv_ops.out_flush = audio_aio_async_out_flush;
 		audio->drv_ops.in_flush = audio_aio_async_in_flush;
 		q6asm_set_io_mode(audio->ac, ASYNC_IO_MODE);
 	} else {
-		pr_err("%s[%p]:SIO interface not supported\n",
+		pr_err("%s[%pK]:SIO interface not supported\n",
 			__func__, audio);
 		rc = -EACCES;
 		goto fail;
@@ -1160,7 +1160,7 @@ int audio_aio_open(struct q6audio_aio *audio, struct file *file)
 		if (e_node)
 			list_add_tail(&e_node->list, &audio->free_event_queue);
 		else {
-			pr_err("%s[%p]:event pkt alloc failed\n",
+			pr_err("%s[%pK]:event pkt alloc failed\n",
 				__func__, audio);
 			rc = -ENOMEM;
 			goto cleanup;
@@ -1173,7 +1173,7 @@ int audio_aio_open(struct q6audio_aio *audio, struct file *file)
 		rc = -ENOMEM;
 		goto cleanup;
 	}
-	pr_debug("Ion client create in audio_aio_open %p", audio->client);
+	pr_debug("Ion client create in audio_aio_open %pK", audio->client);
 
 	rc = register_volume_listener(audio);
 	if (rc < 0)
@@ -1216,7 +1216,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	case AUDIO_GET_EVENT: {
-		pr_debug("%s[%p]:AUDIO_GET_EVENT\n", __func__, audio);
+		pr_debug("%s[%pK]:AUDIO_GET_EVENT\n", __func__, audio);
 		if (mutex_trylock(&audio->get_event_lock)) {
 			rc = audio_aio_process_event_req(audio,
 						(void __user *)arg);
@@ -1255,11 +1255,11 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	case AUDIO_OUTPORT_FLUSH: {
-		pr_debug("%s[%p]:AUDIO_OUTPORT_FLUSH\n", __func__, audio);
+		pr_debug("%s[%pK]:AUDIO_OUTPORT_FLUSH\n", __func__, audio);
 		mutex_lock(&audio->read_lock);
 		rc = audio_aio_outport_flush(audio);
 		if (rc < 0) {
-			pr_err("%s[%p]: AUDIO_OUTPORT_FLUSH failed\n",
+			pr_err("%s[%pK]: AUDIO_OUTPORT_FLUSH failed\n",
 				__func__, audio);
 			rc = -EINTR;
 		}
@@ -1267,13 +1267,13 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	case AUDIO_STOP: {
-		pr_debug("%s[%p]: AUDIO_STOP session_id[%d]\n", __func__,
+		pr_debug("%s[%pK]: AUDIO_STOP session_id[%d]\n", __func__,
 				audio, audio->ac->session);
 		mutex_lock(&audio->lock);
 		audio->stopped = 1;
 		rc = audio_aio_flush(audio);
 		if (rc < 0) {
-			pr_err("%s[%p]:Audio Stop procedure failed rc=%d\n",
+			pr_err("%s[%pK]:Audio Stop procedure failed rc=%d\n",
 				__func__, audio, rc);
 			mutex_unlock(&audio->lock);
 			break;
@@ -1281,7 +1281,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		audio->enabled = 0;
 		audio->drv_status &= ~ADRV_STATUS_PAUSE;
 		if (audio->drv_status & ADRV_STATUS_FSYNC) {
-			pr_debug("%s[%p] Waking up the audio_aio_fsync\n",
+			pr_debug("%s[%pK] Waking up the audio_aio_fsync\n",
 					__func__, audio);
 			wake_up(&audio->write_wait);
 		}
@@ -1289,12 +1289,12 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	case AUDIO_PAUSE: {
-		pr_debug("%s[%p]:AUDIO_PAUSE %ld\n", __func__, audio, arg);
+		pr_debug("%s[%pK]:AUDIO_PAUSE %ld\n", __func__, audio, arg);
 		mutex_lock(&audio->lock);
 		if (arg == 1) {
 			rc = audio_aio_pause(audio);
 			if (rc < 0) {
-				pr_err("%s[%p]: pause FAILED rc=%d\n",
+				pr_err("%s[%pK]: pause FAILED rc=%d\n",
 					__func__, audio, rc);
 				mutex_unlock(&audio->lock);
 				break;
@@ -1304,7 +1304,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			if (audio->drv_status & ADRV_STATUS_PAUSE) {
 				rc = audio_aio_enable(audio);
 				if (rc)
-					pr_err("%s[%p]: audio enable failed\n",
+					pr_err("%s[%pK]: audio enable failed\n",
 					__func__, audio);
 				else {
 					audio->drv_status &= ~ADRV_STATUS_PAUSE;
@@ -1316,13 +1316,13 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	case AUDIO_FLUSH: {
-		pr_debug("%s[%p]: AUDIO_FLUSH sessionid[%d]\n", __func__,
+		pr_debug("%s[%pK]: AUDIO_FLUSH sessionid[%d]\n", __func__,
 			audio, audio->ac->session);
 		mutex_lock(&audio->lock);
 		audio->rflush = 1;
 		audio->wflush = 1;
 		if (audio->drv_status & ADRV_STATUS_FSYNC) {
-			pr_debug("%s[%p] Waking up the audio_aio_fsync\n",
+			pr_debug("%s[%pK] Waking up the audio_aio_fsync\n",
 				__func__, audio);
 			wake_up(&audio->write_wait);
 		}
@@ -1331,7 +1331,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		/* Flush input / Output buffer in software*/
 		audio_aio_ioport_reset(audio);
 		if (rc < 0) {
-			pr_err("%s[%p]:AUDIO_FLUSH interrupted\n",
+			pr_err("%s[%pK]:AUDIO_FLUSH interrupted\n",
 				__func__, audio);
 			rc = -EINTR;
 		} else {
@@ -1349,7 +1349,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	}
 	case AUDIO_REGISTER_ION: {
 		struct msm_audio_ion_info info;
-		pr_debug("%s[%p]:AUDIO_REGISTER_ION\n", __func__, audio);
+		pr_debug("%s[%pK]:AUDIO_REGISTER_ION\n", __func__, audio);
 		mutex_lock(&audio->lock);
 		if (copy_from_user(&info, (void *)arg, sizeof(info)))
 			rc = -EFAULT;
@@ -1366,7 +1366,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	case AUDIO_DEREGISTER_ION: {
 		struct msm_audio_ion_info info;
 		mutex_lock(&audio->lock);
-		pr_debug("%s[%p]:AUDIO_DEREGISTER_ION\n", __func__, audio);
+		pr_debug("%s[%pK]:AUDIO_DEREGISTER_ION\n", __func__, audio);
 		if (copy_from_user(&info, (void *)arg, sizeof(info)))
 			rc = -EFAULT;
 		else {
@@ -1385,7 +1385,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		memset(&cfg, 0, sizeof(cfg));
 		cfg.buffer_size = audio->str_cfg.buffer_size;
 		cfg.buffer_count = audio->str_cfg.buffer_count;
-		pr_debug("%s[%p]:GET STREAM CFG %d %d\n",
+		pr_debug("%s[%pK]:GET STREAM CFG %d %d\n",
 			__func__, audio, cfg.buffer_size, cfg.buffer_count);
 		if (copy_to_user((void *)arg, &cfg, sizeof(cfg)))
 			rc = -EFAULT;
@@ -1394,7 +1394,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	}
 	case AUDIO_SET_STREAM_CONFIG: {
 		struct msm_audio_stream_config cfg;
-		pr_debug("%s[%p]:SET STREAM CONFIG\n", __func__, audio);
+		pr_debug("%s[%pK]:SET STREAM CONFIG\n", __func__, audio);
 		mutex_lock(&audio->lock);
 		if (copy_from_user(&cfg, (void *)arg, sizeof(cfg))) {
 			rc = -EFAULT;
@@ -1417,7 +1417,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	}
 	case AUDIO_SET_CONFIG: {
 		struct msm_audio_config config;
-		pr_err("%s[%p]:AUDIO_SET_CONFIG\n", __func__, audio);
+		pr_err("%s[%pK]:AUDIO_SET_CONFIG\n", __func__, audio);
 		mutex_lock(&audio->lock);
 		if (copy_from_user(&config, (void *)arg, sizeof(config))) {
 			rc = -EFAULT;
@@ -1425,7 +1425,7 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			break;
 		}
 		if (audio->feedback != NON_TUNNEL_MODE) {
-			pr_err("%s[%p]:Not sufficient permission to change the playback mode\n",
+			pr_err("%s[%pK]:Not sufficient permission to change the playback mode\n",
 				 __func__, audio);
 			rc = -EACCES;
 			mutex_unlock(&audio->lock);
@@ -1462,14 +1462,14 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		}
 
 		audio->buf_cfg.meta_info_enable = cfg.meta_info_enable;
-		pr_debug("%s[%p]:session id %d: Set-buf-cfg: meta[%d]",
+		pr_debug("%s[%pK]:session id %d: Set-buf-cfg: meta[%d]",
 				__func__, audio,
 				audio->ac->session, cfg.meta_info_enable);
 		mutex_unlock(&audio->lock);
 		break;
 	}
 	case AUDIO_GET_BUF_CFG: {
-		pr_debug("%s[%p]:session id %d: Get-buf-cfg: meta[%d] framesperbuf[%d]\n",
+		pr_debug("%s[%pK]:session id %d: Get-buf-cfg: meta[%d] framesperbuf[%d]\n",
 			 __func__, audio,
 			audio->ac->session, audio->buf_cfg.meta_info_enable,
 			audio->buf_cfg.frames_per_buf);
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_wma.c b/arch/arm/mach-msm/qdsp6v2/audio_wma.c
index 2f8df45240f..cb4064d5140 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_wma.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_wma.c
@@ -35,7 +35,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	case AUDIO_START: {
 		struct asm_wma_cfg wma_cfg;
 		struct msm_audio_wma_config_v2 *wma_config;
-		pr_debug("%s[%p]: AUDIO_START session_id[%d]\n", __func__,
+		pr_debug("%s[%pK]: AUDIO_START session_id[%d]\n", __func__,
 						audio, audio->ac->session);
 		if (audio->feedback == NON_TUNNEL_MODE) {
 			/* Configure PCM output block */
@@ -97,7 +97,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 		if (rc)
 			pr_err("Failed in utils_ioctl: %d\n", rc);
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_wmapro.c b/arch/arm/mach-msm/qdsp6v2/audio_wmapro.c
index 7d0edf0d921..622507e90f0 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_wmapro.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_wmapro.c
@@ -153,7 +153,7 @@ static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	default:
-		pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
+		pr_debug("%s[%pK]: Calling utils ioctl\n", __func__, audio);
 		rc = audio->codec_ioctl(file, cmd, arg);
 		if (rc)
 			pr_err("Failed in utils_ioctl: %d\n", rc);
diff --git a/arch/arm/mach-msm/qdsp6v2/dsp_debug.c b/arch/arm/mach-msm/qdsp6v2/dsp_debug.c
index 26c8f75ac1f..5c1a65bece0 100644
--- a/arch/arm/mach-msm/qdsp6v2/dsp_debug.c
+++ b/arch/arm/mach-msm/qdsp6v2/dsp_debug.c
@@ -169,7 +169,7 @@ static ssize_t dsp_read(struct file *file, char __user *buf,
 		}
 		if (copy_to_user(buf, ptr, PAGE_SIZE)) {
 			iounmap(mem_buffer);
-			pr_err("[%s:%s] copy error @ %p\n", __MM_FILE__,
+			pr_err("[%s:%s] copy error @ %pK\n", __MM_FILE__,
 					__func__, buf);
 			return -EFAULT;
 		}
diff --git a/arch/arm/mach-msm/qdsp6v2/msm_audio_ion.c b/arch/arm/mach-msm/qdsp6v2/msm_audio_ion.c
index f19ad59c2d6..8c8e9f6c53c 100644
--- a/arch/arm/mach-msm/qdsp6v2/msm_audio_ion.c
+++ b/arch/arm/mach-msm/qdsp6v2/msm_audio_ion.c
@@ -95,10 +95,10 @@ int msm_audio_ion_alloc(const char *name, struct ion_client **client,
 		pr_err("%s: ION memory mapping for AUDIO failed\n", __func__);
 		goto err_ion_handle;
 	}
-	pr_debug("%s: mapped address = %p, size=%d\n", __func__, *vaddr, bufsz);
+	pr_debug("%s: mapped address = %pK, size=%d\n", __func__, *vaddr, bufsz);
 
 	if (bufsz != 0) {
-		pr_debug("%s: memset to 0 %p %d\n", __func__, *vaddr, bufsz);
+		pr_debug("%s: memset to 0 %pK %d\n", __func__, *vaddr, bufsz);
 		memset((void *)*vaddr, 0, bufsz);
 	}
 
@@ -137,7 +137,7 @@ int msm_audio_ion_import(const char *name, struct ion_client **client,
 	bufsz should be 0 and fd shouldn't be 0 as of now
 	*/
 	*handle = ion_import_dma_buf(*client, fd);
-	pr_err("%s: DMA Buf name=%s, fd=%d handle=%p\n", __func__,
+	pr_err("%s: DMA Buf name=%s, fd=%d handle=%pK\n", __func__,
 							name, fd, *handle);
 	if (IS_ERR_OR_NULL((void *) (*handle))) {
 		pr_err("%s: ion import dma buffer failed\n",
@@ -168,7 +168,7 @@ int msm_audio_ion_import(const char *name, struct ion_client **client,
 		rc = -ENOMEM;
 		goto err_ion_handle;
 	}
-	pr_debug("%s: mapped address = %p, size=%d\n", __func__, *vaddr, bufsz);
+	pr_debug("%s: mapped address = %pK, size=%d\n", __func__, *vaddr, bufsz);
 
 	return 0;
 
@@ -190,7 +190,7 @@ int msm_audio_ion_free(struct ion_client *client, struct ion_handle *handle)
 	}
 	if (msm_audio_ion_data.smmu_enabled) {
 		/* Need to populate book kept infomation */
-		pr_debug("client=%p, domain=%p, domain_id=%d, group=%p",
+		pr_debug("client=%pK, domain=%pK, domain_id=%d, group=%pK",
 			client, msm_audio_ion_data.domain,
 			msm_audio_ion_data.domain_id, msm_audio_ion_data.group);
 
@@ -255,7 +255,7 @@ int msm_audio_ion_mmap(struct audio_buffer *ab,
 				offset = 0;
 			}
 			len = min(len, remainder);
-			pr_debug("vma=%p, addr=%x len=%ld vm_start=%x vm_end=%x vm_page_prot=%ld\n",
+			pr_debug("vma=%pK, addr=%x len=%ld vm_start=%x vm_end=%x vm_page_prot=%ld\n",
 				vma, (unsigned int)addr, len,
 				(unsigned int)vma->vm_start,
 				(unsigned int)vma->vm_end,
@@ -279,7 +279,7 @@ int msm_audio_ion_mmap(struct audio_buffer *ab,
 			return ret;
 		}
 		pr_debug("phys=%x len=%d\n", (unsigned int)phys_addr, phys_len);
-		pr_debug("vma=%p, vm_start=%x vm_end=%x vm_pgoff=%ld vm_page_prot=%ld\n",
+		pr_debug("vma=%pK, vm_start=%x vm_end=%x vm_pgoff=%ld vm_page_prot=%ld\n",
 			vma, (unsigned int)vma->vm_start,
 			(unsigned int)vma->vm_end, vma->vm_pgoff,
 			(unsigned long int)vma->vm_page_prot);
@@ -316,7 +316,7 @@ struct ion_client *msm_audio_ion_client_create(unsigned int heap_mask,
 
 void msm_audio_ion_client_destroy(struct ion_client *client)
 {
-	pr_debug("%s: client = %p smmu_enabled = %d\n", __func__,
+	pr_debug("%s: client = %pK smmu_enabled = %d\n", __func__,
 		client, msm_audio_ion_data.smmu_enabled);
 
 	ion_client_destroy(client);
@@ -338,7 +338,7 @@ int msm_audio_ion_import_legacy(const char *name, struct ion_client *client,
 	bufsz should be 0 and fd shouldn't be 0 as of now
 	*/
 	*handle = ion_import_dma_buf(client, fd);
-	pr_debug("%s: DMA Buf name=%s, fd=%d handle=%p\n", __func__,
+	pr_debug("%s: DMA Buf name=%s, fd=%d handle=%pK\n", __func__,
 							name, fd, *handle);
 	if (IS_ERR_OR_NULL((void *)(*handle))) {
 		pr_err("%s: ion import dma buffer failed\n",
@@ -404,7 +404,7 @@ int msm_audio_ion_cache_operations(struct audio_buffer *abuff, int cache_op)
 	int msm_cache_ops = 0;
 
 	if (!abuff) {
-		pr_err("Invalid params: %p, %p\n", __func__, abuff);
+		pr_err("Invalid params: %pK, %pK\n", __func__, abuff);
 		return -EINVAL;
 	}
 	rc = ion_handle_get_flags(abuff->client, abuff->handle,
@@ -450,7 +450,7 @@ static int msm_audio_ion_get_phys(struct ion_client *client,
 			pr_err("%s: ION map iommu failed %d\n", __func__, rc);
 			return rc;
 		}
-		pr_debug("client=%p, domain=%p, domain_id=%d, group=%p",
+		pr_debug("client=%pK, domain=%pK, domain_id=%d, group=%pK",
 			client, msm_audio_ion_data.domain,
 			msm_audio_ion_data.domain_id, msm_audio_ion_data.group);
 	} else {
@@ -486,18 +486,18 @@ static int msm_audio_ion_probe(struct platform_device *pdev)
 		msm_audio_ion_data.domain =
 			iommu_group_get_iommudata(msm_audio_ion_data.group);
 		if (IS_ERR_OR_NULL(msm_audio_ion_data.domain)) {
-			pr_err("Failed to get domain data for group %p",
+			pr_err("Failed to get domain data for group %pK",
 					msm_audio_ion_data.group);
 			goto fail_group;
 		}
 		msm_audio_ion_data.domain_id =
 				msm_find_domain_no(msm_audio_ion_data.domain);
 		if (msm_audio_ion_data.domain_id < 0) {
-			pr_err("Failed to get domain index for domain %p",
+			pr_err("Failed to get domain index for domain %pK",
 					msm_audio_ion_data.domain);
 			goto fail_group;
 		}
-		pr_debug("domain=%p, domain_id=%d, group=%p",
+		pr_debug("domain=%pK, domain_id=%d, group=%pK",
 			msm_audio_ion_data.domain,
 			msm_audio_ion_data.domain_id, msm_audio_ion_data.group);
 
@@ -521,7 +521,7 @@ static int msm_audio_ion_probe(struct platform_device *pdev)
 
 static int msm_audio_ion_remove(struct platform_device *pdev)
 {
-	pr_debug("%s: msm audio ion is unloaded, domain=%p, group=%p\n",
+	pr_debug("%s: msm audio ion is unloaded, domain=%pK, group=%pK\n",
 		__func__, msm_audio_ion_data.domain, msm_audio_ion_data.group);
 	iommu_detach_group(msm_audio_ion_data.domain, msm_audio_ion_data.group);
 
diff --git a/arch/arm/mach-msm/qdsp6v2/pcm_in.c b/arch/arm/mach-msm/qdsp6v2/pcm_in.c
index cf7548d9347..c770322b705 100644
--- a/arch/arm/mach-msm/qdsp6v2/pcm_in.c
+++ b/arch/arm/mach-msm/qdsp6v2/pcm_in.c
@@ -408,7 +408,7 @@ static ssize_t pcm_in_read(struct file *file, char __user *buf,
 			len = size;
 		else {
 			len = count;
-			pr_err("%s: short read data[%p]bytesavail[%d]"
+			pr_err("%s: short read data[%pK]bytesavail[%d]"
 				"bytesrequest[%d]"
 				"bytesrejected%d]\n",\
 				__func__, data, size,
diff --git a/arch/arm/mach-msm/qdsp6v2/q6audio_v1_aio.c b/arch/arm/mach-msm/qdsp6v2/q6audio_v1_aio.c
index ffd14bd2c2e..dddafba47a2 100644
--- a/arch/arm/mach-msm/qdsp6v2/q6audio_v1_aio.c
+++ b/arch/arm/mach-msm/qdsp6v2/q6audio_v1_aio.c
@@ -56,18 +56,18 @@ void audio_aio_cb(uint32_t opcode, uint32_t token,
 
 	switch (opcode) {
 	case ASM_DATA_EVENT_WRITE_DONE:
-		pr_debug("%s[%p]:ASM_DATA_EVENT_WRITE_DONE token = 0x%x\n",
+		pr_debug("%s[%pK]:ASM_DATA_EVENT_WRITE_DONE token = 0x%x\n",
 			__func__, audio, token);
 		audio_aio_async_write_ack(audio, token, payload);
 		break;
 	case ASM_DATA_EVENT_READ_DONE:
-		pr_debug("%s[%p]:ASM_DATA_EVENT_READ_DONE token = 0x%x\n",
+		pr_debug("%s[%pK]:ASM_DATA_EVENT_READ_DONE token = 0x%x\n",
 			__func__, audio, token);
 		audio_aio_async_read_ack(audio, token, payload);
 		break;
 	case ASM_DATA_CMDRSP_EOS:
 		/* EOS Handle */
-		pr_debug("%s[%p]:ASM_DATA_CMDRSP_EOS\n", __func__, audio);
+		pr_debug("%s[%pK]:ASM_DATA_CMDRSP_EOS\n", __func__, audio);
 		if (audio->feedback) { /* Non-Tunnel mode */
 			audio->eos_rsp = 1;
 			/* propagate input EOS i/p buffer,
@@ -89,18 +89,18 @@ void audio_aio_cb(uint32_t opcode, uint32_t token,
 		break;
 	case ASM_DATA_CMD_MEDIA_FORMAT_UPDATE:
 	case ASM_STREAM_CMD_SET_ENCDEC_PARAM:
-		pr_debug("%s[%p]:payload0[%x] payloa1d[%x]opcode= 0x%x\n",
+		pr_debug("%s[%pK]:payload0[%x] payloa1d[%x]opcode= 0x%x\n",
 			__func__, audio, payload[0], payload[1], opcode);
 		break;
 	case ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY:
 	case ASM_DATA_EVENT_ENC_SR_CM_NOTIFY:
-		pr_debug("%s[%p]: ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY, "
+		pr_debug("%s[%pK]: ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY, "
 
 				"payload[0]-sr = %d, payload[1]-chl = %d, "
 				"payload[2] = %d, payload[3] = %d\n", __func__,
 				audio, payload[0], payload[1], payload[2],
 				payload[3]);
-		pr_debug("%s[%p]: ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY, sr(prev) = %d, chl(prev) = %d,",
+		pr_debug("%s[%pK]: ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY, sr(prev) = %d, chl(prev) = %d,",
 		__func__, audio, audio->pcm_cfg.sample_rate,
 		audio->pcm_cfg.channel_count);
 		audio->pcm_cfg.sample_rate = payload[0];
@@ -145,7 +145,7 @@ void extract_meta_out_info(struct q6audio_aio *audio,
 		else
 			memset(&buf_node->meta_info.meta_in,
 			0, sizeof(struct dec_meta_in));
-		pr_debug("%s[%p]:i/p: msw_ts 0x%lx lsw_ts 0x%lx nflags 0x%8x\n",
+		pr_debug("%s[%pK]:i/p: msw_ts 0x%lx lsw_ts 0x%lx nflags 0x%8x\n",
 			__func__, audio,
 			buf_node->meta_info.meta_in.ntimestamp.highpart,
 			buf_node->meta_info.meta_in.ntimestamp.lowpart,
@@ -155,7 +155,7 @@ void extract_meta_out_info(struct q6audio_aio *audio,
 			&buf_node->meta_info.meta_out,
 			sizeof(struct dec_meta_out));
 		meta_data->meta_out_dsp[0].nflags = 0x00000000;
-		pr_debug("%s[%p]:o/p: msw_ts 0x%8x lsw_ts 0x%8x nflags 0x%8x, num_frames = %d\n",
+		pr_debug("%s[%pK]:o/p: msw_ts 0x%8x lsw_ts 0x%8x nflags 0x%8x, num_frames = %d\n",
 		__func__, audio,
 		((struct dec_meta_out *)buf_node->kvaddr)->\
 			meta_out_dsp[0].msw_ts,
@@ -204,7 +204,7 @@ void audio_aio_async_read_ack(struct q6audio_aio *audio, uint32_t token,
 			event_payload.aio_buf.data_len = payload[2] + \
 						payload[3] + \
 						sizeof(struct dec_meta_out);
-			pr_debug("%s[%p]:nr of frames 0x%8x len=%d\n",
+			pr_debug("%s[%pK]:nr of frames 0x%8x len=%d\n",
 				__func__, audio,
 				filled_buf->meta_info.meta_out.num_of_frames,
 				event_payload.aio_buf.data_len);
@@ -215,7 +215,7 @@ void audio_aio_async_read_ack(struct q6audio_aio *audio, uint32_t token,
 					event_payload);
 		kfree(filled_buf);
 	} else {
-		pr_err("%s[%p]:expected=%lx ret=%x\n",
+		pr_err("%s[%pK]:expected=%lx ret=%x\n",
 			__func__, audio, filled_buf->token, token);
 		spin_unlock_irqrestore(&audio->dsp_lock, flags);
 	}
diff --git a/arch/arm/mach-msm/qdsp6v2/q6audio_v2_aio.c b/arch/arm/mach-msm/qdsp6v2/q6audio_v2_aio.c
index 21040b15e1c..d1fafb5a668 100644
--- a/arch/arm/mach-msm/qdsp6v2/q6audio_v2_aio.c
+++ b/arch/arm/mach-msm/qdsp6v2/q6audio_v2_aio.c
@@ -54,18 +54,18 @@ void audio_aio_cb(uint32_t opcode, uint32_t token,
 
 	switch (opcode) {
 	case ASM_DATA_EVENT_WRITE_DONE_V2:
-		pr_debug("%s[%p]:ASM_DATA_EVENT_WRITE_DONE token = 0x%x\n",
+		pr_debug("%s[%pK]:ASM_DATA_EVENT_WRITE_DONE token = 0x%x\n",
 			__func__, audio, token);
 		audio_aio_async_write_ack(audio, token, payload);
 		break;
 	case ASM_DATA_EVENT_READ_DONE_V2:
-		pr_debug("%s[%p]:ASM_DATA_EVENT_READ_DONE token = 0x%x\n",
+		pr_debug("%s[%pK]:ASM_DATA_EVENT_READ_DONE token = 0x%x\n",
 			__func__, audio, token);
 		audio_aio_async_read_ack(audio, token, payload);
 		break;
 	case ASM_DATA_EVENT_RENDERED_EOS:
 		/* EOS Handle */
-		pr_debug("%s[%p]:ASM_DATA_CMDRSP_EOS\n", __func__, audio);
+		pr_debug("%s[%pK]:ASM_DATA_CMDRSP_EOS\n", __func__, audio);
 		if (audio->feedback) { /* Non-Tunnel mode */
 			audio->eos_rsp = 1;
 			/* propagate input EOS i/p buffer,
@@ -87,16 +87,16 @@ void audio_aio_cb(uint32_t opcode, uint32_t token,
 		break;
 	case ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2:
 	case ASM_STREAM_CMD_SET_ENCDEC_PARAM:
-		pr_debug("%s[%p]:payload0[%x] payloa1d[%x]opcode= 0x%x\n",
+		pr_debug("%s[%pK]:payload0[%x] payloa1d[%x]opcode= 0x%x\n",
 			__func__, audio, payload[0], payload[1], opcode);
 		break;
 	case ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY:
 	case ASM_DATA_EVENT_ENC_SR_CM_CHANGE_NOTIFY:
-		pr_debug("%s[%p]: ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY, payload[0]-sr = %d, payload[1]-chl = %d, payload[2] = %d, payload[3] = %d\n",
+		pr_debug("%s[%pK]: ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY, payload[0]-sr = %d, payload[1]-chl = %d, payload[2] = %d, payload[3] = %d\n",
 					 __func__, audio, payload[0],
 					 payload[1], payload[2], payload[3]);
 
-		pr_debug("%s[%p]: ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY, sr(prev) = %d, chl(prev) = %d,",
+		pr_debug("%s[%pK]: ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY, sr(prev) = %d, chl(prev) = %d,",
 		__func__, audio, audio->pcm_cfg.sample_rate,
 		audio->pcm_cfg.channel_count);
 
@@ -129,7 +129,7 @@ void extract_meta_out_info(struct q6audio_aio *audio,
 		else
 			memset(&buf_node->meta_info.meta_in,
 			0, sizeof(struct dec_meta_in));
-		pr_debug("%s[%p]:i/p: msw_ts 0x%lx lsw_ts 0x%lx nflags 0x%8x\n",
+		pr_debug("%s[%pK]:i/p: msw_ts 0x%lx lsw_ts 0x%lx nflags 0x%8x\n",
 			__func__, audio,
 			buf_node->meta_info.meta_in.ntimestamp.highpart,
 			buf_node->meta_info.meta_in.ntimestamp.lowpart,
@@ -144,7 +144,7 @@ void extract_meta_out_info(struct q6audio_aio *audio,
 				meta_data->meta_out_dsp[0].lsw_ts;
 		meta_data->meta_out_dsp[0].lsw_ts = temp;
 
-		pr_debug("%s[%p]:o/p: msw_ts 0x%8x lsw_ts 0x%8x nflags 0x%8x, num_frames = %d\n",
+		pr_debug("%s[%pK]:o/p: msw_ts 0x%8x lsw_ts 0x%8x nflags 0x%8x, num_frames = %d\n",
 		__func__, audio,
 		((struct dec_meta_out *)buf_node->kvaddr)->\
 			meta_out_dsp[0].msw_ts,
@@ -200,7 +200,7 @@ void audio_aio_async_read_ack(struct q6audio_aio *audio, uint32_t token,
 							 = payload[9];
 			event_payload.aio_buf.data_len = payload[4]\
 				 + payload[5] + sizeof(struct dec_meta_out);
-			pr_debug("%s[%p]:nr of frames 0x%8x len=%d\n",
+			pr_debug("%s[%pK]:nr of frames 0x%8x len=%d\n",
 				__func__, audio,
 				filled_buf->meta_info.meta_out.num_of_frames,
 				event_payload.aio_buf.data_len);
@@ -212,7 +212,7 @@ void audio_aio_async_read_ack(struct q6audio_aio *audio, uint32_t token,
 					event_payload);
 		kfree(filled_buf);
 	} else {
-		pr_err("%s[%p]:expected=%lx ret=%x\n",
+		pr_err("%s[%pK]:expected=%lx ret=%x\n",
 			__func__, audio, filled_buf->token, token);
 		spin_unlock_irqrestore(&audio->dsp_lock, flags);
 	}
diff --git a/arch/arm/mach-msm/qdsp6v2/q6core.c b/arch/arm/mach-msm/qdsp6v2/q6core.c
index fd699dfe5db..a497deb9c2d 100644
--- a/arch/arm/mach-msm/qdsp6v2/q6core.c
+++ b/arch/arm/mach-msm/qdsp6v2/q6core.c
@@ -160,7 +160,7 @@ void core_open(void)
 		core_handle_q = apr_register("ADSP", "CORE",
 					aprv2_core_fn_q, 0xFFFFFFFF, NULL);
 	}
-	pr_debug("Open_q %p\n", core_handle_q);
+	pr_debug("Open_q %pK\n", core_handle_q);
 	if (core_handle_q == NULL)
 		pr_err("%s: Unable to register CORE\n", __func__);
 }
@@ -265,11 +265,11 @@ static ssize_t apr_debug_write(struct file *file, const char __user *buf,
 	if (!strncmp(l_buf + 20, "open_q", 64)) {
 		apr_handle_q = apr_register("ADSP", "TEST", aprv2_debug_fn_q,
 							0xFFFFFFFF, NULL);
-		pr_info("Open_q %p\n", apr_handle_q);
+		pr_info("Open_q %pK\n", apr_handle_q);
 	} else if (!strncmp(l_buf + 20, "open_m", 64)) {
 		apr_handle_m = apr_register("MODEM", "TEST", aprv2_debug_fn_m,
 							0xFFFFFFFF, NULL);
-		pr_info("Open_m %p\n", apr_handle_m);
+		pr_info("Open_m %pK\n", apr_handle_m);
 	} else if (!strncmp(l_buf + 20, "write_q", 64)) {
 		struct apr_hdr *hdr;
 
