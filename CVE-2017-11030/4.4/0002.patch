From 2be7caec635de9fcf0d2145f858635e9366f0f4f Mon Sep 17 00:00:00 2001
From: Ashish Garg <ashigarg@codeaurora.org>
Date: Fri, 9 Jun 2017 16:49:15 +0530
Subject: msm: mdss: validate page id before reading from edid buffer

Provide complete resolution details in a sysfs node "res_info"
limited to PAGE_SIZE. Different modules can query for multiple
resolution details based on the resolution ids received from
EDID of the TV. In case resolution details exceed PAGE_SIZE,
reuse res_info to get remaining timing details by provide page
details. Check page id is within the max supported resolution
ids to avoid reading extra memory than required.

Change-Id: I7cdd071ba462080fe5bb302d0da824ed95b50f15
Signed-off-by: Ashish Garg <ashigarg@codeaurora.org>
---
 drivers/video/fbdev/msm/mdss_hdmi_edid.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/drivers/video/fbdev/msm/mdss_hdmi_edid.c b/drivers/video/fbdev/msm/mdss_hdmi_edid.c
index ddc5edb..a953dd1 100644
--- a/drivers/video/fbdev/msm/mdss_hdmi_edid.c
+++ b/drivers/video/fbdev/msm/mdss_hdmi_edid.c
@@ -469,8 +469,10 @@ static ssize_t hdmi_edid_sysfs_wta_res_info(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
 	int rc, page_id;
+	u32 i = 0, j, page;
 	ssize_t ret = strnlen(buf, PAGE_SIZE);
 	struct hdmi_edid_ctrl *edid_ctrl = hdmi_edid_get_ctrl(dev);
+	struct msm_hdmi_mode_timing_info info = {0};
 
 	if (!edid_ctrl) {
 		DEV_ERR("%s: invalid input\n", __func__);
@@ -483,7 +485,22 @@ static ssize_t hdmi_edid_sysfs_wta_res_info(struct device *dev,
 		return rc;
 	}
 
-	edid_ctrl->page_id = page_id;
+	if (page_id > MSM_HDMI_INIT_RES_PAGE) {
+		page = MSM_HDMI_INIT_RES_PAGE;
+		while (page < page_id) {
+			j = 1;
+			while (sizeof(info) * j < PAGE_SIZE) {
+				i++;
+				j++;
+			}
+			page++;
+		}
+	}
+
+	if (i < HDMI_VFRMT_MAX)
+		edid_ctrl->page_id = page_id;
+	else
+		DEV_ERR("%s: invalid page id\n", __func__);
 
 	DEV_DBG("%s: %d\n", __func__, edid_ctrl->page_id);
 	return ret;
-- 
cgit v1.1

