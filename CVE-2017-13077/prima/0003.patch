From 8bb90caf194a1b56ac60d7421f30ae49493d9a3d Mon Sep 17 00:00:00 2001
From: Sravan Kumar Kairam <sgoud@codeaurora.org>
Date: Wed, 1 Nov 2017 19:00:23 +0530
Subject: wlan: Update key sequence counter to TL

Currently the key sequence counter received from user space is
not updated at TL. So update the sequence counter to TL.

Change-Id: I460d64511502fd414d0e8568c69712bbe54dd7fa
CRs-Fixed: 2136293
---
 CORE/HDD/src/wlan_hdd_assoc.c    |  5 -----
 CORE/HDD/src/wlan_hdd_cfg80211.c | 17 +++++++++++++++++
 CORE/TL/inc/wlan_qct_tl.h        | 10 ++++++++++
 CORE/TL/src/wlan_qct_tl.c        | 28 ++++++++++++++++++++++++++++
 CORE/TL/src/wlan_qct_tl_ba.c     |  6 +-----
 5 files changed, 56 insertions(+), 10 deletions(-)

diff --git a/CORE/HDD/src/wlan_hdd_assoc.c b/CORE/HDD/src/wlan_hdd_assoc.c
index 7e5de46..287b29c 100644
--- a/CORE/HDD/src/wlan_hdd_assoc.c
+++ b/CORE/HDD/src/wlan_hdd_assoc.c
@@ -1922,7 +1922,6 @@ static VOS_STATUS hdd_roamRegisterSTA( hdd_adapter_t *pAdapter,
    staDesc.ucIsEseSta = pRoamInfo->isESEAssoc;
 #endif //FEATURE_WLAN_ESE
 
-#ifdef VOLANS_ENABLE_SW_REPLAY_CHECK
    /* check whether replay check is valid for the station or not */
    if( (eCSR_ENCRYPT_TYPE_TKIP == connectedCipherAlgo) || (eCSR_ENCRYPT_TYPE_AES == connectedCipherAlgo))
    {
@@ -1933,7 +1932,6 @@ static VOS_STATUS hdd_roamRegisterSTA( hdd_adapter_t *pAdapter,
        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
                  "HDD register TL ucIsReplayCheckValid %d: Replay check is needed for station", staDesc.ucIsReplayCheckValid);
    }
-
    else
    {
       /* For other encryption modes replay check is
@@ -1942,7 +1940,6 @@ static VOS_STATUS hdd_roamRegisterSTA( hdd_adapter_t *pAdapter,
         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
                  "HDD register TL ucIsReplayCheckValid %d", staDesc.ucIsReplayCheckValid);
    }
-#endif
 
 #ifdef FEATURE_WLAN_WAPI
    hddLog(LOG1, "%s: WAPI STA Registered: %d", __func__, pAdapter->wapi_info.fIsWapiSta);
@@ -3424,12 +3421,10 @@ VOS_STATUS hdd_roamRegisterTDLSSTA(hdd_adapter_t *pAdapter,
     /* tdls Direct Link do not need bcastSig */
     staDesc.ucBcastSig  = 0 ;
 
-#ifdef VOLANS_ENABLE_SW_REPLAY_CHECK
     if(staDesc.ucProtectedFrame)
         staDesc.ucIsReplayCheckValid = VOS_TRUE;
     else
         staDesc.ucIsReplayCheckValid = VOS_FALSE;
-#endif
 
     staDesc.ucInitState = WLANTL_STA_CONNECTED ;
 
diff --git a/CORE/HDD/src/wlan_hdd_cfg80211.c b/CORE/HDD/src/wlan_hdd_cfg80211.c
index 64ecb2b..edf1bf7 100644
--- a/CORE/HDD/src/wlan_hdd_cfg80211.c
+++ b/CORE/HDD/src/wlan_hdd_cfg80211.c
@@ -12039,6 +12039,9 @@ static int __wlan_hdd_cfg80211_add_key( struct wiphy *wiphy,
     VOS_STATUS vos_status;
     eHalStatus halStatus;
     hdd_context_t *pHddCtx;
+    uint8_t staid, i;
+    v_MACADDR_t *peerMacAddr;
+    u64 rsc_counter = 0;
 
     ENTER();
 
@@ -12082,6 +12085,8 @@ static int __wlan_hdd_cfg80211_add_key( struct wiphy *wiphy,
            "%s: called with key index = %d & key length %d & seq length %d",
            __func__, key_index, params->key_len, params->seq_len);
 
+    peerMacAddr = (v_MACADDR_t *)mac_addr;
+
     /*extract key idx, key len and key*/
     vos_mem_zero(&setKey,sizeof(tCsrRoamSetKey));
     setKey.keyId = key_index;
@@ -12223,6 +12228,8 @@ static int __wlan_hdd_cfg80211_add_key( struct wiphy *wiphy,
             hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
             vos_status = wlan_hdd_check_ula_done(pAdapter);
 
+            staid = hdd_sta_id_find_from_mac_addr(pAdapter, peerMacAddr);
+
             if ( vos_status != VOS_STATUS_SUCCESS )
             {
                 VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -12284,6 +12291,8 @@ static int __wlan_hdd_cfg80211_add_key( struct wiphy *wiphy,
             }
         }
 
+        staid = pHddStaCtx->conn_info.staId[0];
+
         pWextState->roamProfile.Keys.KeyLength[key_index] = (u8)params->key_len;
 
         pWextState->roamProfile.Keys.defaultIndex = key_index;
@@ -12391,6 +12400,14 @@ static int __wlan_hdd_cfg80211_add_key( struct wiphy *wiphy,
         }
     }
 
+    if (pairwise) {
+       for (i = 0; i < params->seq_len; i++) {
+          rsc_counter |= (params->seq[i] << i*8);
+       }
+
+       WLANTL_SetKeySeqCounter(pVosContext, rsc_counter, staid);
+    }
+
 end:
     /* Need to clear any trace of key value in the memory.
      * Thus zero out the memory even though it is local
diff --git a/CORE/TL/inc/wlan_qct_tl.h b/CORE/TL/inc/wlan_qct_tl.h
index 353a28a..146d658 100644
--- a/CORE/TL/inc/wlan_qct_tl.h
+++ b/CORE/TL/inc/wlan_qct_tl.h
@@ -3437,4 +3437,14 @@ void WLANTL_SetARPFWDatapath(void * pvosGCtx, bool flag);
  * Return: void
  */
 void WLANTL_GetSAPStaRSSi(void * pvosGCtx, uint8_t ucSTAId, s8 *rssi);
+
+/**
+ * WLANTL_SetKeySeqCounter() - set sequence key counter
+ * @pvosGCtx: global vos context
+ * @counter: key sequence counter
+ * @staid: station index
+ *
+ * Return: void
+ */
+void WLANTL_SetKeySeqCounter(void *pvosGCtx, u64 counter, uint8_t staid);
 #endif /* #ifndef WLAN_QCT_WLANTL_H */
diff --git a/CORE/TL/src/wlan_qct_tl.c b/CORE/TL/src/wlan_qct_tl.c
index 475d42a..97e4766 100755
--- a/CORE/TL/src/wlan_qct_tl.c
+++ b/CORE/TL/src/wlan_qct_tl.c
@@ -14437,6 +14437,34 @@ void WLANTL_GetSAPStaRSSi(void *pvosGCtx, uint8_t ucSTAId, s8 *rssi)
    *rssi = pTLCb->atlSTAClients[ucSTAId]->rssi_sample_sum / count;
 }
 
+void WLANTL_SetKeySeqCounter(void *pvosGCtx, u64 counter, uint8_t staid)
+{
+   WLANTL_CbType*  pTLCb = NULL;
+   uint8_t i;
+
+   pTLCb = VOS_GET_TL_CB(pvosGCtx);
+   if (NULL == pTLCb) {
+      TLLOGE(VOS_TRACE( VOS_MODULE_ID_TL, VOS_TRACE_LEVEL_ERROR,
+             "%s: Invalid TL pointer from pvosGCtx", __func__));
+      return;
+   }
+
+   if (WLANTL_STA_ID_INVALID(staid)) {
+      TLLOGE(VOS_TRACE( VOS_MODULE_ID_TL, VOS_TRACE_LEVEL_ERROR,
+             "%s: Invalid Sta id passed", __func__));
+      return;
+   }
+
+   if (NULL == pTLCb->atlSTAClients[staid]) {
+      TLLOGE(VOS_TRACE( VOS_MODULE_ID_TL, VOS_TRACE_LEVEL_ERROR,
+             "%s: Station context is NULL", __func__));
+      return;
+   }
+
+   for(i = 0; i < WLANTL_MAX_TID; i++)
+      pTLCb->atlSTAClients[staid]->ullReplayCounter[i] = counter;
+}
+
 #ifdef WLAN_FEATURE_RMC
 VOS_STATUS WLANTL_RmcInit
 (
diff --git a/CORE/TL/src/wlan_qct_tl_ba.c b/CORE/TL/src/wlan_qct_tl_ba.c
index efca2c0..e01d128 100644
--- a/CORE/TL/src/wlan_qct_tl_ba.c
+++ b/CORE/TL/src/wlan_qct_tl_ba.c
@@ -1129,16 +1129,12 @@ VOS_STATUS WLANTL_MSDUReorder
    ucFwdIdx  = (v_U8_t)WDA_GET_RX_REORDER_FWD_IDX(pvBDHeader);
    CSN       = (v_U16_t)WDA_GET_RX_REORDER_CUR_PKT_SEQ_NO(pvBDHeader);
 
-
-
-#ifdef WLANTL_HAL_VOLANS
    /* Replay check code : check whether replay check is needed or not */
    if(VOS_TRUE == pClientSTA->ucIsReplayCheckValid)
    {
            /* Getting 48-bit replay counter from the RX BD */
-           ullreplayCounter = WDA_DS_GetReplayCounter(aucBDHeader);
+           ullreplayCounter = WDA_DS_GetReplayCounter(pvBDHeader);
    }
-#endif 
 
 #ifdef WLANTL_REORDER_DEBUG_MSG_ENABLE
    TLLOGE(VOS_TRACE(VOS_MODULE_ID_TL, VOS_TRACE_LEVEL_ERROR,"opCode %d SI %d, FI %d, CI %d seqNo %d", ucOpCode, ucSlotIdx, ucFwdIdx, currentReorderInfo->ucCIndex, CSN));
-- 
cgit v1.1

