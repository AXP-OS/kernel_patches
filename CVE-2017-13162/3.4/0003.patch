From ab16327e420b4cd1608f6c5cbb88f93e6e217428 Mon Sep 17 00:00:00 2001
From: Todd Kjos <tkjos@google.com>
Date: Wed, 6 Dec 2017 22:20:13 +0100
Subject: [PATCH] ANDROID: binder: fix OOB write in __binder_update_page_range

commit e12f1f1c65a9 ("binder: always allocate/map first
BINDER_MIN_ALLOC pages") introduced a vulnerability where
the alloc->pages array can be accessed beyond the allocated
elements. For this to occur, the passed-in VMA range must
be < BINDER_MIN_ALLOC pages (which cannot happen for normal
use cases). BINDER_MIN_ALLOC is set to 6 pages, so mmap'ing
1 page results in OOB accesses.

The fix is to return an error if binder_mmap is called with
a VMA size less than BINDER_MIN_ALLOC.

Bug: 64216036
Test: verified fixed with submitter's test program
Change-Id: I4b6dbf3f466fea46e587d6a33f724ee4fe7f1368
Signed-off-by: Todd Kjos <tkjos@google.com>
CVE-2017-13162
Signed-off-by: Kevin F. Haggerty <haggertk@lineageos.org>
---
 drivers/staging/android/binder.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index 5b14766c2af..e88574c7831 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -3007,6 +3007,11 @@ static int binder_mmap(struct file *filp, struct vm_area_struct *vma)
 		}
 	}
 #endif
+	if (vma->vm_end - vma->vm_start < BINDER_MIN_ALLOC) {
+		ret = -EINVAL;
+		failure_string = "VMA size < BINDER_MIN_ALLOC";
+		goto err_vma_too_small;
+	}
 	proc->pages = kzalloc(sizeof(proc->pages[0]) * ((vma->vm_end - vma->vm_start) / PAGE_SIZE), GFP_KERNEL);
 	if (proc->pages == NULL) {
 		ret = -ENOMEM;
@@ -3044,6 +3049,7 @@ static int binder_mmap(struct file *filp, struct vm_area_struct *vma)
 	kfree(proc->pages);
 	proc->pages = NULL;
 err_alloc_pages_failed:
+err_vma_too_small:
 	mutex_lock(&binder_mmap_lock);
 	vfree(proc->buffer);
 	proc->buffer = NULL;
