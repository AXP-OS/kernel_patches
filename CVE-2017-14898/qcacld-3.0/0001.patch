From f4bc0d11aa35ffe5f58fdcb7e4bfeffa08011128 Mon Sep 17 00:00:00 2001
From: Dustin Brown <dustinb@codeaurora.org>
Date: Fri, 2 Jun 2017 10:33:51 -0700
Subject: qcacld-3.0: Avoid MAC address overrun in get chain RSSI

Currently, in __wlan_hdd_cfg80211_get_chain_rssi the
QCA_WLAN_VENDOR_ATTR_MAC_ADDR attribute is read without providing an
nla policy. This can lead to a buffer overrun if userspace provides less
than the expected amount of data. Ensure the expected amount of data has
been passed from userspace before using the
QCA_WLAN_VENDOR_ATTR_MAC_ADDR attribute in
__wlan_hdd_cfg80211_get_chain_rssi.

Change-Id: Ibffb925b9ec574a07f887299ed3035779367dce4
CRs-Fixed: 2054758
---
 core/hdd/src/wlan_hdd_cfg80211.c | 24 +++++++++++++++++-------
 1 file changed, 17 insertions(+), 7 deletions(-)

diff --git a/core/hdd/src/wlan_hdd_cfg80211.c b/core/hdd/src/wlan_hdd_cfg80211.c
index 9c0b8cf..bd9a110 100644
--- a/core/hdd/src/wlan_hdd_cfg80211.c
+++ b/core/hdd/src/wlan_hdd_cfg80211.c
@@ -9123,8 +9123,10 @@ static int __wlan_hdd_cfg80211_get_chain_rssi(struct wiphy *wiphy,
 	struct hdd_chain_rssi_context *context;
 	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_MAX + 1];
 	QDF_STATUS status;
-	int retval = 0;
+	int retval;
 	unsigned long rc;
+	const int mac_len = sizeof(req_msg.peer_macaddr);
+	int msg_len;
 
 	ENTER();
 
@@ -9132,19 +9134,27 @@ static int __wlan_hdd_cfg80211_get_chain_rssi(struct wiphy *wiphy,
 	if (0 != retval)
 		return retval;
 
-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len, NULL)) {
-		hdd_err(FL("Invalid ATTR"));
-		return -EINVAL;
+	/* nla validation doesn't do exact lengths, do the validation later */
+	retval = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len, NULL);
+	if (retval) {
+		hdd_err("Invalid ATTR");
+		return retval;
 	}
 
 	if (!tb[QCA_WLAN_VENDOR_ATTR_MAC_ADDR]) {
-		hdd_err(FL("attr mac addr failed"));
+		hdd_err("attr mac addr failed");
 		return -EINVAL;
 	}
 
+	msg_len = nla_len(tb[QCA_WLAN_VENDOR_ATTR_MAC_ADDR]);
+	if (msg_len != mac_len) {
+		hdd_err("Invalid mac address length: %d, expected %d",
+			msg_len, mac_len);
+		return -ERANGE;
+	}
+
 	memcpy(&req_msg.peer_macaddr,
-		nla_data(tb[QCA_WLAN_VENDOR_ATTR_MAC_ADDR]),
-		sizeof(req_msg.peer_macaddr));
+	       nla_data(tb[QCA_WLAN_VENDOR_ATTR_MAC_ADDR]), mac_len);
 	req_msg.session_id = pAdapter->sessionId;
 
 	spin_lock(&hdd_context_lock);
-- 
cgit v1.1

