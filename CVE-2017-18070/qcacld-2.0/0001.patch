From dc6c24b0a660d643c90a9cede1be4bdd44509b3e Mon Sep 17 00:00:00 2001
From: gaurank kathpalia <gkathpal@codeaurora.org>
Date: Tue, 7 Nov 2017 15:07:27 +0530
Subject: qcacld-2.0: Avoid integer overflow in
 wma_ndp_end_response_event_handler

The variable 'len_end_rsp' is a uint32 which can be overflowed if the
value of variable "event->num_ndp_end_rsp_per_ndi_list" is very large.
If the integer overflow occurs, finally it would lead to a heap overwrite
of heap object "end_rsp".

Check for len_end_rsp size , and ensure that an integer overflow does not
happen in wma_peer_info_event_handler.

Change-Id: I75cfaeacbee93fb27ad587feddfe298ca1d0d19b
CRs-Fixed: 2114348
---
 CORE/SERVICES/WMA/wma_nan_datapath.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/CORE/SERVICES/WMA/wma_nan_datapath.c b/CORE/SERVICES/WMA/wma_nan_datapath.c
index 45b604f..7aec779 100644
--- a/CORE/SERVICES/WMA/wma_nan_datapath.c
+++ b/CORE/SERVICES/WMA/wma_nan_datapath.c
@@ -664,6 +664,14 @@ static int wma_ndp_end_response_event_handler(void *handle,
 	WMA_LOGD(FL("WMI_NDP_END_RSP_EVENTID(0x%X) recieved. transaction_id: %d, rsp_status: %d, reason_code: %d"),
 		 WMI_NDP_END_RSP_EVENTID, fixed_params->transaction_id,
 		 fixed_params->rsp_status, fixed_params->reason_code);
+	if (((U32_MAX - sizeof(*end_rsp))/sizeof(struct peer_ndp_map)) <
+					 event->num_ndp_end_rsp_per_ndi_list) {
+		WMA_LOGD(FL(" Number of NDP end rsp %d is very large "),
+			event->num_ndp_end_rsp_per_ndi_list);
+		pe_msg.bodyval = true;
+		ret = -EINVAL;
+		goto send_ndp_end_rsp;
+	}
 
 	len_end_rsp = sizeof(*end_rsp) + (event->num_ndp_end_rsp_per_ndi_list *
 						sizeof(struct peer_ndp_map));
-- 
cgit v1.1

