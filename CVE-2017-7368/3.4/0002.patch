From b8a181e46ece18060c07429bf06a25eea95d1fc5 Mon Sep 17 00:00:00 2001
From: Yeleswarapu Nagaradhesh <nagaradh@codeaurora.org>
Date: Tue, 14 Feb 2017 14:27:56 +0530
Subject: [PATCH] ASoC: msm: acquire lock in ioctl

If two ioctls are triggered with different commands,
there is a possibility to access freed confidence level
memory. To resolve this acquire lock in ioctl.
Also release mutex lock properly in error cases.

CRs-Fixed: 1103085
Change-Id: I7d6b2eff21c8297e5f0755a0c141254be32f777d
Signed-off-by: Yeleswarapu Nagaradhesh <nagaradh@codeaurora.org>
[haggertk]: Backport to 3.4/msm8974
CVE-2017-7368
Signed-off-by: Kevin F. Haggerty <haggertk@lineageos.org>
---
 sound/soc/msm/qdsp6v2/msm-lsm-client.c | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/sound/soc/msm/qdsp6v2/msm-lsm-client.c b/sound/soc/msm/qdsp6v2/msm-lsm-client.c
index 2c7a42b6afc..3050f431de5 100644
--- a/sound/soc/msm/qdsp6v2/msm-lsm-client.c
+++ b/sound/soc/msm/qdsp6v2/msm-lsm-client.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Linux Foundation. All rights reserved.
+ * Copyright (c) 2013, 2017, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -39,6 +39,7 @@ struct lsm_priv {
 	wait_queue_head_t event_wait;
 	unsigned long event_avail;
 	atomic_t event_wait_stop;
+	struct mutex lsm_api_lock;
 };
 
 static void lsm_event_handler(uint32_t opcode, uint32_t token,
@@ -95,6 +96,7 @@ static int msm_lsm_ioctl(struct snd_pcm_substream *substream,
 	struct lsm_priv *prtd = runtime->private_data;
 	struct snd_lsm_event_status *user = arg;
 
+	mutex_lock(&prtd->lsm_api_lock);
 	pr_debug("%s: enter cmd %x\n", __func__, cmd);
 	switch (cmd) {
 	case SNDRV_LSM_REG_SND_MODEL:
@@ -144,10 +146,18 @@ static int msm_lsm_ioctl(struct snd_pcm_substream *substream,
 	case SNDRV_LSM_EVENT_STATUS:
 		pr_debug("%s: Get event status\n", __func__);
 		atomic_set(&prtd->event_wait_stop, 0);
+
+		/*
+		 * Release the api lock before wait to allow
+		 * other IOCTLs to be invoked while waiting
+		 * for event
+		 */
+		mutex_unlock(&prtd->lsm_api_lock);
 		rc = wait_event_interruptible(prtd->event_wait,
 				(cmpxchg(&prtd->event_avail, 1, 0) ||
 				 (xchg = atomic_cmpxchg(&prtd->event_wait_stop,
 							1, 0))));
+		mutex_lock(&prtd->lsm_api_lock);
 		pr_debug("%s: wait_event_interruptible %d event_wait_stop %d\n",
 			 __func__, rc, xchg);
 		if (!rc && !xchg) {
@@ -238,6 +248,7 @@ static int msm_lsm_ioctl(struct snd_pcm_substream *substream,
 	else
 		pr_err("%s: cmd 0x%x failed %d\n", __func__, cmd, rc);
 
+	mutex_unlock(&prtd->lsm_api_lock);
 	return rc;
 }
 
@@ -272,6 +283,7 @@ static int msm_lsm_open(struct snd_pcm_substream *substream)
 
 	pr_debug("%s: Session ID %d\n", __func__, prtd->lsm_client->session);
 	prtd->lsm_client->started = false;
+	mutex_init(&prtd->lsm_api_lock);
 	spin_lock_init(&prtd->event_lock);
 	init_waitqueue_head(&prtd->event_wait);
 	runtime->private_data = prtd;
@@ -321,6 +333,7 @@ static int msm_lsm_close(struct snd_pcm_substream *substream)
 	kfree(prtd->event_status);
 	prtd->event_status = NULL;
 	spin_unlock_irqrestore(&prtd->event_lock, flags);
+	mutex_destroy(&prtd->lsm_api_lock);
 	kfree(prtd);
 	runtime->private_data = NULL;
 
