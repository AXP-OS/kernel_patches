From e8c520575d06aa07feaedea9cee8f6b472582d67 Mon Sep 17 00:00:00 2001
From: Haibin Liu <haibinl@codeaurora.org>
Date: Wed, 9 Aug 2017 16:26:41 +0800
Subject: [PATCH] msm: sensor: Fix crash when ioctl VIDIOC_MSM_SENSOR_INIT_CFG

Issue:
the invalid slave_info is used by msm_sensor_driver_probe.
This cause crash when ioctl VIDIOC_MSM_SENSOR_INIT_CFG repeatedly.

Fix:
1) avoid the same msm_sd_subdev added into the ordered_sd_list.
2) enlarge the buffer size for i2c addr and data.

Bug: 36492827
Change-Id: Idffcd3b82b9590dbfdcaf14b80668cc894178f54
Signed-off-by: Haibin Liu <haibinl@codeaurora.org>
CVE-2017-9702
Signed-off-by: Kevin F. Haggerty <haggertk@lineageos.org>
---
 drivers/media/platform/msm/camera_ll/msm.c    |  5 +++++
 .../camera_ll/sensor/io/msm_camera_cci_i2c.c  |  5 +++--
 .../msm/camera_ll/sensor/msm_sensor_driver.c  | 20 +++++++++++--------
 drivers/media/platform/msm/camera_v2/msm.c    |  5 +++++
 .../camera_v2/sensor/io/msm_camera_cci_i2c.c  |  5 +++--
 .../msm/camera_v2/sensor/msm_sensor_driver.c  | 20 +++++++++++--------
 6 files changed, 40 insertions(+), 20 deletions(-)

diff --git a/drivers/media/platform/msm/camera_ll/msm.c b/drivers/media/platform/msm/camera_ll/msm.c
index ef1a72a46ae..42b66e826e9 100644
--- a/drivers/media/platform/msm/camera_ll/msm.c
+++ b/drivers/media/platform/msm/camera_ll/msm.c
@@ -314,6 +314,11 @@ static void msm_add_sd_in_position(struct msm_sd_subdev *msm_subdev,
 	struct msm_sd_subdev *temp_sd;
 
 	list_for_each_entry(temp_sd, sd_list, list) {
+		if (temp_sd == msm_subdev) {
+			pr_err("%s :Fail to add the same sd %d\n",
+				__func__, __LINE__);
+			return;
+		}
 		if (msm_subdev->close_seq < temp_sd->close_seq) {
 			list_add_tail(&msm_subdev->list, &temp_sd->list);
 			return;
diff --git a/drivers/media/platform/msm/camera_ll/sensor/io/msm_camera_cci_i2c.c b/drivers/media/platform/msm/camera_ll/sensor/io/msm_camera_cci_i2c.c
index 089de22031e..4f5a19e2b81 100644
--- a/drivers/media/platform/msm/camera_ll/sensor/io/msm_camera_cci_i2c.c
+++ b/drivers/media/platform/msm/camera_ll/sensor/io/msm_camera_cci_i2c.c
@@ -22,7 +22,8 @@
 #define CDBG(fmt, args...) do { } while (0)
 #define S_I2C_DBG(fmt, args...) do { } while (0)
 #endif
-
+#define MAX_I2C_ADDR_TYPE_SIZE (MSM_CAMERA_I2C_3B_ADDR + 1)
+#define MAX_I2C_DATA_TYPE_SIZE (MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA + 1)
 #define I2C_COMPARE_MATCH 0
 #define I2C_COMPARE_MISMATCH 1
 #define I2C_POLL_MAX_ITERATION 20
@@ -32,7 +33,7 @@ int32_t msm_camera_cci_i2c_read(struct msm_camera_i2c_client *client,
 	enum msm_camera_i2c_data_type data_type)
 {
 	int32_t rc = -EFAULT;
-	unsigned char buf[client->addr_type+data_type];
+	unsigned char buf[MAX_I2C_ADDR_TYPE_SIZE + MAX_I2C_DATA_TYPE_SIZE];
 	struct msm_camera_cci_ctrl cci_ctrl;
 
 	if ((client->addr_type != MSM_CAMERA_I2C_BYTE_ADDR
diff --git a/drivers/media/platform/msm/camera_ll/sensor/msm_sensor_driver.c b/drivers/media/platform/msm/camera_ll/sensor/msm_sensor_driver.c
index 8614f4fd0e9..6544510f238 100644
--- a/drivers/media/platform/msm/camera_ll/sensor/msm_sensor_driver.c
+++ b/drivers/media/platform/msm/camera_ll/sensor/msm_sensor_driver.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2015,2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -287,12 +287,6 @@ int32_t msm_sensor_driver_probe(void *setting)
     /* Update sensor name in sensor control structure */
     s_ctrl->sensordata->sensor_name = slave_info->sensor_name;
 
-    /*
-      Set probe succeeded flag to 1 so that no other camera shall
-      * probed on this slot
-      */
-    s_ctrl->is_probe_succeed = 1;
-
     /*
      * Create /dev/videoX node, comment for now until dummy /dev/videoX
      * node is created and used by HAL
@@ -318,7 +312,11 @@ int32_t msm_sensor_driver_probe(void *setting)
     s_ctrl->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_SENSOR;
     s_ctrl->msm_sd.sd.entity.name = s_ctrl->msm_sd.sd.name;
     s_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x3;
-    msm_sd_register(&s_ctrl->msm_sd);
+    rc = msm_sd_register(&s_ctrl->msm_sd);
+    if (rc < 0) {
+        pr_err("failed: msm_sd_register rc %d", rc);
+        return rc;
+    }
 
     memcpy(slave_info->subdev_name, s_ctrl->msm_sd.sd.entity.name,
            sizeof(slave_info->subdev_name));
@@ -363,6 +361,12 @@ int32_t msm_sensor_driver_probe(void *setting)
                                         s_ctrl->sensor_i2c_client);
 #endif
 
+
+    /*
+      Set probe succeeded flag to 1 so that no other camera shall
+      * probed on this slot
+      */
+    s_ctrl->is_probe_succeed = 1;
     return rc;
 
 FREE_POWER_OFF_SETTING:
diff --git a/drivers/media/platform/msm/camera_v2/msm.c b/drivers/media/platform/msm/camera_v2/msm.c
index 0ac553c66df..6e2a60a8122 100644
--- a/drivers/media/platform/msm/camera_v2/msm.c
+++ b/drivers/media/platform/msm/camera_v2/msm.c
@@ -321,6 +321,11 @@ static void msm_add_sd_in_position(struct msm_sd_subdev *msm_subdev,
 	struct msm_sd_subdev *temp_sd;
 
 	list_for_each_entry(temp_sd, sd_list, list) {
+		if (temp_sd == msm_subdev) {
+			pr_err("%s :Fail to add the same sd %d\n",
+				__func__, __LINE__);
+			return;
+		}
 		if (msm_subdev->close_seq < temp_sd->close_seq) {
 			list_add_tail(&msm_subdev->list, &temp_sd->list);
 			return;
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c
index ee0e7330f8a..b19d3e1c486 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c
@@ -22,7 +22,8 @@
 #define CDBG(fmt, args ...) do { } while (0)
 #define S_I2C_DBG(fmt, args ...) do { } while (0)
 #endif
-
+#define MAX_I2C_ADDR_TYPE_SIZE (MSM_CAMERA_I2C_3B_ADDR + 1)
+#define MAX_I2C_DATA_TYPE_SIZE (MSM_CAMERA_I2C_SET_BYTE_WRITE_MASK_DATA + 1)
 #define I2C_COMPARE_MATCH 0
 #define I2C_COMPARE_MISMATCH 1
 #define I2C_POLL_MAX_ITERATION 20
@@ -48,7 +49,7 @@ int32_t msm_camera_cci_i2c_read(struct msm_camera_i2c_client *client,
 		return rc;
 	}
 
-	buf = kzalloc(client->addr_type+data_type, GFP_KERNEL);
+	buf = kzalloc(MAX_I2C_ADDR_TYPE_SIZE + MAX_I2C_DATA_TYPE_SIZE, GFP_KERNEL);
 	if (!buf) {
 		pr_err("%s:%d no memory\n", __func__, __LINE__);
 		return -ENOMEM;
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
index 7716b149927..dcbe5d9c6cf 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2015,2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -279,12 +279,6 @@ int32_t msm_sensor_driver_probe(void *setting)
 	/* Update sensor name in sensor control structure */
 	s_ctrl->sensordata->sensor_name = slave_info->sensor_name;
 
-	/*
-	   Set probe succeeded flag to 1 so that no other camera shall
-	 * probed on this slot
-	 */
-	s_ctrl->is_probe_succeed = 1;
-
 	/*
 	 * Create /dev/videoX node, comment for now until dummy /dev/videoX
 	 * node is created and used by HAL
@@ -310,7 +304,11 @@ int32_t msm_sensor_driver_probe(void *setting)
 	s_ctrl->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_SENSOR;
 	s_ctrl->msm_sd.sd.entity.name = s_ctrl->msm_sd.sd.name;
 	s_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x3;
-	msm_sd_register(&s_ctrl->msm_sd);
+	rc = msm_sd_register(&s_ctrl->msm_sd);
+	if (rc < 0) {
+		pr_err("failed: msm_sd_register rc %d", rc);
+		return rc;
+	}
 
 	memcpy(slave_info->subdev_name, s_ctrl->msm_sd.sd.entity.name,
 	       sizeof(slave_info->subdev_name));
@@ -367,6 +365,12 @@ int32_t msm_sensor_driver_probe(void *setting)
 	gpio_set_value_cansleep(
 		power_info->gpio_conf->gpio_num_info->gpio_num
 		[SENSOR_GPIO_COMP], GPIOF_OUT_INIT_LOW);
+
+	/*
+	   Set probe succeeded flag to 1 so that no other camera shall
+	 * probed on this slot
+	 */
+	s_ctrl->is_probe_succeed = 1;
 	return rc;
 
  FREE_POWER_OFF_SETTING:
