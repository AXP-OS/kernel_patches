From c07af6ed22ed8b930422268501366816559af650 Mon Sep 17 00:00:00 2001
From: Jilai Wang <jilaiw@codeaurora.org>
Date: Tue, 16 Jul 2019 15:53:53 -0400
Subject: msm: npu: Use mutex to protect map/unmap to avoid race condition

If multiple processes call map/unmap funciton concurrently, it's
possible to cause data structure corruption while both of them
accesses the same buffer at the same time. This change is to use
mutex to avoid this problem.

Change-Id: I3aeab502566c4105695a5d14736c9bea73d060e5
Signed-off-by: Jilai Wang <jilaiw@codeaurora.org>
---
 drivers/media/platform/msm/npu/npu_mgr.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/drivers/media/platform/msm/npu/npu_mgr.c b/drivers/media/platform/msm/npu/npu_mgr.c
index afa4ae7..ef19506 100644
--- a/drivers/media/platform/msm/npu/npu_mgr.c
+++ b/drivers/media/platform/msm/npu/npu_mgr.c
@@ -1002,8 +1002,16 @@ int32_t npu_host_get_info(struct npu_device *npu_dev,
 int32_t npu_host_map_buf(struct npu_client *client,
 			struct msm_npu_map_buf_ioctl *map_ioctl)
 {
-	return npu_mem_map(client, map_ioctl->buf_ion_hdl, map_ioctl->size,
+	struct npu_device *npu_dev = client->npu_dev;
+	struct npu_host_ctx *host_ctx = &npu_dev->host_ctx;
+	int ret;
+
+	mutex_lock(&host_ctx->lock);
+	ret = npu_mem_map(client, map_ioctl->buf_ion_hdl, map_ioctl->size,
 		&map_ioctl->npu_phys_addr);
+	mutex_unlock(&host_ctx->lock);
+
+	return ret;
 }
 
 int32_t npu_host_unmap_buf(struct npu_client *client,
@@ -1021,8 +1029,10 @@ int32_t npu_host_unmap_buf(struct npu_client *client,
 		&host_ctx->fw_deinit_done, NW_CMD_TIMEOUT))
 		pr_warn("npu: wait for fw_deinit_done time out\n");
 
+	mutex_lock(&host_ctx->lock);
 	npu_mem_unmap(client, unmap_ioctl->buf_ion_hdl,
 		unmap_ioctl->npu_phys_addr);
+	mutex_unlock(&host_ctx->lock);
 	return 0;
 }
 
-- 
cgit v1.1

