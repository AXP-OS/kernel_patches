From 931aa630b763dbb39bc7a35bc7a086b0d5f2a41e Mon Sep 17 00:00:00 2001
From: Karthik Anantha Ram <kartanan@codeaurora.org>
Date: Tue, 11 Dec 2018 10:37:52 -0800
Subject: msm: camera: reqmgr: Hold device lock while retrieving session info

There is a possibility for destroy session and link to occur
concurrently, if this does we end up using a freed pointer while
linking. Avoid this by increasing the scope of the device lock.

Change-Id: I6ffb2d0633455a838cca9194e4717d82a9647183
Signed-off-by: Karthik Anantha Ram <kartanan@codeaurora.org>
---
 drivers/media/platform/msm/camera/cam_req_mgr/cam_req_mgr_core.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/drivers/media/platform/msm/camera/cam_req_mgr/cam_req_mgr_core.c b/drivers/media/platform/msm/camera/cam_req_mgr/cam_req_mgr_core.c
index 4c4afc1..1295e29 100644
--- a/drivers/media/platform/msm/camera/cam_req_mgr/cam_req_mgr_core.c
+++ b/drivers/media/platform/msm/camera/cam_req_mgr/cam_req_mgr_core.c
@@ -2432,16 +2432,17 @@ int cam_req_mgr_link(struct cam_req_mgr_link_info *link_info)
 		return -EINVAL;
 	}
 
+	mutex_lock(&g_crm_core_dev->crm_lock);
+
 	/* session hdl's priv data is cam session struct */
 	cam_session = (struct cam_req_mgr_core_session *)
 		cam_get_device_priv(link_info->session_hdl);
 	if (!cam_session) {
 		CAM_DBG(CAM_CRM, "NULL pointer");
+		mutex_unlock(&g_crm_core_dev->crm_lock);
 		return -EINVAL;
 	}
 
-	mutex_lock(&g_crm_core_dev->crm_lock);
-
 	/* Allocate link struct and map it with session's request queue */
 	link = __cam_req_mgr_reserve_link(cam_session);
 	if (!link) {
-- 
cgit v1.1

