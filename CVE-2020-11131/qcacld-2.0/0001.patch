From b5549a556a9ce60b514ea20dc62f9499a97857a2 Mon Sep 17 00:00:00 2001
From: Paul Zhang <paulz@codeaurora.org>
Date: Tue, 8 Oct 2019 15:47:49 +0800
Subject: qcacld-2.0: Using size_t to avoid OOB

An out-of-bound write can be triggered by a specially-crafted
command supplied by a userspace application via the NL80211
(Netlink) interface in function wma_apfind_set_cmd if
apfind_req->request_data_len is a large value that's close to
the limit of uint16_t (such as 0xffff).

Change-Id: Iea43469cc78bebe3f8603ac14ff8253687307beb
CRs-Fixed: 2539113
---
 CORE/SERVICES/WMA/wma.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/CORE/SERVICES/WMA/wma.c b/CORE/SERVICES/WMA/wma.c
index 9c8084c..19d18e4 100644
--- a/CORE/SERVICES/WMA/wma.c
+++ b/CORE/SERVICES/WMA/wma.c
@@ -27691,8 +27691,8 @@ static VOS_STATUS wma_apfind_set_cmd(void *wda_handle,
 	tp_wma_handle wma_handle = (tp_wma_handle)wda_handle;
 	wmi_apfind_cmd_param *cmd;
 	wmi_buf_t buf;
-	u_int16_t len = sizeof(*cmd);
-	u_int16_t apfind_data_len, apfind_data_len_aligned;
+	size_t len = sizeof(*cmd);
+	size_t apfind_data_len, apfind_data_len_aligned;
 	u_int8_t *buf_ptr;
 
 	if (!apfind_req) {
-- 
cgit v1.1

