From 1afe9f760cd54ebba2fd7fc7e8f31db502348ce6 Mon Sep 17 00:00:00 2001
From: Terence Ho <terenceh@codeaurora.org>
Date: Thu, 13 Aug 2020 16:45:50 -0400
Subject: msm: ais: restrict cci user interface to VIDEOC_CAM_CONTROL

Restrict cci user interface to VIDEOC_CAM_CONTROL.
Kernel clients would access via functions directly.

Acked-by: Abderahmane Allalou <aallalou@qti.qualcomm.com>.

Change-Id: I607d4a78ad453f4191745d88e942f84bc2488d2c
Signed-off-by: Terence Ho <terenceh@codeaurora.org>
---
 .../ais/cam_sensor_module/cam_cci/cam_cci_core.c   | 19 +++++++----
 .../ais/cam_sensor_module/cam_cci/cam_cci_dev.c    |  3 --
 .../ais/cam_sensor_module/cam_cci/cam_cci_dev.h    |  2 --
 .../cam_sensor_io/cam_sensor_cci_i2c.c             | 38 ++++++++++++----------
 4 files changed, 33 insertions(+), 29 deletions(-)

diff --git a/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_core.c b/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_core.c
index f30c9e4..8bcdc95 100644
--- a/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_core.c
+++ b/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_core.c
@@ -2013,7 +2013,14 @@ int32_t cam_cci_core_cfg(struct v4l2_subdev *sd,
 	struct cam_cci_ctrl *cci_ctrl)
 {
 	int32_t rc = 0;
-	struct cci_device *cci_dev = v4l2_get_subdevdata(sd);
+	struct cci_device *cci_dev;
+
+	if (sd == NULL || cci_ctrl == NULL) {
+		CAM_ERR(CAM_CCI, "cci_ctrl or sd null");
+		rc = -ENODEV;
+		return rc;
+	}
+	cci_dev = v4l2_get_subdevdata(sd);
 
 	CAM_DBG(CAM_CCI, "cmd %d", cci_ctrl->cmd);
 
@@ -2071,12 +2078,10 @@ int32_t cam_cci_core_cam_ctrl(struct v4l2_subdev *sd,
 
 	CAM_DBG(CAM_CCI, "cmd %d", cmd->op_code);
 
-	if (cmd->op_code != AIS_SENSOR_I2C_POWER_DOWN) {
-		if (cmd->handle_type != CAM_HANDLE_USER_POINTER) {
-			CAM_ERR(CAM_CCI, "Invalid handle type: %d",
+	if (cmd->handle_type != CAM_HANDLE_USER_POINTER) {
+		CAM_ERR(CAM_CCI, "Invalid handle type: %d",
 				cmd->handle_type);
-			return -EINVAL;
-		}
+		return -EINVAL;
 	}
 
 	cci_ctrl.cci_info = kzalloc(sizeof(struct cam_sensor_cci_client),
@@ -2090,7 +2095,7 @@ int32_t cam_cci_core_cam_ctrl(struct v4l2_subdev *sd,
 
 		sensor_cap.slot_info = cci_dev->soc_info.index;
 		if (copy_to_user(u64_to_user_ptr(cmd->handle),
-			&sensor_cap, sizeof(struct  cam_sensor_query_cap))) {
+			&sensor_cap, sizeof(sensor_cap))) {
 			CAM_ERR(CAM_CCI, "Failed Copy to User");
 			rc = -EFAULT;
 		}
diff --git a/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_dev.c b/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_dev.c
index 4a6edef2..6f6b7b2 100644
--- a/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_dev.c
+++ b/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_dev.c
@@ -37,9 +37,6 @@ static long cam_cci_subdev_ioctl(struct v4l2_subdev *sd,
 	}
 
 	switch (cmd) {
-	case VIDIOC_MSM_CCI_CFG:
-		rc = cam_cci_core_cfg(sd, arg);
-		break;
 	case VIDIOC_CAM_CONTROL:
 		rc = cam_cci_core_cam_ctrl(sd, arg);
 		break;
diff --git a/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_dev.h b/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_dev.h
index 1c21e03..3e410b30 100644
--- a/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_dev.h
+++ b/drivers/media/platform/msm/ais/cam_sensor_module/cam_cci/cam_cci_dev.h
@@ -324,7 +324,5 @@ static inline struct v4l2_subdev *cam_cci_get_subdev(int cci_dev_index)
 }
 #endif
 
-#define VIDIOC_MSM_CCI_CFG \
-	_IOWR('V', BASE_VIDIOC_PRIVATE + 23, struct cam_cci_ctrl *)
 
 #endif /* _CAM_CCI_DEV_H_ */
diff --git a/drivers/media/platform/msm/ais/cam_sensor_module/cam_sensor_io/cam_sensor_cci_i2c.c b/drivers/media/platform/msm/ais/cam_sensor_module/cam_sensor_io/cam_sensor_cci_i2c.c
index 16edb38..0078142e 100644
--- a/drivers/media/platform/msm/ais/cam_sensor_module/cam_sensor_io/cam_sensor_cci_i2c.c
+++ b/drivers/media/platform/msm/ais/cam_sensor_module/cam_sensor_io/cam_sensor_cci_i2c.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2017-2018,2020 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -12,7 +12,7 @@
 
 #include "cam_sensor_cmn_header.h"
 #include "cam_sensor_i2c.h"
-#include "cam_cci_dev.h"
+#include "cam_cci_core.h"
 
 int32_t cam_cci_i2c_read(struct cam_sensor_cci_client *cci_client,
 	uint32_t addr, uint32_t *data,
@@ -36,8 +36,8 @@ int32_t cam_cci_i2c_read(struct cam_sensor_cci_client *cci_client,
 	cci_ctrl.cfg.cci_i2c_read_cfg.data_type = data_type;
 	cci_ctrl.cfg.cci_i2c_read_cfg.data = buf;
 	cci_ctrl.cfg.cci_i2c_read_cfg.num_byte = data_type;
-	rc = v4l2_subdev_call(cci_client->cci_subdev,
-		core, ioctl, VIDIOC_MSM_CCI_CFG, &cci_ctrl);
+
+	rc = cam_cci_core_cfg(cci_client->cci_subdev, &cci_ctrl);
 	if (rc < 0) {
 		CAM_ERR(CAM_SENSOR, "rc = %d", rc);
 		return rc;
@@ -88,14 +88,18 @@ int32_t cam_camera_cci_i2c_read_seq(struct cam_sensor_cci_client *cci_client,
 	cci_ctrl.cfg.cci_i2c_read_cfg.data = buf;
 	cci_ctrl.cfg.cci_i2c_read_cfg.num_byte = num_byte;
 	cci_ctrl.status = -EFAULT;
-	rc = v4l2_subdev_call(cci_client->cci_subdev,
-		core, ioctl, VIDIOC_MSM_CCI_CFG, &cci_ctrl);
-	rc = cci_ctrl.status;
+
+	rc = cam_cci_core_cfg(cci_client->cci_subdev, &cci_ctrl);
 	CAM_DBG(CAM_SENSOR, "addr = 0x%x, rc = %d", addr, rc);
-	for (i = 0; i < num_byte; i++) {
-		data[i] = buf[i];
-		CAM_DBG(CAM_SENSOR, "Byte %d: Data: 0x%x\n", i, data[i]);
+
+	if (!rc) {
+		for (i = 0; i < num_byte; i++) {
+			data[i] = buf[i];
+			CAM_DBG(CAM_SENSOR, "Byte %d: Data: 0x%x",
+				i, data[i]);
+		}
 	}
+
 	kfree(buf);
 	return rc;
 }
@@ -124,13 +128,13 @@ static int32_t cam_cci_i2c_write_table_cmd(
 	cci_ctrl.cfg.cci_i2c_write_cfg.data_type = write_setting->data_type;
 	cci_ctrl.cfg.cci_i2c_write_cfg.addr_type = write_setting->addr_type;
 	cci_ctrl.cfg.cci_i2c_write_cfg.size = write_setting->size;
-	rc = v4l2_subdev_call(cci_client->cci_subdev,
-		core, ioctl, VIDIOC_MSM_CCI_CFG, &cci_ctrl);
+
+	rc = cam_cci_core_cfg(cci_client->cci_subdev, &cci_ctrl);
 	if (rc < 0) {
 		CAM_ERR(CAM_SENSOR, "Failed rc = %d", rc);
 		return rc;
 	}
-	rc = cci_ctrl.status;
+
 	if (write_setting->delay > 20)
 		msleep(write_setting->delay);
 	else if (write_setting->delay)
@@ -229,11 +233,11 @@ int32_t cam_sensor_cci_i2c_util(struct cam_sensor_cci_client *cci_client,
 
 	cci_ctrl.cmd = cci_cmd;
 	cci_ctrl.cci_info = cci_client;
-	rc = v4l2_subdev_call(cci_client->cci_subdev,
-		core, ioctl, VIDIOC_MSM_CCI_CFG, &cci_ctrl);
+
+	rc = cam_cci_core_cfg(cci_client->cci_subdev, &cci_ctrl);
 	if (rc < 0) {
 		CAM_ERR(CAM_SENSOR, "Failed rc = %d", rc);
-		return rc;
 	}
-	return cci_ctrl.status;
+
+	return rc;
 }
-- 
cgit v1.1

