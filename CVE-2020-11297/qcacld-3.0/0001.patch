From 2a10c7aa8cdd3277e35176207c44ade90a567e73 Mon Sep 17 00:00:00 2001
From: sheenam monga <shebala@codeaurora.org>
Date: Wed, 18 Dec 2019 12:29:28 +0530
Subject: qcacld-3.0: Drop Excessive Disassoc frames

Currently, In function lim_is_pkt_candidate_for_drop
to drop excessive management frames subType should be
SIR_MAC_MGMT_ASSOC_REQ, SIR_MAC_MGMT_DISASSOC and
SIR_MAC_MGMT_DEAUTH. As subType can not be equal to
3 management subtypes at same time,excessive frames for Assoc,
Disassoc and Deauth will never drop.

To drop excessive frames keep a check of OR instead of AND for
ASSOC, DISASSOC AND DEAUTH subTypes. Send diag event after all
duplicate checks in lim_process_disassoc_frame and
lim_process_deauth_frame.

Change-Id: I595378d409804d3fbd9c5d22a37090d6dc429075
CRs-Fixed: 2588832
---
 core/mac/src/pe/lim/lim_api.c                    |  8 ++++----
 core/mac/src/pe/lim/lim_process_deauth_frame.c   | 19 +++++++++----------
 core/mac/src/pe/lim/lim_process_disassoc_frame.c | 18 +++++++++---------
 3 files changed, 22 insertions(+), 23 deletions(-)

diff --git a/core/mac/src/pe/lim/lim_api.c b/core/mac/src/pe/lim/lim_api.c
index 2ced252..1ad5ac5 100644
--- a/core/mac/src/pe/lim/lim_api.c
+++ b/core/mac/src/pe/lim/lim_api.c
@@ -2645,8 +2645,8 @@ tMgmtFrmDropReason lim_is_pkt_candidate_for_drop(struct mac_context *mac,
 				  curr_seq_num);
 			return eMGMT_DROP_DUPLICATE_AUTH_FRAME;
 		}
-	} else if ((subType == SIR_MAC_MGMT_ASSOC_REQ) &&
-		   (subType == SIR_MAC_MGMT_DISASSOC) &&
+	} else if ((subType == SIR_MAC_MGMT_ASSOC_REQ) ||
+		   (subType == SIR_MAC_MGMT_DISASSOC) ||
 		   (subType == SIR_MAC_MGMT_DEAUTH)) {
 		uint16_t assoc_id;
 		struct dph_hash_table *dph_table;
@@ -2657,7 +2657,7 @@ tMgmtFrmDropReason lim_is_pkt_candidate_for_drop(struct mac_context *mac,
 		pe_session = pe_find_session_by_bssid(mac, pHdr->bssId,
 				&sessionId);
 		if (!pe_session)
-			return eMGMT_DROP_NO_DROP;
+			return eMGMT_DROP_SPURIOUS_FRAME;
 		dph_table = &pe_session->dph.dphHashTable;
 		sta_ds = dph_lookup_hash_entry(mac, pHdr->sa, &assoc_id,
 					       dph_table);
@@ -2665,7 +2665,7 @@ tMgmtFrmDropReason lim_is_pkt_candidate_for_drop(struct mac_context *mac,
 			if (subType == SIR_MAC_MGMT_ASSOC_REQ)
 				return eMGMT_DROP_NO_DROP;
 			else
-				return eMGMT_DROP_EXCESSIVE_MGMT_FRAME;
+				return eMGMT_DROP_SPURIOUS_FRAME;
 		}
 
 		if (subType == SIR_MAC_MGMT_ASSOC_REQ)
diff --git a/core/mac/src/pe/lim/lim_process_deauth_frame.c b/core/mac/src/pe/lim/lim_process_deauth_frame.c
index b35b65b..ebe7154 100644
--- a/core/mac/src/pe/lim/lim_process_deauth_frame.c
+++ b/core/mac/src/pe/lim/lim_process_deauth_frame.c
@@ -157,16 +157,6 @@ lim_process_deauth_frame(struct mac_context *mac, uint8_t *pRxPacketInfo,
 			reasonCode, lim_dot11_reason_str(reasonCode),
 			QDF_MAC_ADDR_ARRAY(pHdr->sa));
 
-	if (mac->mlme_cfg->gen.fatal_event_trigger &&
-	    (reasonCode != eSIR_MAC_UNSPEC_FAILURE_REASON &&
-	    reasonCode != eSIR_MAC_DEAUTH_LEAVING_BSS_REASON &&
-	    reasonCode != eSIR_MAC_DISASSOC_LEAVING_BSS_REASON)) {
-		cds_flush_logs(WLAN_LOG_TYPE_FATAL,
-			       WLAN_LOG_INDICATOR_HOST_DRIVER,
-			       WLAN_LOG_REASON_DISCONNECT,
-			       true, false);
-	}
-
 	lim_diag_event_report(mac, WLAN_PE_DIAG_DEAUTH_FRAME_EVENT,
 		pe_session, 0, reasonCode);
 
@@ -319,6 +309,15 @@ lim_process_deauth_frame(struct mac_context *mac, uint8_t *pRxPacketInfo,
 	lim_perform_deauth(mac, pe_session, reasonCode, pHdr->sa,
 			   frame_rssi);
 
+	if (mac->mlme_cfg->gen.fatal_event_trigger &&
+	    (reasonCode != eSIR_MAC_UNSPEC_FAILURE_REASON &&
+	    reasonCode != eSIR_MAC_DEAUTH_LEAVING_BSS_REASON &&
+	    reasonCode != eSIR_MAC_DISASSOC_LEAVING_BSS_REASON)) {
+		cds_flush_logs(WLAN_LOG_TYPE_FATAL,
+			       WLAN_LOG_INDICATOR_HOST_DRIVER,
+			       WLAN_LOG_REASON_DISCONNECT,
+			       true, false);
+	}
 
 } /*** end lim_process_deauth_frame() ***/
 
diff --git a/core/mac/src/pe/lim/lim_process_disassoc_frame.c b/core/mac/src/pe/lim/lim_process_disassoc_frame.c
index 6a190fe..27e6a7e 100644
--- a/core/mac/src/pe/lim/lim_process_disassoc_frame.c
+++ b/core/mac/src/pe/lim/lim_process_disassoc_frame.c
@@ -156,15 +156,6 @@ lim_process_disassoc_frame(struct mac_context *mac, uint8_t *pRxPacketInfo,
 	lim_diag_event_report(mac, WLAN_PE_DIAG_DISASSOC_FRAME_EVENT,
 		pe_session, 0, reasonCode);
 
-	if (mac->mlme_cfg->gen.fatal_event_trigger &&
-	    (reasonCode != eSIR_MAC_UNSPEC_FAILURE_REASON &&
-	    reasonCode != eSIR_MAC_DEAUTH_LEAVING_BSS_REASON &&
-	    reasonCode != eSIR_MAC_DISASSOC_LEAVING_BSS_REASON)) {
-		cds_flush_logs(WLAN_LOG_TYPE_FATAL,
-			       WLAN_LOG_INDICATOR_HOST_DRIVER,
-			       WLAN_LOG_REASON_DISCONNECT,
-			       true, false);
-	}
 	/**
 	 * Extract 'associated' context for STA, if any.
 	 * This is maintained by DPH and created by LIM.
@@ -315,6 +306,15 @@ lim_process_disassoc_frame(struct mac_context *mac, uint8_t *pRxPacketInfo,
 	lim_perform_disassoc(mac, frame_rssi, reasonCode,
 			     pe_session, pHdr->sa);
 
+	if (mac->mlme_cfg->gen.fatal_event_trigger &&
+	    (reasonCode != eSIR_MAC_UNSPEC_FAILURE_REASON &&
+	    reasonCode != eSIR_MAC_DEAUTH_LEAVING_BSS_REASON &&
+	    reasonCode != eSIR_MAC_DISASSOC_LEAVING_BSS_REASON)) {
+		cds_flush_logs(WLAN_LOG_TYPE_FATAL,
+			       WLAN_LOG_INDICATOR_HOST_DRIVER,
+			       WLAN_LOG_REASON_DISCONNECT,
+			       true, false);
+	}
 } /*** end lim_process_disassoc_frame() ***/
 
 #ifdef FEATURE_WLAN_TDLS
-- 
cgit v1.1

