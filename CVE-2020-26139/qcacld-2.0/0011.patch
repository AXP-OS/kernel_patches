From 09d426ddfd015b2fe02000bc55abb1f6c6952980 Mon Sep 17 00:00:00 2001
From: Tiger Yu <tfyu@codeaurora.org>
Date: Fri, 5 Mar 2021 11:16:51 +0800
Subject: qcacld-2.0: Add eapol sanity checking for intra-bss forwarding &
 indicate

Dropping all eapol frames during intra-bss forwarding. And add eapol
sanity checking when indicate the RX pakcets to the up layer.

Change-Id: I7384cb7ae8a6806df7cfe2e25e62d2fa884b2f65
CRs-Fixed: 2868053
---
 CORE/CLD_TXRX/TXRX/ol_rx_fwd.c                | 54 ++++++++++++++++++++-------
 CORE/HDD/inc/wlan_hdd_cfg.h                   | 15 +++++++-
 CORE/HDD/src/wlan_hdd_cfg.c                   |  9 ++++-
 CORE/HDD/src/wlan_hdd_softap_tx_rx.c          | 34 ++++++++++++++++-
 CORE/SERVICES/COMMON/adf/adf_nbuf.c           | 25 +++++++++++++
 CORE/SERVICES/COMMON/adf/adf_nbuf.h           | 19 ++++++++++
 CORE/SERVICES/COMMON/adf/linux/adf_nbuf_pvt.h |  1 +
 7 files changed, 141 insertions(+), 16 deletions(-)

diff --git a/CORE/CLD_TXRX/TXRX/ol_rx_fwd.c b/CORE/CLD_TXRX/TXRX/ol_rx_fwd.c
index 7a71fe0..ea9cc2a 100644
--- a/CORE/CLD_TXRX/TXRX/ol_rx_fwd.c
+++ b/CORE/CLD_TXRX/TXRX/ol_rx_fwd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011, 2014, 2021 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -212,19 +212,47 @@ ol_rx_fwd_check(
              * This MSDU needs to be forwarded to the tx path.
              * Check whether it also needs to be sent to the OS shim,
              * in which case we need to make a copy (or clone?).
-             */
-            if (htt_rx_msdu_discard(pdev->htt_pdev, rx_desc)) {
-                htt_rx_msdu_desc_free(pdev->htt_pdev, msdu);
-                ol_rx_fwd_to_tx(tx_vdev, msdu);
-                msdu = NULL; /* already handled this MSDU */
-            } else {
-				adf_nbuf_t copy;
-				copy = adf_nbuf_copy(msdu);
-                if (copy) {
-					ol_rx_fwd_to_tx(tx_vdev, copy);
+	     */
+	    {
+		u_int16_t off = 0;
+		// for HL, point to payload right now
+		if (pdev->cfg.is_high_latency) {
+			off = htt_rx_msdu_rx_desc_size_hl(pdev->htt_pdev,
+							  rx_desc);
+		}
+                /*
+                 * CR 2868053
+                 * discard EAPOL frame for intrabss forwarding
+                 */
+                if ((vdev->opmode == wlan_op_mode_ap) &&
+                    __adf_nbuf_data_is_eapol_pkt(adf_nbuf_data(msdu) + off)) {
+                    VOS_TRACE(VOS_MODULE_ID_TXRX, VOS_TRACE_LEVEL_ERROR,
+                        "\n%s:QSV2020005 EAPOL forwarding discard \n",
+                        __FUNCTION__);
+                    /* Drop the packet*/
+                    htt_rx_msdu_desc_free(pdev->htt_pdev, msdu);
+                    TXRX_STATS_MSDU_LIST_INCR(
+                        pdev, tx.dropped.host_reject, msdu);
+                    /* add NULL terminator */
+                    adf_nbuf_set_next(msdu, NULL);
+                    adf_nbuf_tx_free(msdu, ADF_NBUF_PKT_ERROR);
+                    msdu = msdu_list;
+                    continue;
                 }
-            }
-        }
+	     }
+
+             if (htt_rx_msdu_discard(pdev->htt_pdev, rx_desc)) {
+                    htt_rx_msdu_desc_free(pdev->htt_pdev, msdu);
+                    ol_rx_fwd_to_tx(tx_vdev, msdu);
+                    msdu = NULL; /* already handled this MSDU */
+             } else {
+		    adf_nbuf_t copy;
+		    copy = adf_nbuf_copy(msdu);
+                    if (copy) {
+			ol_rx_fwd_to_tx(tx_vdev, copy);
+                    }
+             }
+	}
         if (msdu) {
             /* send this frame to the OS */
             OL_TXRX_LIST_APPEND(deliver_list_head, deliver_list_tail, msdu);
diff --git a/CORE/HDD/inc/wlan_hdd_cfg.h b/CORE/HDD/inc/wlan_hdd_cfg.h
index ae044c1..789dc2d 100644
--- a/CORE/HDD/inc/wlan_hdd_cfg.h
+++ b/CORE/HDD/inc/wlan_hdd_cfg.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2015 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2015, 2021 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -2256,6 +2256,18 @@ This feature requires the dependent cfg.ini "gRoamPrefer5GHz" set to 1 */
 #define CFG_ENABLE_DEBUG_CONNECT_ISSUE_MAX         (0xFF)
 #define CFG_ENABLE_DEBUG_CONNECT_ISSUE_DEFAULT     (0)
 
+/*
+ * Eapol sanity checking Enable/Disable for SAP.
+ * 0x0 - Enable eapol sanity checking in the RX path
+ *       before deliver to the OS in the SAP mode.
+ * 0x1 - Enable eapol sanity checking in the RX path
+ *       before deliver to the OS in the SAP mode.
+ */
+#define CFG_ENABLE_SAP_EAPOL_CHECKING             "gEnableSapEapolChecking"
+#define CFG_ENABLE_SAP_EAPOL_CHECKING_MIN         (0)
+#define CFG_ENABLE_SAP_EAPOL_CHECKING_MAX         (1)
+#define CFG_ENABLE_SAP_EAPOL_CHECKING_DEFAULT     (1)
+
 /* This will be used only for debugging purpose, will be removed after sometime */
 #define CFG_ENABLE_RX_THREAD                       "gEnableRxThread"
 #define CFG_ENABLE_RX_THREAD_MIN                   (0)
@@ -3261,6 +3273,7 @@ typedef struct hdd_config
    v_U32_t                     TxPower5g;
    v_U32_t                     gEnableDebugLog;
    v_U8_t                      enableRxThread;
+   v_U32_t                     gEnableSapEapolChecking;
    v_BOOL_t                    fDfsPhyerrFilterOffload;
    v_U8_t                      gSapPreferredChanLocation;
    v_U8_t                      gDisableDfsJapanW53;
diff --git a/CORE/HDD/src/wlan_hdd_cfg.c b/CORE/HDD/src/wlan_hdd_cfg.c
index 4d1919e..48debf6 100644
--- a/CORE/HDD/src/wlan_hdd_cfg.c
+++ b/CORE/HDD/src/wlan_hdd_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2015 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2015, 2021 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -2835,6 +2835,13 @@ REG_TABLE_ENTRY g_registry_table[] =
                  CFG_ENABLE_DEBUG_CONNECT_ISSUE_MIN ,
                  CFG_ENABLE_DEBUG_CONNECT_ISSUE_MAX),
 
+   REG_VARIABLE( CFG_ENABLE_SAP_EAPOL_CHECKING, WLAN_PARAM_Integer,
+                 hdd_config_t, gEnableSapEapolChecking,
+                 VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+                 CFG_ENABLE_SAP_EAPOL_CHECKING_DEFAULT,
+                 CFG_ENABLE_SAP_EAPOL_CHECKING_MIN ,
+                 CFG_ENABLE_SAP_EAPOL_CHECKING_MAX),
+
    REG_VARIABLE( CFG_ENABLE_RX_THREAD, WLAN_PARAM_Integer,
                  hdd_config_t, enableRxThread,
                  VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
diff --git a/CORE/HDD/src/wlan_hdd_softap_tx_rx.c b/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
index 53cf77c..5cbb622 100644
--- a/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
+++ b/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2015 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2015, 2021 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -1099,6 +1099,38 @@ VOS_STATUS hdd_softap_rx_packet_cbk(v_VOID_t *vosContext,
    }
 #endif /* QCA_PKT_PROTO_TRACE */
 
+
+   if (pHddCtx->cfg_ini->gEnableSapEapolChecking) {
+          if (adf_nbuf_is_eapol_pkt(skb)) {
+              /* CR 2868053 */
+              VOS_TRACE(VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_INFO,
+                  "%s: QSV2020005, dev, mode=%d, session=%u, %s, addr (%pM)",
+                  __FUNCTION__,
+                  pAdapter->device_mode,
+                  pAdapter->sessionId,
+                  pAdapter->dev->name,
+                  pAdapter->dev->dev_addr);
+              VOS_TRACE(VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_INFO,
+                  "%s:QSV2020005 pkt addr (%pM)",
+                  __FUNCTION__,
+                  skb->data);
+              if (adf_os_mem_cmp(pAdapter->dev->dev_addr,
+                skb->data, VOS_MAC_ADDR_SIZE)) {
+                  /* CR 2868053, discard this EAPOL */
+                  VOS_TRACE(VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_ERROR,
+                      "%s:QSV2020005 discard invalid EAPOL frame, dev=%pM, "
+                      "pkt_da=%pM",
+                      __FUNCTION__,
+                      pAdapter->dev->dev_addr,
+                      skb->data);
+
+                  adf_nbuf_free(skb);
+                  return VOS_STATUS_SUCCESS;
+              }
+          }
+   }
+
+
    VOS_TRACE( VOS_MODULE_ID_HDD_SAP_DATA, VOS_TRACE_LEVEL_INFO_LOW,
               "%s: send one packet to kernel", __func__);
 
diff --git a/CORE/SERVICES/COMMON/adf/adf_nbuf.c b/CORE/SERVICES/COMMON/adf/adf_nbuf.c
index b5a0cac..10330a9 100644
--- a/CORE/SERVICES/COMMON/adf/adf_nbuf.c
+++ b/CORE/SERVICES/COMMON/adf/adf_nbuf.c
@@ -408,6 +408,31 @@ __adf_nbuf_is_dhcp_pkt(struct sk_buff *skb)
     }
 }
 
+/**
+ * __adf_nbuf_data_is_eapol_pkt() - check if it is EAPOL packet.
+ * @data: Pointer to EAPOL packet data buffer
+ *
+ * This func. checks whether it is a EAPOL packet or not.
+ *
+ * Return: TRUE if it is a EAPOL packet
+ *         FALSE if not
+ */
+bool __adf_nbuf_data_is_eapol_pkt(uint8_t *data)
+{
+    a_uint16_t    ether_type;
+
+    ether_type = (a_uint16_t)(*(a_uint16_t *)(data +
+			ADF_NBUF_TRAC_ETH_TYPE_OFFSET));
+    if (ADF_NBUF_TRAC_EAPOL_ETH_TYPE == adf_os_cpu_to_be16(ether_type))
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
 #ifdef QCA_PKT_PROTO_TRACE
 void
 __adf_nbuf_trace_update(struct sk_buff *buf, char *event_string)
diff --git a/CORE/SERVICES/COMMON/adf/adf_nbuf.h b/CORE/SERVICES/COMMON/adf/adf_nbuf.h
index 602e7d1..206168d 100644
--- a/CORE/SERVICES/COMMON/adf/adf_nbuf.h
+++ b/CORE/SERVICES/COMMON/adf/adf_nbuf.h
@@ -53,12 +53,16 @@
 #define NBUF_PKT_TRAC_TYPE_MGMT_ACTION    0x08
 #define NBUF_PKT_TRAC_MAX_STRING   12
 #define NBUF_PKT_TRAC_PROTO_STRING 4
+#define ADF_NBUF_PKT_ERROR         1
 
 #define ADF_NBUF_TRAC_IPV4_OFFSET       14
 #define ADF_NBUF_TRAC_IPV4_HEADER_SIZE  20
 #define ADF_NBUF_TRAC_DHCP_SRV_PORT     67
 #define ADF_NBUF_TRAC_DHCP_CLI_PORT     68
 
+#define ADF_NBUF_TRAC_ETH_TYPE_OFFSET   12
+#define ADF_NBUF_TRAC_EAPOL_ETH_TYPE    0x888E
+
 /**
  * @brief Platform indepedent packet abstraction
  */
@@ -1151,4 +1155,19 @@ adf_nbuf_is_dhcp_pkt(adf_nbuf_t buf)
     return (__adf_nbuf_is_dhcp_pkt(buf));
 }
 
+/**
+ * adf_nbuf_is_eapol_pkt() - check if it is EAPOL packet.
+ * @buf: Pointer to EAPOL packet buffer
+ *
+ * This func. checks whether it is a EAPOL packet or not.
+ *
+ * Return: TRUE if it is a EAPOL packet
+ *         FALSE if not
+ */
+static inline
+bool adf_nbuf_is_eapol_pkt(adf_nbuf_t buf)
+{
+	return __adf_nbuf_data_is_eapol_pkt(adf_nbuf_data(buf));
+}
+
 #endif
diff --git a/CORE/SERVICES/COMMON/adf/linux/adf_nbuf_pvt.h b/CORE/SERVICES/COMMON/adf/linux/adf_nbuf_pvt.h
index bc51123..e046c60 100644
--- a/CORE/SERVICES/COMMON/adf/linux/adf_nbuf_pvt.h
+++ b/CORE/SERVICES/COMMON/adf/linux/adf_nbuf_pvt.h
@@ -265,6 +265,7 @@ void            __adf_nbuf_frag_info(struct sk_buff *skb, adf_os_sglist_t  *sg);
 void            __adf_nbuf_dmamap_set_cb(__adf_os_dma_map_t dmap, void *cb, void *arg);
 void            __adf_nbuf_reg_trace_cb(adf_nbuf_trace_update_t cb_func_ptr);
 a_status_t      __adf_nbuf_is_dhcp_pkt(struct sk_buff *skb);
+bool            __adf_nbuf_data_is_eapol_pkt(uint8_t *data);
 
 #ifdef QCA_PKT_PROTO_TRACE
 void
-- 
cgit v1.1

