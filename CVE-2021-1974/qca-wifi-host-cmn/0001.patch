From b4462910f414ffa2ad40e19d400e389c13ac6001 Mon Sep 17 00:00:00 2001
From: Jinwei Chen <jinweic@codeaurora.org>
Date: Mon, 20 Jul 2020 16:35:28 +0800
Subject: qcacmn: handle IPA buffer smmu map/unmap correctly

Handle ipa buffer smmu map/unmap with below changes,
(1) Do IPA smmu unmap for RX buffer received from REO
exception/WBM RX release/REO DST/RXDMA DST ring.
(2) Align IPA smmu map length to qdf_nbuf_map_nytes_single()
with fixed length.

Change-Id: I1ed46b31ed31f5b7e4e2484d519bc85d35ce1e69
CRs-Fixed: 2728644
---
 dp/wifi3.0/dp_ipa.c       | 22 ++++++++++++++++------
 dp/wifi3.0/dp_ipa.h       |  2 ++
 dp/wifi3.0/dp_rx.c        | 16 ++++++++++++++--
 dp/wifi3.0/dp_rx_defrag.c | 14 ++++++++++----
 dp/wifi3.0/dp_rx_desc.c   | 19 ++++++++++++-------
 dp/wifi3.0/dp_rx_err.c    | 28 ++++++++++++++++++++++++++--
 6 files changed, 80 insertions(+), 21 deletions(-)

diff --git a/dp/wifi3.0/dp_ipa.c b/dp/wifi3.0/dp_ipa.c
index e728334..0f48e43 100644
--- a/dp/wifi3.0/dp_ipa.c
+++ b/dp/wifi3.0/dp_ipa.c
@@ -93,13 +93,14 @@ static void dp_ipa_reo_remap_history_add(uint32_t ix0_val, uint32_t ix2_val,
 
 static QDF_STATUS __dp_ipa_handle_buf_smmu_mapping(struct dp_soc *soc,
 						   qdf_nbuf_t nbuf,
+						   uint32_t size,
 						   bool create)
 {
 	qdf_mem_info_t mem_map_table = {0};
 
 	qdf_update_mem_map_table(soc->osdev, &mem_map_table,
 				 qdf_nbuf_get_frag_paddr(nbuf, 0),
-				 skb_end_pointer(nbuf) - nbuf->data);
+				 size);
 
 	if (create)
 		qdf_ipa_wdi_create_smmu_mapping(1, &mem_map_table);
@@ -111,6 +112,7 @@ static QDF_STATUS __dp_ipa_handle_buf_smmu_mapping(struct dp_soc *soc,
 
 QDF_STATUS dp_ipa_handle_rx_buf_smmu_mapping(struct dp_soc *soc,
 					     qdf_nbuf_t nbuf,
+					     uint32_t size,
 					     bool create)
 {
 	struct dp_pdev *pdev;
@@ -129,7 +131,7 @@ QDF_STATUS dp_ipa_handle_rx_buf_smmu_mapping(struct dp_soc *soc,
 	if (!qdf_atomic_read(&soc->ipa_pipes_enabled))
 		return QDF_STATUS_SUCCESS;
 
-	return __dp_ipa_handle_buf_smmu_mapping(soc, nbuf, create);
+	return __dp_ipa_handle_buf_smmu_mapping(soc, nbuf, size, create);
 }
 
 #ifdef RX_DESC_MULTI_PAGE_ALLOC
@@ -165,7 +167,8 @@ static QDF_STATUS dp_ipa_handle_rx_buf_pool_smmu_mapping(struct dp_soc *soc,
 			continue;
 		nbuf = rx_desc->nbuf;
 
-		__dp_ipa_handle_buf_smmu_mapping(soc, nbuf, create);
+		__dp_ipa_handle_buf_smmu_mapping(soc, nbuf,
+						 rx_pool->buf_size, create);
 	}
 	qdf_spin_unlock_bh(&rx_pool->lock);
 
@@ -195,7 +198,8 @@ static QDF_STATUS dp_ipa_handle_rx_buf_pool_smmu_mapping(struct dp_soc *soc,
 
 		nbuf = rx_pool->array[i].rx_desc.nbuf;
 
-		__dp_ipa_handle_buf_smmu_mapping(soc, nbuf, create);
+		__dp_ipa_handle_buf_smmu_mapping(soc, nbuf,
+						 rx_pool->buf_size, create);
 	}
 	qdf_spin_unlock_bh(&rx_pool->lock);
 
@@ -225,7 +229,10 @@ static void dp_tx_ipa_uc_detach(struct dp_soc *soc, struct dp_pdev *pdev)
 			continue;
 
 		if (qdf_mem_smmu_s1_enabled(soc->osdev))
-			__dp_ipa_handle_buf_smmu_mapping(soc, nbuf, false);
+			__dp_ipa_handle_buf_smmu_mapping(
+					soc, nbuf,
+					skb_end_pointer(nbuf) - nbuf->data,
+					false);
 
 		qdf_nbuf_unmap_single(soc->osdev, nbuf, QDF_DMA_BIDIRECTIONAL);
 		qdf_nbuf_free(nbuf);
@@ -372,7 +379,10 @@ static int dp_tx_ipa_uc_attach(struct dp_soc *soc, struct dp_pdev *pdev)
 			= (void *)nbuf;
 
 		if (qdf_mem_smmu_s1_enabled(soc->osdev))
-			__dp_ipa_handle_buf_smmu_mapping(soc, nbuf, true);
+			__dp_ipa_handle_buf_smmu_mapping(
+					soc, nbuf,
+					skb_end_pointer(nbuf) - nbuf->data,
+					true);
 	}
 
 	hal_srng_access_end_unlocked(soc->hal_soc,
diff --git a/dp/wifi3.0/dp_ipa.h b/dp/wifi3.0/dp_ipa.h
index c933b3f..f075c3d 100644
--- a/dp/wifi3.0/dp_ipa.h
+++ b/dp/wifi3.0/dp_ipa.h
@@ -239,6 +239,7 @@ int dp_ipa_ring_resource_setup(struct dp_soc *soc,
 		struct dp_pdev *pdev);
 QDF_STATUS dp_ipa_handle_rx_buf_smmu_mapping(struct dp_soc *soc,
 					     qdf_nbuf_t nbuf,
+					     uint32_t size,
 					     bool create);
 
 bool dp_reo_remap_config(struct dp_soc *soc, uint32_t *remap1,
@@ -266,6 +267,7 @@ static inline int dp_ipa_ring_resource_setup(struct dp_soc *soc,
 
 static inline QDF_STATUS dp_ipa_handle_rx_buf_smmu_mapping(struct dp_soc *soc,
 							   qdf_nbuf_t nbuf,
+							   uint32_t size,
 							   bool create)
 {
 	return QDF_STATUS_SUCCESS;
diff --git a/dp/wifi3.0/dp_rx.c b/dp/wifi3.0/dp_rx.c
index 43fe14e..216ec80 100644
--- a/dp/wifi3.0/dp_rx.c
+++ b/dp/wifi3.0/dp_rx.c
@@ -260,7 +260,8 @@ QDF_STATUS __dp_rx_buffers_replenish(struct dp_soc *dp_soc, uint32_t mac_id,
 
 		paddr = qdf_nbuf_get_frag_paddr(rx_netbuf, 0);
 
-		dp_ipa_handle_rx_buf_smmu_mapping(dp_soc, rx_netbuf, true);
+		dp_ipa_handle_rx_buf_smmu_mapping(dp_soc, rx_netbuf,
+						  buf_size, true);
 		/*
 		 * check if the physical address of nbuf->data is
 		 * less then 0x50000000 then free the nbuf and try
@@ -2027,6 +2028,11 @@ more_data:
 		if (QDF_IS_STATUS_ERROR(status)) {
 			if (qdf_unlikely(rx_desc && rx_desc->nbuf)) {
 				qdf_assert_always(rx_desc->unmapped);
+				dp_ipa_handle_rx_buf_smmu_mapping(
+							soc,
+							rx_desc->nbuf,
+							RX_DATA_BUFFER_SIZE,
+							false);
 				qdf_nbuf_unmap_nbytes_single(
 							soc->osdev,
 							rx_desc->nbuf,
@@ -2169,6 +2175,9 @@ more_data:
 		 * in case double skb unmap happened.
 		 */
 		rx_desc_pool = &soc->rx_desc_buf[rx_desc->pool_id];
+		dp_ipa_handle_rx_buf_smmu_mapping(soc, rx_desc->nbuf,
+						  rx_desc_pool->buf_size,
+						  false);
 		qdf_nbuf_unmap_nbytes_single(soc->osdev, rx_desc->nbuf,
 					     QDF_DMA_FROM_DEVICE,
 					     rx_desc_pool->buf_size);
@@ -2735,7 +2744,10 @@ dp_pdev_rx_buffers_attach(struct dp_soc *dp_soc, uint32_t mac_id,
 						     desc_list->rx_desc.cookie,
 						     rx_desc_pool->owner);
 
-			dp_ipa_handle_rx_buf_smmu_mapping(dp_soc, nbuf, true);
+			dp_ipa_handle_rx_buf_smmu_mapping(
+						dp_soc, nbuf,
+						rx_desc_pool->buf_size,
+						true);
 
 			desc_list = next;
 		}
diff --git a/dp/wifi3.0/dp_rx_defrag.c b/dp/wifi3.0/dp_rx_defrag.c
index 40518f2..8c5cda2 100644
--- a/dp/wifi3.0/dp_rx_defrag.c
+++ b/dp/wifi3.0/dp_rx_defrag.c
@@ -1093,10 +1093,12 @@ static QDF_STATUS dp_rx_defrag_reo_reinject(struct dp_peer *peer,
 			qdf_nbuf_data(head), nbuf_len);
 
 	cookie = HAL_RX_BUF_COOKIE_GET(msdu0);
+	rx_desc_pool = &soc->rx_desc_buf[pdev->lmac_id];
 
 	/* map the nbuf before reinject it into HW */
-	ret = qdf_nbuf_map_single(soc->osdev, head,
-				  QDF_DMA_FROM_DEVICE);
+	ret = qdf_nbuf_map_nbytes_single(soc->osdev, head,
+					 QDF_DMA_FROM_DEVICE,
+					 rx_desc_pool->buf_size);
 	if (qdf_unlikely(ret == QDF_STATUS_E_FAILURE)) {
 		QDF_TRACE(QDF_MODULE_ID_DP, QDF_TRACE_LEVEL_ERROR,
 				"%s: nbuf map failed !", __func__);
@@ -1110,10 +1112,11 @@ static QDF_STATUS dp_rx_defrag_reo_reinject(struct dp_peer *peer,
 	 */
 	rx_desc->unmapped = 0;
 
-	dp_ipa_handle_rx_buf_smmu_mapping(soc, head, true);
+	dp_ipa_handle_rx_buf_smmu_mapping(soc, head,
+					  rx_desc_pool->buf_size,
+					  true);
 
 	paddr = qdf_nbuf_get_frag_paddr(head, 0);
-	rx_desc_pool = &soc->rx_desc_buf[pdev->lmac_id];
 
 	ret = check_x86_paddr(soc, &head, &paddr, rx_desc_pool);
 
@@ -1732,6 +1735,9 @@ uint32_t dp_rx_frag_handle(struct dp_soc *soc, hal_ring_desc_t ring_desc,
 	msdu = rx_desc->nbuf;
 
 	rx_desc_pool = &soc->rx_desc_buf[rx_desc->pool_id];
+	dp_ipa_handle_rx_buf_smmu_mapping(soc, rx_desc->nbuf,
+					  rx_desc_pool->buf_size,
+					  false);
 	qdf_nbuf_unmap_nbytes_single(soc->osdev, rx_desc->nbuf,
 				     QDF_DMA_FROM_DEVICE,
 				     rx_desc_pool->buf_size);
diff --git a/dp/wifi3.0/dp_rx_desc.c b/dp/wifi3.0/dp_rx_desc.c
index 32e2ddb..1f8148a 100644
--- a/dp/wifi3.0/dp_rx_desc.c
+++ b/dp/wifi3.0/dp_rx_desc.c
@@ -172,8 +172,10 @@ static QDF_STATUS __dp_rx_desc_nbuf_free(struct dp_soc *soc,
 		if (rx_desc->in_use) {
 			nbuf = rx_desc->nbuf;
 			if (!rx_desc->unmapped) {
-				dp_ipa_handle_rx_buf_smmu_mapping(soc, nbuf,
-								  false);
+				dp_ipa_handle_rx_buf_smmu_mapping(
+							soc, nbuf,
+							rx_desc_pool->buf_size,
+							false);
 				qdf_nbuf_unmap_nbytes_single(
 							soc->osdev,
 							rx_desc->nbuf,
@@ -326,8 +328,10 @@ void dp_rx_desc_nbuf_and_pool_free(struct dp_soc *soc, uint32_t pool_id,
 			nbuf = rx_desc_pool->array[i].rx_desc.nbuf;
 
 			if (!(rx_desc_pool->array[i].rx_desc.unmapped)) {
-				dp_ipa_handle_rx_buf_smmu_mapping(soc, nbuf,
-								  false);
+				dp_ipa_handle_rx_buf_smmu_mapping(
+							soc, nbuf,
+							rx_desc_pool->buf_size,
+							false);
 				qdf_nbuf_unmap_nbytes_single(
 							soc->osdev, nbuf,
 							QDF_DMA_FROM_DEVICE,
@@ -354,9 +358,10 @@ void dp_rx_desc_nbuf_free(struct dp_soc *soc,
 			nbuf = rx_desc_pool->array[i].rx_desc.nbuf;
 
 			if (!(rx_desc_pool->array[i].rx_desc.unmapped)) {
-				dp_ipa_handle_rx_buf_smmu_mapping(soc, nbuf,
-								  false);
-
+				dp_ipa_handle_rx_buf_smmu_mapping(
+						soc, nbuf,
+						rx_desc_pool->buf_size,
+						false);
 				qdf_nbuf_unmap_nbytes_single(
 							soc->osdev, nbuf,
 							QDF_DMA_FROM_DEVICE,
diff --git a/dp/wifi3.0/dp_rx_err.c b/dp/wifi3.0/dp_rx_err.c
index 04056ad..70d2736 100644
--- a/dp/wifi3.0/dp_rx_err.c
+++ b/dp/wifi3.0/dp_rx_err.c
@@ -25,6 +25,7 @@
 #include "qdf_trace.h"
 #include "qdf_nbuf.h"
 #include "dp_rx_defrag.h"
+#include "dp_ipa.h"
 #ifdef FEATURE_WDS
 #include "dp_txrx_wds.h"
 #endif
@@ -301,6 +302,9 @@ dp_rx_msdus_drop(struct dp_soc *soc, hal_ring_desc_t ring_desc,
 		}
 
 		rx_desc_pool = &soc->rx_desc_buf[rx_desc->pool_id];
+		dp_ipa_handle_rx_buf_smmu_mapping(soc, rx_desc->nbuf,
+						  rx_desc_pool->buf_size,
+						  false);
 		qdf_nbuf_unmap_nbytes_single(soc->osdev, rx_desc->nbuf,
 					     QDF_DMA_FROM_DEVICE,
 					     rx_desc_pool->buf_size);
@@ -492,6 +496,9 @@ more_msdu_link_desc:
 
 		nbuf = rx_desc->nbuf;
 		rx_desc_pool = &soc->rx_desc_buf[rx_desc->pool_id];
+		dp_ipa_handle_rx_buf_smmu_mapping(soc, nbuf,
+						  rx_desc_pool->buf_size,
+						  false);
 		qdf_nbuf_unmap_nbytes_single(soc->osdev, nbuf,
 					     QDF_DMA_FROM_DEVICE,
 					     rx_desc_pool->buf_size);
@@ -1792,6 +1799,9 @@ dp_rx_wbm_err_process(struct dp_intr *int_ctx, struct dp_soc *soc,
 
 		nbuf = rx_desc->nbuf;
 		rx_desc_pool = &soc->rx_desc_buf[rx_desc->pool_id];
+		dp_ipa_handle_rx_buf_smmu_mapping(soc, nbuf,
+						  rx_desc_pool->buf_size,
+						  false);
 		qdf_nbuf_unmap_nbytes_single(soc->osdev, nbuf,
 					     QDF_DMA_FROM_DEVICE,
 					     rx_desc_pool->buf_size);
@@ -2099,6 +2109,7 @@ dp_rx_err_mpdu_pop(struct dp_soc *soc, uint32_t mac_id,
 	struct dp_pdev *pdev = dp_get_pdev_for_lmac_id(soc, mac_id);
 	uint32_t rx_link_buf_info[HAL_RX_BUFFINFO_NUM_DWORDS];
 	hal_rxdma_desc_t ring_desc;
+	struct rx_desc_pool *rx_desc_pool;
 
 	if (!pdev) {
 		QDF_TRACE(QDF_MODULE_ID_DP, QDF_TRACE_LEVEL_DEBUG,
@@ -2169,8 +2180,17 @@ dp_rx_err_mpdu_pop(struct dp_soc *soc, uint32_t mac_id,
 						continue;
 					}
 
-					qdf_nbuf_unmap_single(soc->osdev, msdu,
-						QDF_DMA_FROM_DEVICE);
+					rx_desc_pool = &soc->
+						rx_desc_buf[rx_desc->pool_id];
+					dp_ipa_handle_rx_buf_smmu_mapping(
+							soc, msdu,
+							rx_desc_pool->buf_size,
+							false);
+					qdf_nbuf_unmap_nbytes_single(
+						soc->osdev, msdu,
+						QDF_DMA_FROM_DEVICE,
+						rx_desc_pool->buf_size);
+					rx_desc->unmapped = 1;
 
 					QDF_TRACE(QDF_MODULE_ID_DP,
 						QDF_TRACE_LEVEL_DEBUG,
@@ -2394,6 +2414,10 @@ dp_handle_wbm_internal_error(struct dp_soc *soc, void *hal_desc,
 
 		if (rx_desc && rx_desc->nbuf) {
 			rx_desc_pool = &soc->rx_desc_buf[rx_desc->pool_id];
+			dp_ipa_handle_rx_buf_smmu_mapping(
+						soc, rx_desc->nbuf,
+						rx_desc_pool->buf_size,
+						false);
 			qdf_nbuf_unmap_nbytes_single(soc->osdev, rx_desc->nbuf,
 						     QDF_DMA_FROM_DEVICE,
 						     rx_desc_pool->buf_size);
-- 
cgit v1.1

