From 82c4a394b75b4d5a6a6d0e1538a21af42a7483d9 Mon Sep 17 00:00:00 2001
From: Ke Huang <keh@codeaurora.org>
Date: Wed, 26 May 2021 17:44:56 +0800
Subject: qcacld-2.0: fix some overflow issue in wma

there are potential overflow risk in functions
wma_process_sap_auth_offload,
wmi_unified_probe_rsp_tmpl_send, and
wmi_unified_bcn_tmpl_send, so fix these potential
overflow risk in these functions.

Change-Id: I98665de677f314f30a57991f48191f847718740c
CRs-Fixed: 2938490
---
 CORE/SERVICES/WMA/wma.c | 32 +++++++++++++++++++++++++++++++-
 1 file changed, 31 insertions(+), 1 deletion(-)

diff --git a/CORE/SERVICES/WMA/wma.c b/CORE/SERVICES/WMA/wma.c
index b0ec026..11a7f54 100644
--- a/CORE/SERVICES/WMA/wma.c
+++ b/CORE/SERVICES/WMA/wma.c
@@ -20779,6 +20779,11 @@ static int wmi_unified_probe_rsp_tmpl_send(tp_wma_handle wma,
 
 	frm = probe_rsp_info->pProbeRespTemplate;
 	tmpl_len = probe_rsp_info->probeRespTemplateLen;
+	if (tmpl_len > BEACON_TX_BUFFER_SIZE) {
+		WMA_LOGE(FL("tmpl_len: %d > %d. Invalid tmpl len"),
+			 tmpl_len, BEACON_TX_BUFFER_SIZE);
+		return -EINVAL;
+	}
 	tmpl_len_aligned = roundup(tmpl_len, sizeof(A_UINT32));
 	/*
 	 * Make the TSF offset negative so probe response in the same
@@ -20873,7 +20878,19 @@ static int wmi_unified_bcn_tmpl_send(tp_wma_handle wma,
 		tmpl_len = *(u_int32_t *)&bcn_info->beacon[0];
 	else
 		tmpl_len = bcn_info->beaconLength;
+
+	if (tmpl_len > BEACON_TX_BUFFER_SIZE) {
+		WMA_LOGE(FL("tmpl_len: %d > %d. Invalid tmpl len"),
+			 tmpl_len, BEACON_TX_BUFFER_SIZE);
+		return -EINVAL;
+	}
+
 	if (p2p_ie_len) {
+		if (tmpl_len <= p2p_ie_len) {
+			WMA_LOGE(FL("tmpl_len %d <= p2p_ie_len %d, Invalid"),
+				 tmpl_len, p2p_ie_len);
+			return -EINVAL;
+		}
 		tmpl_len -= (u_int32_t) p2p_ie_len;
 	}
 
@@ -20893,6 +20910,12 @@ static int wmi_unified_bcn_tmpl_send(tp_wma_handle wma,
 	          sizeof(wmi_bcn_prb_info) + WMI_TLV_HDR_SIZE +
 		  tmpl_len_aligned;
 
+	if (wmi_buf_len > BEACON_TX_BUFFER_SIZE) {
+		WMA_LOGE(FL("wmi_buf_len: %d > %d. Can't send wmi cmd"),
+			 wmi_buf_len, BEACON_TX_BUFFER_SIZE);
+		return -EINVAL;
+	}
+
 	wmi_buf = wmi_buf_alloc(wma->wmi_handle, wmi_buf_len);
 	if (!wmi_buf) {
 		WMA_LOGE("%s : wmi_buf_alloc failed", __func__);
@@ -31439,7 +31462,7 @@ static int wma_process_sap_auth_offload(tp_wma_handle wma_handle,
 	wmi_sap_ofl_enable_cmd_fixed_param *cmd = NULL;
 	wmi_buf_t buf;
 	u_int8_t *buf_ptr;
-	u_int16_t len, psk_len, psk_len_padded;
+	uint32_t len, psk_len, psk_len_padded;
 	int err;
 
 	if (!WMI_SERVICE_IS_ENABLED(wma_handle->wmi_service_bitmap,
@@ -31448,6 +31471,13 @@ static int wma_process_sap_auth_offload(tp_wma_handle wma_handle,
 		return -EIO;
 	}
 
+	if (sap_auth_offload_info->key_len < 8 ||
+	    sap_auth_offload_info->key_len > SIR_PSK_MAX_LEN) {
+		hddLog(VOS_TRACE_LEVEL_ERROR,
+		       "%s: invalid key length(%d) of WPA security!", __func__,
+		       sap_auth_offload_info->key_len);
+		return -EINVAL;
+	}
 	psk_len = sap_auth_offload_info->key_len;
 	psk_len_padded = roundup(psk_len, sizeof(uint32_t));
 
-- 
cgit v1.1

