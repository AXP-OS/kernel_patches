From a823779f1102ed986fb4ed4ea66375e4980763c1 Mon Sep 17 00:00:00 2001
From: Swaroop Belur Sudhanva <ssudhanv@codeaurora.org>
Date: Fri, 20 Aug 2021 10:37:02 -0700
Subject: msm: synx: fix synx_release_core race condition

Fix resolves potential issue where code might lock one mutex and
release another mutex inadvertantly.

Change-Id: Ia693640e3de7001707f5f97461d33ae142a8e4d5
Signed-off-by: Swaroop Belur Sudhanva <ssudhanv@codeaurora.org>
---
 drivers/media/platform/msm/synx/synx.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/media/platform/msm/synx/synx.c b/drivers/media/platform/msm/synx/synx.c
index cd6795c..5143f703 100644
--- a/drivers/media/platform/msm/synx/synx.c
+++ b/drivers/media/platform/msm/synx/synx.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
  */
 #define pr_fmt(fmt) "synx: " fmt
 
@@ -450,10 +450,10 @@ static int synx_release_core(struct synx_table_row *row)
 	 * (definitely for merged synx on invoing deinit)
 	 * be carefull while accessing the metadata
 	 */
-	mutex_lock(&synx_dev->row_locks[row->index]);
-	fence = row->fence;
 	idx = row->index;
-	if (!idx) {
+	mutex_lock(&synx_dev->row_locks[idx]);
+	fence = row->fence;
+	if ((!idx) || (!fence)) {
 		mutex_unlock(&synx_dev->row_locks[idx]);
 		pr_err("object already cleaned up at %d\n", idx);
 		return -EINVAL;
-- 
cgit v1.1

