From 3a6eab8dabec3049a06e4449bbb2ed4f107f9c47 Mon Sep 17 00:00:00 2001
From: Daniel Rosenberg <drosen@google.com>
Date: Tue, 25 Jan 2022 14:18:06 +0000
Subject: [PATCH] ion: Fix use after free during ION_IOC_ALLOC

If a user happens to call ION_IOC_FREE during an ION_IOC_ALLOC
on the just allocated id, and the copy_to_user fails, the cleanup
code will attempt to free an already freed handle.

This adds a wrapper for ion_alloc that adds an ion_handle_get to
avoid this.

Issue: SEC-3341
Issue: SEC-3344
Signed-off-by: Daniel Rosenberg <drosen@google.com>
Signed-off-by: Dennis Cagle <d-cagle@codeaurora.org>
Signed-off-by: Patrick Daly <pdaly@codeaurora.org>
Signed-off-by: Lee Jones <lee.jones@linaro.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 504e1d6ee65d5b5a053253ae62f46035d774353c)
Change-Id: Id3e558ce7bb983447752852dcdea33c65a323e45
---
 drivers/gpu/ion/ion.c | 19 +++++++++++++++----
 include/linux/ion.h   |  4 ++++
 2 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/ion/ion.c b/drivers/gpu/ion/ion.c
index 6e87ca7ce665..0571a2a581c3 100644
--- a/drivers/gpu/ion/ion.c
+++ b/drivers/gpu/ion/ion.c
@@ -521,9 +521,9 @@ static int ion_handle_add(struct ion_client *client, struct ion_handle *handle)
 	return 0;
 }
 
-struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
+struct ion_handle *__ion_alloc(struct ion_client *client, size_t len,
 			     size_t align, unsigned int heap_id_mask,
-			     unsigned int flags)
+			     unsigned int flags, bool grab_handle)
 {
 	struct ion_handle *handle;
 	struct ion_device *dev = client->dev;
@@ -624,6 +624,8 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 		return handle;
 
 	mutex_lock(&client->lock);
+	if (grab_handle)
+		ion_handle_get(handle);
 	ret = ion_handle_add(client, handle);
 	mutex_unlock(&client->lock);
 	if (ret) {
@@ -633,6 +635,13 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 
 	return handle;
 }
+
+struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
+			     size_t align, unsigned int heap_id_mask,
+			     unsigned int flags)
+{
+	return __ion_alloc(client, len, align, heap_id_mask, flags, false);
+}
 EXPORT_SYMBOL(ion_alloc);
 
 static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)
@@ -1433,8 +1442,8 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 		if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
 			return -EFAULT;
-		handle = ion_alloc(client, data.len, data.align,
-					     data.heap_mask, data.flags);
+		handle = __ion_alloc(client, data.len, data.align,
+					     data.heap_mask, data.flags, true);
 
 		if (IS_ERR(handle))
 			return PTR_ERR(handle);
@@ -1445,8 +1454,10 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			mutex_lock(&client->lock);
 			user_ion_free_nolock(client, handle);
 			mutex_unlock(&client->lock);
+			ion_handle_put(handle);
 			return -EFAULT;
 		}
+		ion_handle_put(handle);
 		break;
 	}
 	case ION_IOC_FREE:
diff --git a/include/linux/ion.h b/include/linux/ion.h
index 8300e833e1d5..e9acadb8de4a 100644
--- a/include/linux/ion.h
+++ b/include/linux/ion.h
@@ -182,6 +182,10 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 			     size_t align, unsigned int heap_id_mask,
 			     unsigned int flags);
 
+struct ion_handle *__ion_alloc(struct ion_client *client, size_t len,
+			       size_t align, unsigned int heap_id_mask,
+			       unsigned int flags, bool grab_handle);
+
 /**
  * ion_free - free a handle
  * @client:	the client
