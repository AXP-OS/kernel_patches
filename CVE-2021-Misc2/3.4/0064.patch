From 49f55527ddd928a351f77e72cd36d12e9a5ffc09 Mon Sep 17 00:00:00 2001
From: Jeremy Gebben <jgebben@codeaurora.org>
Date: Wed, 18 Sep 2013 16:03:46 -0600
Subject: [PATCH] msm: kgsl: store process comm name in kgsl_process_private

Now that contexts keep a reference on their owning
kgsl_process_private, look up pid and process from there.
If the process is exiting while hanging the GPU, the
process name might not be available anymore by the time
we make the snapshot.

Issue: SEC-3014
Change-Id: If05ae2096dd7d25bfe9931e949759e11ba3cd262
Signed-off-by: Jeremy Gebben <jgebben@codeaurora.org>
(cherry-picked from commit https://source.codeaurora.org/quic/la/kernel/msm-3.10/commit/?id=06ab8cc77d0a8eb32edeadf5c445a643f0df0c1b)
---
 drivers/gpu/msm/adreno_dispatch.c | 11 +++--------
 drivers/gpu/msm/adreno_profile.c  |  2 +-
 drivers/gpu/msm/kgsl.c            |  3 ++-
 drivers/gpu/msm/kgsl_device.h     |  8 ++++----
 4 files changed, 10 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/msm/adreno_dispatch.c b/drivers/gpu/msm/adreno_dispatch.c
index 2a42e64dbb8..ec7820bbd96 100644
--- a/drivers/gpu/msm/adreno_dispatch.c
+++ b/drivers/gpu/msm/adreno_dispatch.c
@@ -1073,13 +1073,8 @@ static char _pidname[TASK_COMM_LEN];
 
 static inline const char *_kgsl_context_comm(struct kgsl_context *context)
 {
-	struct task_struct *task = NULL;
-
-	if (context)
-		task = find_task_by_vpid(context->pid);
-
-	if (task)
-		get_task_comm(_pidname, task);
+	if (context && context->proc_priv)
+		strlcpy(_pidname, context->proc_priv->comm, sizeof(_pidname));
 	else
 		snprintf(_pidname, TASK_COMM_LEN, "unknown");
 
@@ -1089,7 +1084,7 @@ static inline const char *_kgsl_context_comm(struct kgsl_context *context)
 #define pr_fault(_d, _c, fmt, args...) \
 		dev_err((_d)->dev, "%s[%d]: " fmt, \
 		_kgsl_context_comm((_c)->context), \
-		(_c)->context->pid, ##args)
+		(_c)->context->proc_priv->pid, ##args)
 
 
 static void adreno_fault_header(struct kgsl_device *device,
diff --git a/drivers/gpu/msm/adreno_profile.c b/drivers/gpu/msm/adreno_profile.c
index c1dc87b4b4e..d424e8f4b83 100644
--- a/drivers/gpu/msm/adreno_profile.c
+++ b/drivers/gpu/msm/adreno_profile.c
@@ -420,7 +420,7 @@ static void transfer_results(struct kgsl_device *device,
 		} else {
 			struct adreno_context *adreno_ctxt =
 				ADRENO_CONTEXT(k_ctxt);
-			pid = k_ctxt->pid;  /* pid */
+			pid = k_ctxt->proc_priv->pid;  /* pid */
 			tid = k_ctxt->tid; /* tid creator */
 			client_type =  adreno_ctxt->type << 16;
 		}
diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index d5c59df55a5..301025b0df4 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -584,7 +584,6 @@ int kgsl_context_init(struct kgsl_device_private *dev_priv,
 	context->device = dev_priv->device;
 	context->dev_priv = dev_priv;
 	context->proc_priv = dev_priv->process_priv;
-	context->pid = task_tgid_nr(current);
 	context->tid = task_pid_nr(current);
 
 	ret = kgsl_sync_timeline_create(context);
@@ -1009,6 +1008,8 @@ kgsl_get_process_private(struct kgsl_device *device)
 	if (test_bit(KGSL_PROCESS_INIT, &private->priv))
 		goto done;
 
+	get_task_comm(private->comm, current->group_leader);
+
 	private->mem_rb = RB_ROOT;
 	idr_init(&private->mem_idr);
 
diff --git a/drivers/gpu/msm/kgsl_device.h b/drivers/gpu/msm/kgsl_device.h
index 58187e95384..1a82d8cb75c 100644
--- a/drivers/gpu/msm/kgsl_device.h
+++ b/drivers/gpu/msm/kgsl_device.h
@@ -405,7 +405,6 @@ struct kgsl_process_private;
  * sync_pt timestamp expires
  * @events: A kgsl_event_group for this context - contains the list of GPU
  * events
- * @pid: process that owns this context.
  * @tid: task that created this context.
  * @pagefault_ts: global timestamp of the pagefault, if KGSL_CONTEXT_PAGEFAULT
  * is set.
@@ -417,7 +416,6 @@ struct kgsl_process_private;
 struct kgsl_context {
 	struct kref refcount;
 	uint32_t id;
-	pid_t pid;
 	pid_t tid;
 	struct kgsl_device_private *dev_priv;
 	struct kgsl_process_private *proc_priv;
@@ -439,6 +437,7 @@ struct kgsl_context {
  * all devices)
  * @priv: Internal flags, use KGSL_PROCESS_* values
  * @pid: ID for the task owner of the process
+ * @comm: task name of the process
  * @mem_lock: Spinlock to protect the process memory lists
  * @refcount: kref object for reference counting the process
  * @process_private_mutex: Mutex to synchronize access to the process struct
@@ -452,6 +451,7 @@ struct kgsl_context {
 struct kgsl_process_private {
 	unsigned long priv;
 	pid_t pid;
+	char comm[TASK_COMM_LEN];
 	spinlock_t mem_lock;
 
 	/* General refcount for process private struct obj */
@@ -736,8 +736,8 @@ static inline struct kgsl_context *kgsl_context_get_owner(
 
 	context = kgsl_context_get(dev_priv->device, id);
 
-	/* Verify that the context belongs to current calling process. */
-	if (context != NULL && context->pid != dev_priv->process_priv->pid) {
+	/* Verify that the context belongs to current calling fd. */
+	if (context != NULL && context->dev_priv != dev_priv) {
 		kgsl_context_put(context);
 		return NULL;
 	}
