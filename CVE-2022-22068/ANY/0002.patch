From 0098ef73cc8d83fce4583252d3fe5e95642e9a9f Mon Sep 17 00:00:00 2001
From: Jilai Wang <quic_jilaiw@quicinc.com>
Date: Sun, 12 Dec 2021 18:16:01 -0500
Subject: msm: npu: remove asynchronous network execution support

Remove asynchronous network execution related code since it's
not used.

Change-Id: Ied3cc7e6196daad62d4bfe4fcf0a7f8626235516
Signed-off-by: Jilai Wang <quic_jilaiw@quicinc.com>
---
 drivers/media/platform/msm/npu/npu_common.h |  10 --
 drivers/media/platform/msm/npu/npu_dev.c    |  65 +------------
 drivers/media/platform/msm/npu/npu_mgr.c    | 146 ++--------------------------
 drivers/media/platform/msm/npu/npu_mgr.h    |   1 -
 4 files changed, 9 insertions(+), 213 deletions(-)

diff --git a/drivers/media/platform/msm/npu/npu_common.h b/drivers/media/platform/msm/npu/npu_common.h
index d5be84b9..5a9754b 100644
--- a/drivers/media/platform/msm/npu/npu_common.h
+++ b/drivers/media/platform/msm/npu/npu_common.h
@@ -294,18 +294,9 @@ struct npu_device {
 	uint32_t hw_version;
 };
 
-struct npu_kevent {
-	struct list_head list;
-	struct msm_npu_event evt;
-	uint64_t reserved[4];
-};
-
 struct npu_client {
 	struct npu_device *npu_dev;
-	wait_queue_head_t wait;
-
 	struct mutex list_lock;
-	struct list_head evt_list;
 	struct list_head mapped_buffer_list;
 };
 
@@ -343,7 +334,6 @@ void disable_fw(struct npu_device *npu_dev);
 int load_fw(struct npu_device *npu_dev);
 int unload_fw(struct npu_device *npu_dev);
 int npu_set_bw(struct npu_device *npu_dev, int new_ib, int new_ab);
-int npu_process_kevent(struct npu_client *client, struct npu_kevent *kevt);
 int npu_notify_cdsprm_cxlimit_activity(struct npu_device *npu_dev, bool enable);
 int npu_bridge_mbox_send_data(struct npu_host_ctx *host_ctx,
 	struct npu_mbox *mbox, void *data);
diff --git a/drivers/media/platform/msm/npu/npu_dev.c b/drivers/media/platform/msm/npu/npu_dev.c
index ca6db6a..9cc26a8 100644
--- a/drivers/media/platform/msm/npu/npu_dev.c
+++ b/drivers/media/platform/msm/npu/npu_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
  */
 
 /* -------------------------------------------------------------------------
@@ -90,8 +90,6 @@ static int npu_unload_network(struct npu_client *client,
 	unsigned long arg);
 static int npu_exec_network_v2(struct npu_client *client,
 	unsigned long arg);
-static int npu_receive_event(struct npu_client *client,
-	unsigned long arg);
 static int npu_set_fw_state(struct npu_client *client, uint32_t enable);
 static int npu_set_property(struct npu_client *client,
 	unsigned long arg);
@@ -99,7 +97,6 @@ static int npu_get_property(struct npu_client *client,
 	unsigned long arg);
 static long npu_ioctl(struct file *file, unsigned int cmd,
 					unsigned long arg);
-static unsigned int npu_poll(struct file *filp, struct poll_table_struct *p);
 static int npu_parse_dt_clock(struct npu_device *npu_dev);
 static int npu_parse_dt_regulator(struct npu_device *npu_dev);
 static int npu_parse_dt_bw(struct npu_device *npu_dev);
@@ -210,7 +207,6 @@ static const struct file_operations npu_fops = {
 #ifdef CONFIG_COMPAT
 	 .compat_ioctl = npu_ioctl,
 #endif
-	.poll = npu_poll,
 };
 
 static const struct thermal_cooling_device_ops npu_cooling_ops = {
@@ -1255,9 +1251,7 @@ static int npu_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 
 	client->npu_dev = npu_dev;
-	init_waitqueue_head(&client->wait);
 	mutex_init(&client->list_lock);
-	INIT_LIST_HEAD(&client->evt_list);
 	INIT_LIST_HEAD(&(client->mapped_buffer_list));
 	file->private_data = client;
 
@@ -1267,17 +1261,9 @@ static int npu_open(struct inode *inode, struct file *file)
 static int npu_close(struct inode *inode, struct file *file)
 {
 	struct npu_client *client = file->private_data;
-	struct npu_kevent *kevent;
 
 	npu_host_cleanup_networks(client);
 
-	while (!list_empty(&client->evt_list)) {
-		kevent = list_first_entry(&client->evt_list,
-			struct npu_kevent, list);
-		list_del(&kevent->list);
-		kfree(kevent);
-	}
-
 	mutex_destroy(&client->list_lock);
 	kfree(client);
 	return 0;
@@ -1525,35 +1511,6 @@ static int npu_exec_network_v2(struct npu_client *client,
 	return ret;
 }
 
-static int npu_receive_event(struct npu_client *client,
-	unsigned long arg)
-{
-	void __user *argp = (void __user *)arg;
-	struct npu_kevent *kevt;
-	int ret = 0;
-
-	mutex_lock(&client->list_lock);
-	if (list_empty(&client->evt_list)) {
-		NPU_ERR("event list is empty\n");
-		ret = -EINVAL;
-	} else {
-		kevt = list_first_entry(&client->evt_list,
-			struct npu_kevent, list);
-		list_del(&kevt->list);
-		npu_process_kevent(client, kevt);
-		ret = copy_to_user(argp, &kevt->evt,
-			sizeof(struct msm_npu_event));
-		if (ret) {
-			NPU_ERR("fail to copy to user\n");
-			ret = -EFAULT;
-		}
-		kfree(kevt);
-	}
-	mutex_unlock(&client->list_lock);
-
-	return ret;
-}
-
 static int npu_set_fw_state(struct npu_client *client, uint32_t enable)
 {
 	struct npu_device *npu_dev = client->npu_dev;
@@ -1715,9 +1672,6 @@ static long npu_ioctl(struct file *file, unsigned int cmd,
 	case MSM_NPU_EXEC_NETWORK_V2:
 		ret = npu_exec_network_v2(client, arg);
 		break;
-	case MSM_NPU_RECEIVE_EVENT:
-		ret = npu_receive_event(client, arg);
-		break;
 	case MSM_NPU_SET_PROP:
 		ret = npu_set_property(client, arg);
 		break;
@@ -1731,23 +1685,6 @@ static long npu_ioctl(struct file *file, unsigned int cmd,
 	return ret;
 }
 
-static unsigned int npu_poll(struct file *filp, struct poll_table_struct *p)
-{
-	struct npu_client *client = filp->private_data;
-	int rc = 0;
-
-	poll_wait(filp, &client->wait, p);
-
-	mutex_lock(&client->list_lock);
-	if (!list_empty(&client->evt_list)) {
-		NPU_DBG("poll cmd done\n");
-		rc = POLLIN | POLLRDNORM;
-	}
-	mutex_unlock(&client->list_lock);
-
-	return rc;
-}
-
 /* -------------------------------------------------------------------------
  * Device Tree Parsing
  * -------------------------------------------------------------------------
diff --git a/drivers/media/platform/msm/npu/npu_mgr.c b/drivers/media/platform/msm/npu/npu_mgr.c
index 8e93a71..9eb337d 100644
--- a/drivers/media/platform/msm/npu/npu_mgr.c
+++ b/drivers/media/platform/msm/npu/npu_mgr.c
@@ -60,7 +60,6 @@ static int npu_send_network_cmd(struct npu_device *npu_dev,
 	struct npu_network_cmd *cmd);
 static int npu_send_misc_cmd(struct npu_device *npu_dev, uint32_t q_idx,
 	void *cmd_ptr, struct npu_misc_cmd *cmd);
-static int npu_queue_event(struct npu_client *client, struct npu_kevent *evt);
 static int npu_notify_aop(struct npu_device *npu_dev, bool on);
 static int npu_notify_fw_pwr_state(struct npu_device *npu_dev,
 	uint32_t pwr_level, bool post);
@@ -283,7 +282,6 @@ int load_fw(struct npu_device *npu_dev)
 static void complete_pending_commands(struct npu_host_ctx *host_ctx)
 {
 	struct npu_network *network = NULL;
-	struct npu_kevent kevt;
 	struct npu_network_cmd *cmd;
 	struct npu_misc_cmd *misc_cmd;
 	int i;
@@ -294,26 +292,10 @@ static void complete_pending_commands(struct npu_host_ctx *host_ctx)
 		if (!network->is_valid || !network->fw_error)
 			continue;
 
-		if (network->is_async) {
-			NPU_DBG("async cmd, queue ssr event\n");
-			kevt.evt.type = MSM_NPU_EVENT_TYPE_SSR;
-			kevt.evt.u.ssr.network_hdl =
-				network->network_hdl;
-			if (npu_queue_event(network->client, &kevt))
-				NPU_ERR("queue npu event failed\n");
-
-			while (!list_empty(&network->cmd_list)) {
-				cmd = list_first_entry(&network->cmd_list,
-					struct npu_network_cmd, list);
-				npu_dequeue_network_cmd(network, cmd);
-				npu_free_network_cmd(host_ctx, cmd);
-			}
-		} else {
-			list_for_each_entry(cmd, &network->cmd_list, list) {
-				NPU_INFO("complete network %llx trans_id %d\n",
-					network->id, cmd->trans_id);
-				complete(&cmd->cmd_done);
-			}
+		list_for_each_entry(cmd, &network->cmd_list, list) {
+			NPU_INFO("complete network %llx trans_id %d\n",
+				network->id, cmd->trans_id);
+			complete(&cmd->cmd_done);
 		}
 	}
 
@@ -1555,23 +1537,6 @@ static void npu_free_network_cmd(struct npu_host_ctx *ctx,
 	kmem_cache_free(ctx->network_cmd_cache, cmd);
 }
 
-static int npu_queue_event(struct npu_client *client, struct npu_kevent *evt)
-{
-	struct npu_kevent *kevt = kmalloc(sizeof(*kevt), GFP_KERNEL);
-
-	if (!kevt)
-		return -ENOMEM;
-
-	*kevt = *evt;
-	INIT_LIST_HEAD(&kevt->list);
-	mutex_lock(&client->list_lock);
-	list_add_tail(&kevt->list, &client->evt_list);
-	mutex_unlock(&client->list_lock);
-	wake_up_interruptible(&client->wait);
-
-	return 0;
-}
-
 static void npu_queue_network_cmd(struct npu_network *network,
 	struct npu_network_cmd *cmd)
 {
@@ -1651,71 +1616,15 @@ static struct npu_misc_cmd *npu_find_misc_cmd(struct npu_host_ctx *ctx,
 	return NULL;
 }
 
-int npu_process_kevent(struct npu_client *client, struct npu_kevent *kevt)
-{
-	struct npu_device *npu_dev = client->npu_dev;
-	struct npu_host_ctx *host_ctx = &npu_dev->host_ctx;
-	int ret = 0;
-
-	mutex_lock(&host_ctx->lock);
-
-	switch (kevt->evt.type) {
-	case MSM_NPU_EVENT_TYPE_EXEC_V2_DONE:
-	{
-		struct npu_network_cmd *cmd = NULL;
-		struct npu_network *network;
-
-		network = get_network_by_hdl(host_ctx,
-			client, kevt->reserved[0]);
-		if (!network) {
-			NPU_ERR("Can't find network %x\n", kevt->reserved[0]);
-			ret = -EINVAL;
-			break;
-		}
-
-		cmd = npu_find_network_cmd(network, kevt->reserved[1]);
-		if (!cmd) {
-			NPU_ERR("can't find exec cmd with trans_id:%d\n",
-				kevt->reserved[1]);
-			network_put(network);
-			ret = -EINVAL;
-			break;
-		}
-
-		kevt->evt.reserved[0] = cmd->cmd_id;
-		ret = copy_to_user((void __user *)cmd->stats_buf_u,
-			(void *)cmd->stats_buf,
-			kevt->evt.u.exec_v2_done.stats_buf_size);
-		if (ret) {
-			NPU_ERR("fail to copy to user\n");
-			kevt->evt.u.exec_v2_done.stats_buf_size = 0;
-			ret = -EFAULT;
-		}
-
-		npu_dequeue_network_cmd(network, cmd);
-		npu_free_network_cmd(host_ctx, cmd);
-		network_put(network);
-		break;
-	}
-	default:
-		break;
-	}
-	mutex_unlock(&host_ctx->lock);
-
-	return ret;
-}
-
 static int app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg)
 {
 	uint32_t msg_id;
 	struct npu_network *network = NULL;
-	struct npu_kevent kevt;
 	struct npu_device *npu_dev = host_ctx->npu_dev;
 	struct npu_network_cmd *network_cmd = NULL;
 	struct npu_misc_cmd *misc_cmd = NULL;
 	int need_ctx_switch = 0;
 
-	memset(&kevt, 0, sizeof(kevt));
 	msg_id = msg[1];
 	switch (msg_id) {
 	case NPU_IPC_MSG_EXECUTE_DONE:
@@ -1746,18 +1655,7 @@ static int app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg)
 
 		network_cmd->ret_status = exe_rsp_pkt->header.status;
 
-		if (!network_cmd->async) {
-			complete(&network_cmd->cmd_done);
-		} else {
-			NPU_DBG("async cmd, queue event\n");
-			kevt.evt.type = MSM_NPU_EVENT_TYPE_EXEC_DONE;
-			kevt.evt.u.exec_done.network_hdl =
-				exe_rsp_pkt->network_hdl;
-			kevt.evt.u.exec_done.exec_result =
-				exe_rsp_pkt->header.status;
-			if (npu_queue_event(network->client, &kevt))
-				NPU_ERR("queue npu event failed\n");
-		}
+		complete(&network_cmd->cmd_done);
 		network_put(network);
 		need_ctx_switch = 1;
 		break;
@@ -1803,21 +1701,7 @@ static int app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg)
 		network_cmd->stats_buf_size = stats_size;
 		network_cmd->ret_status = exe_rsp_pkt->header.status;
 
-		if (network_cmd->async) {
-			NPU_DBG("async cmd, queue event\n");
-			kevt.evt.type = MSM_NPU_EVENT_TYPE_EXEC_V2_DONE;
-			kevt.evt.u.exec_v2_done.network_hdl =
-				exe_rsp_pkt->network_hdl;
-			kevt.evt.u.exec_v2_done.exec_result =
-				exe_rsp_pkt->header.status;
-			kevt.evt.u.exec_v2_done.stats_buf_size = stats_size;
-			kevt.reserved[0] = (uint64_t)network->network_hdl;
-			kevt.reserved[1] = (uint64_t)network_cmd->trans_id;
-			if (npu_queue_event(network->client, &kevt))
-				NPU_ERR("queue npu event failed\n");
-		} else {
-			complete(&network_cmd->cmd_done);
-		}
+		complete(&network_cmd->cmd_done);
 		network_put(network);
 		need_ctx_switch = 1;
 		break;
@@ -2819,7 +2703,6 @@ int32_t npu_host_exec_network_v2(struct npu_client *client,
 	struct npu_network *network;
 	struct npu_host_ctx *host_ctx = &npu_dev->host_ctx;
 	uint32_t num_patch_params, pkt_size;
-	bool async_ioctl = !!exec_ioctl->async;
 	int i, retry_cnt = 1;
 
 	mutex_lock(&host_ctx->lock);
@@ -2852,14 +2735,6 @@ int32_t npu_host_exec_network_v2(struct npu_client *client,
 		goto exec_v2_done;
 	}
 
-	if (network->is_async && !async_ioctl) {
-		NPU_ERR("network is in async mode\n");
-		ret = -EINVAL;
-		goto exec_v2_done;
-	}
-
-	network->is_async = async_ioctl;
-
 	NPU_DBG("execute_v2 network %lld\n", network->id);
 	num_patch_params = exec_ioctl->patch_buf_info_num;
 	pkt_size = num_patch_params * sizeof(struct npu_patch_params_v2) +
@@ -2906,10 +2781,10 @@ int32_t npu_host_exec_network_v2(struct npu_client *client,
 	}
 
 	exec_cmd->stats_buf_u = (void __user *)exec_ioctl->stats_buf_addr;
-	exec_cmd->cmd_id = exec_ioctl->async;
+	exec_cmd->cmd_id = 0;
 	exec_cmd->cmd_type = NPU_IPC_CMD_EXECUTE_V2;
 	exec_cmd->trans_id = exec_packet->header.trans_id;
-	exec_cmd->async = async_ioctl;
+	exec_cmd->async = false;
 	npu_queue_network_cmd(network, exec_cmd);
 
 	NPU_DBG("Execute_v2 flags %x stats_buf_size %d\n",
@@ -2922,11 +2797,6 @@ int32_t npu_host_exec_network_v2(struct npu_client *client,
 		goto free_exec_cmd;
 	}
 
-	if (async_ioctl) {
-		NPU_DBG("Async ioctl, return now\n");
-		goto free_exec_packet;
-	}
-
 	mutex_unlock(&host_ctx->lock);
 
 retry:
diff --git a/drivers/media/platform/msm/npu/npu_mgr.h b/drivers/media/platform/msm/npu/npu_mgr.h
index f22e721..414901e 100644
--- a/drivers/media/platform/msm/npu/npu_mgr.h
+++ b/drivers/media/platform/msm/npu/npu_mgr.h
@@ -85,7 +85,6 @@ struct npu_network {
 	bool is_valid;
 	bool is_active;
 	bool fw_error;
-	bool is_async;
 	struct npu_client *client;
 	struct list_head cmd_list;
 };
-- 
cgit v1.1

