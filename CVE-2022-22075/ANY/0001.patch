From ece352ac70eb739462bfa4c9f252cdde9fde4888 Mon Sep 17 00:00:00 2001
From: Mohammed Mirza Mandayappurath Manzoor <quic_mmandaya@quicinc.com>
Date: Tue, 18 Jan 2022 16:06:24 -0800
Subject: [PATCH] msm: kgsl: Zap performance counters across context switches

Performance counter values need not be retained across contexts unless
specifically requested for debug. Zap the counters by initialising
perfcounter SRAM with 0's using GPU_RBBM_PERFCTR_SRAM_INIT_CMD.

Add pm4 packets during context switches and add a KMD postamble packet to
clear the counters during preemption. Do not enable perfcounter save and
restore unless requested.

Change-Id: I371779ce659c07a1cc664327f5ecdcf0374201d8
Signed-off-by: Mohammed Mirza Mandayappurath Manzoor <quic_mmandaya@quicinc.com>
---
 drivers/gpu/msm/a6xx_reg.h               |  2 ++
 drivers/gpu/msm/adreno.h                 |  7 ++++
 drivers/gpu/msm/adreno_a6xx_preempt.c    | 43 +++++++++++++++++++++---
 drivers/gpu/msm/adreno_a6xx_ringbuffer.c | 29 +++++++++++++---
 drivers/gpu/msm/adreno_gen7_preempt.c    | 43 +++++++++++++++++++++---
 drivers/gpu/msm/adreno_gen7_ringbuffer.c | 28 ++++++++++++---
 drivers/gpu/msm/adreno_perfcounter.c     |  6 ++--
 drivers/gpu/msm/adreno_pm4types.h        |  6 ++++
 drivers/gpu/msm/gen7_reg.h               |  2 ++
 9 files changed, 146 insertions(+), 20 deletions(-)

diff --git a/drivers/gpu/msm/a6xx_reg.h b/drivers/gpu/msm/a6xx_reg.h
index 0c0a118957d8e..55613d205c413 100644
--- a/drivers/gpu/msm/a6xx_reg.h
+++ b/drivers/gpu/msm/a6xx_reg.h
@@ -406,6 +406,8 @@
 #define A6XX_RBBM_PERFCTR_RBBM_SEL_2             0x509
 #define A6XX_RBBM_PERFCTR_RBBM_SEL_3             0x50A
 #define A6XX_RBBM_PERFCTR_GPU_BUSY_MASKED        0x50B
+#define A6XX_RBBM_PERFCTR_SRAM_INIT_CMD          0x50e
+#define A6XX_RBBM_PERFCTR_SRAM_INIT_STATUS       0x50f
 
 #define A6XX_RBBM_ISDB_CNT                       0x533
 #define A6XX_RBBM_NC_MODE_CNTL                   0X534
diff --git a/drivers/gpu/msm/adreno.h b/drivers/gpu/msm/adreno.h
index f83a518ff4b1f..8ff4692dcb367 100644
--- a/drivers/gpu/msm/adreno.h
+++ b/drivers/gpu/msm/adreno.h
@@ -27,6 +27,8 @@
 #define SET_PSEUDO_NON_PRIV_SAVE_ADDR 3
 /* Used to inform CP where to save preemption counter data at the time of switch out */
 #define SET_PSEUDO_COUNTER 4
+/* Index to preemption scratch buffer to store KMD postamble */
+#define KMD_POSTAMBLE_IDX 100
 
 /* ADRENO_DEVICE - Given a kgsl_device return the adreno device struct */
 #define ADRENO_DEVICE(device) \
@@ -223,6 +225,9 @@ struct adreno_gpudev;
 /* Time to allow preemption to complete (in ms) */
 #define ADRENO_PREEMPT_TIMEOUT 10000
 
+#define PREEMPT_SCRATCH_ADDR(dev, id) \
+	((dev)->preempt.scratch->gpuaddr + (id * sizeof(u64)))
+
 /**
  * enum adreno_preempt_states
  * ADRENO_PREEMPT_NONE: No preemption is scheduled
@@ -272,6 +277,7 @@ struct adreno_protected_regs {
  * skipsaverestore: To skip saverestore during L1 preemption (for 6XX)
  * usesgmem: enable GMEM save/restore across preemption (for 6XX)
  * count: Track the number of preemptions triggered
+ * @postamble_len: Number of dwords in KMD postamble pm4 packet
  */
 struct adreno_preemption {
 	atomic_t state;
@@ -282,6 +288,7 @@ struct adreno_preemption {
 	bool skipsaverestore;
 	bool usesgmem;
 	unsigned int count;
+	u32 postamble_len;
 };
 
 struct adreno_busy_data {
diff --git a/drivers/gpu/msm/adreno_a6xx_preempt.c b/drivers/gpu/msm/adreno_a6xx_preempt.c
index 7d83230ad22fd..51b7c255c7541 100644
--- a/drivers/gpu/msm/adreno_a6xx_preempt.c
+++ b/drivers/gpu/msm/adreno_a6xx_preempt.c
@@ -533,13 +533,24 @@ u32 a6xx_preemption_pre_ibsubmit(struct adreno_device *adreno_dev,
 
 	if (drawctxt) {
 		struct adreno_ringbuffer *rb = drawctxt->rb;
-		uint64_t dest = adreno_dev->preempt.scratch->gpuaddr
-			+ (rb->id * sizeof(u64));
+		uint64_t dest = PREEMPT_SCRATCH_ADDR(adreno_dev, rb->id);
 
 		*cmds++ = cp_mem_packet(adreno_dev, CP_MEM_WRITE, 2, 2);
 		cmds += cp_gpuaddr(adreno_dev, cmds, dest);
 		*cmds++ = lower_32_bits(gpuaddr);
 		*cmds++ = upper_32_bits(gpuaddr);
+
+		/* Add a KMD post amble to clear the perf counters during preemption */
+		if (!adreno_dev->perfcounter) {
+			u64 kmd_postamble_addr =
+					PREEMPT_SCRATCH_ADDR(adreno_dev, KMD_POSTAMBLE_IDX);
+
+			*cmds++ = cp_type7_packet(CP_SET_AMBLE, 3);
+			*cmds++ = lower_32_bits(kmd_postamble_addr);
+			*cmds++ = upper_32_bits(kmd_postamble_addr);
+			*cmds++ = FIELD_PREP(GENMASK(22, 20), CP_KMD_AMBLE_TYPE)
+				| (FIELD_PREP(GENMASK(19, 0), adreno_dev->preempt.postamble_len));
+		}
 	}
 
 	return (unsigned int) (cmds - cmds_orig);
@@ -554,8 +565,7 @@ u32 a6xx_preemption_post_ibsubmit(struct adreno_device *adreno_dev,
 		return 0;
 
 	if (adreno_dev->cur_rb) {
-		u64 dest = adreno_dev->preempt.scratch->gpuaddr
-			+ (adreno_dev->cur_rb->id * sizeof(u64));
+		u64 dest = PREEMPT_SCRATCH_ADDR(adreno_dev, adreno_dev->cur_rb->id);
 
 		cmds[index++] = cp_type7_packet(CP_MEM_WRITE, 4);
 		cmds[index++] = lower_32_bits(dest);
@@ -720,6 +730,31 @@ int a6xx_preemption_init(struct adreno_device *adreno_dev)
 			return ret;
 	}
 
+	/*
+	 * First 8 dwords of the preemption scratch buffer is used to store the address for CP
+	 * to save/restore VPC data. Reserve 11 dwords in the preemption scratch buffer from
+	 * index KMD_POSTAMBLE_IDX for KMD postamble pm4 packets
+	 */
+	if (!adreno_dev->perfcounter) {
+		u32 *postamble = preempt->scratch->hostptr + (KMD_POSTAMBLE_IDX * sizeof(u64));
+		u32 count = 0;
+
+		postamble[count++] = cp_type7_packet(CP_REG_RMW, 3);
+		postamble[count++] = A6XX_RBBM_PERFCTR_SRAM_INIT_CMD;
+		postamble[count++] = 0x0;
+		postamble[count++] = 0x1;
+
+		postamble[count++] = cp_type7_packet(CP_WAIT_REG_MEM, 6);
+		postamble[count++] = 0x3;
+		postamble[count++] = A6XX_RBBM_PERFCTR_SRAM_INIT_STATUS;
+		postamble[count++] = 0x0;
+		postamble[count++] = 0x1;
+		postamble[count++] = 0x1;
+		postamble[count++] = 0x0;
+
+		preempt->postamble_len = count;
+	}
+
 	set_bit(ADRENO_DEVICE_PREEMPTION, &adreno_dev->priv);
 	return 0;
 }
diff --git a/drivers/gpu/msm/adreno_a6xx_ringbuffer.c b/drivers/gpu/msm/adreno_a6xx_ringbuffer.c
index fe36694eb2af8..9d5f58ca73c92 100644
--- a/drivers/gpu/msm/adreno_a6xx_ringbuffer.c
+++ b/drivers/gpu/msm/adreno_a6xx_ringbuffer.c
@@ -61,11 +61,30 @@ static int a6xx_rb_context_switch(struct adreno_device *adreno_dev,
 		adreno_drawctxt_get_pagetable(drawctxt);
 	struct kgsl_device *device = KGSL_DEVICE(adreno_dev);
 	int count = 0;
-	u32 cmds[32];
+	u32 cmds[41];
+
+	if (adreno_drawctxt_get_pagetable(rb->drawctxt_active) != pagetable) {
+
+		/* Clear performance counters during context switches */
+		if (!adreno_dev->perfcounter) {
+			cmds[count++] = cp_type4_packet(A6XX_RBBM_PERFCTR_SRAM_INIT_CMD, 1);
+			cmds[count++] = 0x1;
+		}
 
-	if (adreno_drawctxt_get_pagetable(rb->drawctxt_active) != pagetable)
 		count += a6xx_rb_pagetable_switch(adreno_dev, rb, drawctxt,
-			pagetable, cmds);
+			pagetable, &cmds[count]);
+
+		/* Wait for performance counter clear to finish */
+		if (!adreno_dev->perfcounter) {
+			cmds[count++] = cp_type7_packet(CP_WAIT_REG_MEM, 6);
+			cmds[count++] = 0x3;
+			cmds[count++] = A6XX_RBBM_PERFCTR_SRAM_INIT_STATUS;
+			cmds[count++] = 0x0;
+			cmds[count++] = 0x1;
+			cmds[count++] = 0x1;
+			cmds[count++] = 0x0;
+		}
+	}
 
 	cmds[count++] = cp_type7_packet(CP_NOP, 1);
 	cmds[count++] = CONTEXT_TO_MEM_IDENTIFIER;
@@ -190,7 +209,7 @@ int a6xx_ringbuffer_init(struct adreno_device *adreno_dev)
 	return 0;
 }
 
-#define A6XX_SUBMIT_MAX 75
+#define A6XX_SUBMIT_MAX 79
 
 int a6xx_ringbuffer_addcmds(struct adreno_device *adreno_dev,
 		struct adreno_ringbuffer *rb, struct adreno_context *drawctxt,
@@ -229,7 +248,7 @@ int a6xx_ringbuffer_addcmds(struct adreno_device *adreno_dev,
 	cmds[index++] = cp_type7_packet(CP_NOP, 1);
 	cmds[index++] = drawctxt ? CMD_IDENTIFIER : CMD_INTERNAL_IDENTIFIER;
 
-	/* This is 21 dwords when drawctxt is not NULL */
+	/* This is 25 dwords when drawctxt is not NULL and perfcounter needs to be zapped */
 	index += a6xx_preemption_pre_ibsubmit(adreno_dev, rb, drawctxt,
 		&cmds[index]);
 
diff --git a/drivers/gpu/msm/adreno_gen7_preempt.c b/drivers/gpu/msm/adreno_gen7_preempt.c
index 0eed35bc5d7d4..6bbdc85504e33 100644
--- a/drivers/gpu/msm/adreno_gen7_preempt.c
+++ b/drivers/gpu/msm/adreno_gen7_preempt.c
@@ -501,14 +501,25 @@ u32 gen7_preemption_pre_ibsubmit(struct adreno_device *adreno_dev,
 done:
 	if (drawctxt) {
 		struct adreno_ringbuffer *rb = drawctxt->rb;
-		u64 dest = adreno_dev->preempt.scratch->gpuaddr
-			+ (rb->id * sizeof(u64));
+		u64 dest = PREEMPT_SCRATCH_ADDR(adreno_dev, rb->id);
 		u64 gpuaddr = drawctxt->base.user_ctxt_record->memdesc.gpuaddr;
 
 		*cmds++ = cp_mem_packet(adreno_dev, CP_MEM_WRITE, 2, 2);
 		cmds += cp_gpuaddr(adreno_dev, cmds, dest);
 		*cmds++ = lower_32_bits(gpuaddr);
 		*cmds++ = upper_32_bits(gpuaddr);
+
+		/* Add a KMD post amble to clear the perf counters during preemption */
+		if (!adreno_dev->perfcounter) {
+			u64 kmd_postamble_addr =
+					PREEMPT_SCRATCH_ADDR(adreno_dev, KMD_POSTAMBLE_IDX);
+
+			*cmds++ = cp_type7_packet(CP_SET_AMBLE, 3);
+			*cmds++ = lower_32_bits(kmd_postamble_addr);
+			*cmds++ = upper_32_bits(kmd_postamble_addr);
+			*cmds++ = FIELD_PREP(GENMASK(22, 20), CP_KMD_AMBLE_TYPE)
+				| (FIELD_PREP(GENMASK(19, 0), adreno_dev->preempt.postamble_len));
+		}
 	}
 
 	return (unsigned int) (cmds - cmds_orig);
@@ -523,8 +534,7 @@ u32 gen7_preemption_post_ibsubmit(struct adreno_device *adreno_dev,
 		return 0;
 
 	if (adreno_dev->cur_rb) {
-		u64 dest = adreno_dev->preempt.scratch->gpuaddr
-			+ (adreno_dev->cur_rb->id * sizeof(u64));
+		u64 dest = PREEMPT_SCRATCH_ADDR(adreno_dev, adreno_dev->cur_rb->id);
 
 		cmds[index++] = cp_type7_packet(CP_MEM_WRITE, 4);
 		cmds[index++] = lower_32_bits(dest);
@@ -694,6 +704,31 @@ int gen7_preemption_init(struct adreno_device *adreno_dev)
 			return ret;
 	}
 
+	/*
+	 * First 8 dwords of the preemption scratch buffer is used to store the address for CP
+	 * to save/restore VPC data. Reserve 11 dwords in the preemption scratch buffer from
+	 * index KMD_POSTAMBLE_IDX for KMD postamble pm4 packets
+	 */
+	if (!adreno_dev->perfcounter) {
+		u32 *postamble = preempt->scratch->hostptr + (KMD_POSTAMBLE_IDX * sizeof(u64));
+		u32 count = 0;
+
+		postamble[count++] = cp_type7_packet(CP_REG_RMW, 3);
+		postamble[count++] = GEN7_RBBM_PERFCTR_SRAM_INIT_CMD;
+		postamble[count++] = 0x0;
+		postamble[count++] = 0x1;
+
+		postamble[count++] = cp_type7_packet(CP_WAIT_REG_MEM, 6);
+		postamble[count++] = 0x3;
+		postamble[count++] = GEN7_RBBM_PERFCTR_SRAM_INIT_STATUS;
+		postamble[count++] = 0x0;
+		postamble[count++] = 0x1;
+		postamble[count++] = 0x1;
+		postamble[count++] = 0x0;
+
+		preempt->postamble_len = count;
+	}
+
 	set_bit(ADRENO_DEVICE_PREEMPTION, &adreno_dev->priv);
 	return 0;
 }
diff --git a/drivers/gpu/msm/adreno_gen7_ringbuffer.c b/drivers/gpu/msm/adreno_gen7_ringbuffer.c
index 8f7305acaf0cd..dd5651f425df1 100644
--- a/drivers/gpu/msm/adreno_gen7_ringbuffer.c
+++ b/drivers/gpu/msm/adreno_gen7_ringbuffer.c
@@ -64,7 +64,7 @@ static int gen7_rb_context_switch(struct adreno_device *adreno_dev,
 		adreno_drawctxt_get_pagetable(drawctxt);
 	struct kgsl_device *device = KGSL_DEVICE(adreno_dev);
 	int count = 0;
-	u32 cmds[46];
+	u32 cmds[55];
 
 	/* Sync both threads */
 	cmds[count++] = cp_type7_packet(CP_THREAD_CONTROL, 1);
@@ -82,10 +82,28 @@ static int gen7_rb_context_switch(struct adreno_device *adreno_dev,
 	cmds[count++] = cp_type7_packet(CP_THREAD_CONTROL, 1);
 	cmds[count++] = CP_SYNC_THREADS | CP_SET_THREAD_BR;
 
-	if (adreno_drawctxt_get_pagetable(rb->drawctxt_active) != pagetable)
+	if (adreno_drawctxt_get_pagetable(rb->drawctxt_active) != pagetable) {
+
+		/* Clear performance counters during context switches */
+		if (!adreno_dev->perfcounter) {
+			cmds[count++] = cp_type4_packet(GEN7_RBBM_PERFCTR_SRAM_INIT_CMD, 1);
+			cmds[count++] = 0x1;
+		}
+
 		count += gen7_rb_pagetable_switch(adreno_dev, rb,
 			drawctxt, pagetable, &cmds[count]);
-	else {
+
+		/* Wait for performance counter clear to finish */
+		if (!adreno_dev->perfcounter) {
+			cmds[count++] = cp_type7_packet(CP_WAIT_REG_MEM, 6);
+			cmds[count++] = 0x3;
+			cmds[count++] = GEN7_RBBM_PERFCTR_SRAM_INIT_STATUS;
+			cmds[count++] = 0x0;
+			cmds[count++] = 0x1;
+			cmds[count++] = 0x1;
+			cmds[count++] = 0x0;
+		}
+	} else {
 		struct kgsl_iommu *iommu = KGSL_IOMMU(device);
 
 		u32 offset = GEN7_SMMU_BASE + (iommu->cb0_offset >> 2) + 0x0d;
@@ -218,7 +236,7 @@ int gen7_ringbuffer_init(struct adreno_device *adreno_dev)
 	return 0;
 }
 
-#define GEN7_SUBMIT_MAX 100
+#define GEN7_SUBMIT_MAX 104
 
 int gen7_ringbuffer_addcmds(struct adreno_device *adreno_dev,
 		struct adreno_ringbuffer *rb, struct adreno_context *drawctxt,
@@ -253,7 +271,7 @@ int gen7_ringbuffer_addcmds(struct adreno_device *adreno_dev,
 	cmds[index++] = cp_type7_packet(CP_NOP, 1);
 	cmds[index++] = drawctxt ? CMD_IDENTIFIER : CMD_INTERNAL_IDENTIFIER;
 
-	/* This is 21 dwords when drawctxt is not NULL */
+	/* This is 25 dwords when drawctxt is not NULL and perfcounter needs to be zapped*/
 	index += gen7_preemption_pre_ibsubmit(adreno_dev, rb, drawctxt,
 		&cmds[index]);
 
diff --git a/drivers/gpu/msm/adreno_perfcounter.c b/drivers/gpu/msm/adreno_perfcounter.c
index c9260e9d6e64e..e3b7325a6a299 100644
--- a/drivers/gpu/msm/adreno_perfcounter.c
+++ b/drivers/gpu/msm/adreno_perfcounter.c
@@ -28,7 +28,8 @@ void adreno_perfcounter_restore(struct adreno_device *adreno_dev)
 	const struct adreno_perfcount_group *group;
 	unsigned int counter, groupid;
 
-	if (counters == NULL)
+	/* Do not save/restore if not requested */
+	if (counters == NULL || !adreno_dev->perfcounter)
 		return;
 
 	for (groupid = 0; groupid < counters->group_count; groupid++) {
@@ -64,7 +65,8 @@ inline void adreno_perfcounter_save(struct adreno_device *adreno_dev)
 	const struct adreno_perfcount_group *group;
 	unsigned int counter, groupid;
 
-	if (counters == NULL)
+	/* Do not save/restore if not requested */
+	if (counters == NULL || !adreno_dev->perfcounter)
 		return;
 
 	for (groupid = 0; groupid < counters->group_count; groupid++) {
diff --git a/drivers/gpu/msm/adreno_pm4types.h b/drivers/gpu/msm/adreno_pm4types.h
index 426cbce027972..028da62a3d668 100644
--- a/drivers/gpu/msm/adreno_pm4types.h
+++ b/drivers/gpu/msm/adreno_pm4types.h
@@ -47,6 +47,9 @@
 /* switches SMMU pagetable, used on a5xx only */
 #define CP_SMMU_TABLE_UPDATE 0x53
 
+/* Designate command streams to be executed before/after CP does state restore during preemption */
+#define CP_SET_AMBLE		0x55
+
 /*  Set internal CP registers, used to indicate context save data addresses */
 #define CP_SET_PSEUDO_REGISTER      0x56
 
@@ -179,6 +182,9 @@
 #define CP_CLEAR_RESOURCE_TABLE BIT(1)
 #define CP_CLEAR_ON_CHIP_TS BIT(0)
 
+/* Used to define amble type in SET_AMBLE packet to execute during preemption */
+#define CP_KMD_AMBLE_TYPE 3
+
 static inline uint pm4_calc_odd_parity_bit(uint val)
 {
 	return (0x9669 >> (0xf & ((val) ^
diff --git a/drivers/gpu/msm/gen7_reg.h b/drivers/gpu/msm/gen7_reg.h
index da03e710ff473..f7e4494bfeb1a 100644
--- a/drivers/gpu/msm/gen7_reg.h
+++ b/drivers/gpu/msm/gen7_reg.h
@@ -546,6 +546,8 @@
 #define GEN7_RBBM_PERFCTR_RBBM_SEL_2             0x509
 #define GEN7_RBBM_PERFCTR_RBBM_SEL_3             0x50a
 #define GEN7_RBBM_PERFCTR_GPU_BUSY_MASKED        0x50b
+#define GEN7_RBBM_PERFCTR_SRAM_INIT_CMD          0x50e
+#define GEN7_RBBM_PERFCTR_SRAM_INIT_STATUS       0x50f
 
 #define GEN7_RBBM_ISDB_CNT                       0x533
 #define GEN7_RBBM_NC_MODE_CNTL                   0x534
-- 
GitLab

