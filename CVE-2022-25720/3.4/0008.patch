From d062ad2744988849a0ceec90c1ee52e7fe226f19 Mon Sep 17 00:00:00 2001
From: Divyajyothi Goparaju <quic_dgoparaj@quicinc.com>
Date: Thu, 30 Dec 2021 12:03:50 +0530
Subject: [PATCH] wlan: Fix array OOB for duplicate rate

Some IoT AP may have duplicate rates in supported rates and
extended rates in beacon, need filter them when populate peer 11a/11b
rates during connect/roaming, or array out of bound issue will happen.

Issue: SEC-3581
Change-Id: Id64b35d3b4ab55ce6962e2c9f3ed0b3e6b1d0ebe
CRs-Fixed: 3102432
(cherry picked from commit 3f82ab6e52dade45289642aec6cf96e6eec056d2)
---
 .../prima/CORE/MAC/src/pe/lim/limAssocUtils.c | 92 +++++++++----------
 1 file changed, 46 insertions(+), 46 deletions(-)

diff --git a/drivers/staging/prima/CORE/MAC/src/pe/lim/limAssocUtils.c b/drivers/staging/prima/CORE/MAC/src/pe/lim/limAssocUtils.c
index 93cf853bbdc..ad3e49762af 100644
--- a/drivers/staging/prima/CORE/MAC/src/pe/lim/limAssocUtils.c
+++ b/drivers/staging/prima/CORE/MAC/src/pe/lim/limAssocUtils.c
@@ -1724,11 +1724,11 @@ limPopulateOwnRateSet(tpAniSirGlobal pMac,
 {
     tSirMacRateSet          tempRateSet;
     tSirMacRateSet          tempRateSet2;
-    tANI_U32                i,j,val,min,isArate;
+    tANI_U32                i,j,val,min;
     tANI_U32 phyMode = 0;
     tANI_U32 selfStaDot11Mode=0;
-
-    isArate = 0;
+    tANI_U8 aRateIndex = 0;
+    tANI_U8 bRateIndex = 0;
 
     wlan_cfgGetInt(pMac, WNI_CFG_DOT11_MODE, &selfStaDot11Mode);
     limGetPhyMode(pMac, &phyMode, psessionEntry);
@@ -1778,53 +1778,53 @@ limPopulateOwnRateSet(tpAniSirGlobal pMac,
      * Sort rates in tempRateSet (they are likely to be already sorted)
      * put the result in pSupportedRates
      */
-    {
-        tANI_U8 aRateIndex = 0;
-        tANI_U8 bRateIndex = 0;
-
-        vos_mem_set((tANI_U8 *) pRates, sizeof(tSirSupportedRates), 0);
-        for(i = 0;i < tempRateSet.numRates; i++)
-        {
-            min = 0;
-            val = 0xff;
-            isArate = 0;
-            for(j = 0; (j < tempRateSet.numRates) && (j < SIR_MAC_RATESET_EID_MAX); j++)
-            {
-                if ((tANI_U32) (tempRateSet.rate[j] & 0x7f) < val)
-                {
-                     val = tempRateSet.rate[j] & 0x7f;
-                     min = j;
-                }
+    vos_mem_set((tANI_U8 *) pRates, sizeof(tSirSupportedRates), 0);
+    for (i = 0; i < tempRateSet.numRates; i++) {
+        min = 0;
+        val = 0xff;
+        for (j = 0; (j < tempRateSet.numRates) &&
+             (j < SIR_MAC_RATESET_EID_MAX); j++) {
+            if ((tANI_U32)(tempRateSet.rate[j] & 0x7f) < val) {
+                val = tempRateSet.rate[j] & 0x7f;
+                min = j;
             }
-
-            if (sirIsArate(tempRateSet.rate[min] & 0x7f))
-                isArate = 1;
-
-    /*
-    * HAL needs to know whether the rate is basic rate or not, as it needs to 
-    * update the response rate table accordingly. e.g. if one of the 11a rates is
-    * basic rate, then that rate can be used for sending control frames.
-    * HAL updates the response rate table whenever basic rate set is changed.
-    */
-            if (basicOnly)
-            {
-                if (tempRateSet.rate[min] & 0x80)
-                {
-                    if (isArate)
-                        pRates->llaRates[aRateIndex++] = tempRateSet.rate[min];
-                    else
-                        pRates->llbRates[bRateIndex++] = tempRateSet.rate[min];
-                }
+        }
+        /*
+         * HAL needs to know whether the rate is basic rate or not,
+         * as it needs to update the response rate table accordingly.
+         * e.g. if one of the 11a rates is basic rate, then that rate
+         * can be used for sending control frames. HAL updates the
+         * response rate table whenever basic rate set is changed.
+         */
+        if (basicOnly && !(tempRateSet.rate[min] & 0x80)) {
+            limLog(pMac, LOG2, FL("Invalid basic rate"));
+        } else if (sirIsArate(tempRateSet.rate[min] & 0x7f)) {
+            if (aRateIndex >= SIR_NUM_11A_RATES) {
+                limLog(pMac, LOG2, FL("OOB, aRateIndex: %d"), aRateIndex);
+            } else if (aRateIndex >= 1 && (tempRateSet.rate[min] ==
+                   pRates->llaRates[aRateIndex - 1])) {
+                limLog(pMac, LOG2, FL("Duplicate 11a rate: %d"),
+                       tempRateSet.rate[min]);
+            } else {
+                pRates->llaRates[aRateIndex++] =
+                        tempRateSet.rate[min];
             }
-            else
-            {
-                if (isArate)
-                    pRates->llaRates[aRateIndex++] = tempRateSet.rate[min];
-                else
-                    pRates->llbRates[bRateIndex++] = tempRateSet.rate[min];
+        } else if (sirIsBrate(tempRateSet.rate[min] & 0x7f)) {
+            if (bRateIndex >= SIR_NUM_11B_RATES) {
+                limLog(pMac, LOG2, FL("OOB, bRateIndex: %d"), bRateIndex);
+            } else if (bRateIndex >= 1 && (tempRateSet.rate[min] ==
+                   pRates->llbRates[bRateIndex - 1])) {
+                limLog(pMac, LOG2, FL("Duplicate 11b rate: %d"),
+                       tempRateSet.rate[min]);
+            } else {
+                pRates->llbRates[bRateIndex++] =
+                        tempRateSet.rate[min];
             }
-            tempRateSet.rate[min] = 0xff;
+        } else {
+            limLog(pMac, LOG2, FL("%d is neither 11a nor 11b rate"),
+                   tempRateSet.rate[min]);
         }
+        tempRateSet.rate[min] = 0xff;
 
     }
 
