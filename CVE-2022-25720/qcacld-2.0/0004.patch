From b61faa63366b5d869e6aeebef7fb2759480b2cd9 Mon Sep 17 00:00:00 2001
From: hangtian <quic_hangtian@quicinc.com>
Date: Thu, 23 Dec 2021 15:06:57 +0800
Subject: [PATCH] qcacld-2.0: Fix array OOB for duplicate rate

Some IoT AP may have duplicate rates in supported rates and
extended rates in beacon, need filter them when populate peer 11a/11b
rates during connect/roaming, or array out of bound issue will happen.

Change-Id: Ie23aefa870b5d07aba9e389bcc736f7bebe54e96
CRs-Fixed: 3099598
---
 CORE/MAC/src/pe/lim/limAssocUtils.c | 93 ++++++++++++++---------------
 1 file changed, 46 insertions(+), 47 deletions(-)

diff --git a/CORE/MAC/src/pe/lim/limAssocUtils.c b/CORE/MAC/src/pe/lim/limAssocUtils.c
index 6226b5d74..3e4e6c9c0 100644
--- a/CORE/MAC/src/pe/lim/limAssocUtils.c
+++ b/CORE/MAC/src/pe/lim/limAssocUtils.c
@@ -1715,11 +1715,11 @@ limPopulateOwnRateSet(tpAniSirGlobal pMac,
 {
     tSirMacRateSet          tempRateSet;
     tSirMacRateSet          tempRateSet2;
-    tANI_U32                i,j,val,min,isArate;
+    tANI_U32                i,j,val,min;
     tANI_U32 phyMode = 0;
     tANI_U32 selfStaDot11Mode=0;
-
-    isArate = 0;
+    tANI_U8 aRateIndex = 0;
+    tANI_U8 bRateIndex = 0;
 
     wlan_cfgGetInt(pMac, WNI_CFG_DOT11_MODE, &selfStaDot11Mode);
     limGetPhyMode(pMac, &phyMode, psessionEntry);
@@ -1769,54 +1769,53 @@ limPopulateOwnRateSet(tpAniSirGlobal pMac,
      * Sort rates in tempRateSet (they are likely to be already sorted)
      * put the result in pSupportedRates
      */
-    {
-        tANI_U8 aRateIndex = 0;
-        tANI_U8 bRateIndex = 0;
-
-        vos_mem_set((tANI_U8 *) pRates, sizeof(tSirSupportedRates), 0);
-        for(i = 0;i < tempRateSet.numRates; i++)
-        {
-            min = 0;
-            val = 0xff;
-            isArate = 0;
-            for(j = 0; (j < tempRateSet.numRates) && (j < SIR_MAC_RATESET_EID_MAX); j++)
-            {
-                if ((tANI_U32) (tempRateSet.rate[j] & 0x7f) < val)
-                {
-                     val = tempRateSet.rate[j] & 0x7f;
-                     min = j;
-                }
+    vos_mem_set((tANI_U8 *) pRates, sizeof(tSirSupportedRates), 0);
+    for (i = 0; i < tempRateSet.numRates; i++) {
+        min = 0;
+        val = 0xff;
+        for (j = 0; (j < tempRateSet.numRates) &&
+             (j < SIR_MAC_RATESET_EID_MAX); j++) {
+            if ((tANI_U32)(tempRateSet.rate[j] & 0x7f) < val) {
+                val = tempRateSet.rate[j] & 0x7f;
+                min = j;
             }
-
-            if (sirIsArate(tempRateSet.rate[min] & 0x7f))
-                isArate = 1;
-
-    /*
-    * HAL needs to know whether the rate is basic rate or not, as it needs to
-    * update the response rate table accordingly. e.g. if one of the 11a rates is
-    * basic rate, then that rate can be used for sending control frames.
-    * HAL updates the response rate table whenever basic rate set is changed.
-    */
-            if (basicOnly)
-            {
-                if (tempRateSet.rate[min] & 0x80)
-                {
-                    if (isArate)
-                        pRates->llaRates[aRateIndex++] = tempRateSet.rate[min];
-                    else
-                        pRates->llbRates[bRateIndex++] = tempRateSet.rate[min];
-                }
+        }
+        /*
+         * HAL needs to know whether the rate is basic rate or not,
+         * as it needs to update the response rate table accordingly.
+         * e.g. if one of the 11a rates is basic rate, then that rate
+         * can be used for sending control frames. HAL updates the
+         * response rate table whenever basic rate set is changed.
+         */
+        if (basicOnly && !(tempRateSet.rate[min] & 0x80)) {
+            limLog(pMac, LOG2, FL("Invalid basic rate"));
+        } else if (sirIsArate(tempRateSet.rate[min] & 0x7f)) {
+            if (aRateIndex >= SIR_NUM_11A_RATES) {
+                limLog(pMac, LOG2, FL("OOB, aRateIndex: %d"), aRateIndex);
+            } else if (aRateIndex >= 1 && (tempRateSet.rate[min] ==
+                   pRates->llaRates[aRateIndex - 1])) {
+                limLog(pMac, LOG2, FL("Duplicate 11a rate: %d"),
+                       tempRateSet.rate[min]);
+            } else {
+                pRates->llaRates[aRateIndex++] =
+                        tempRateSet.rate[min];
             }
-            else
-            {
-                if (isArate)
-                    pRates->llaRates[aRateIndex++] = tempRateSet.rate[min];
-                else
-                    pRates->llbRates[bRateIndex++] = tempRateSet.rate[min];
+        } else if (sirIsBrate(tempRateSet.rate[min] & 0x7f)) {
+            if (bRateIndex >= SIR_NUM_11B_RATES) {
+                limLog(pMac, LOG2, FL("OOB, bRateIndex: %d"), bRateIndex);
+            } else if (bRateIndex >= 1 && (tempRateSet.rate[min] ==
+                   pRates->llbRates[bRateIndex - 1])) {
+                limLog(pMac, LOG2, FL("Duplicate 11b rate: %d"),
+                       tempRateSet.rate[min]);
+            } else {
+                pRates->llbRates[bRateIndex++] =
+                        tempRateSet.rate[min];
             }
-            tempRateSet.rate[min] = 0xff;
+        } else {
+            limLog(pMac, LOG2, FL("%d is neither 11a nor 11b rate"),
+                   tempRateSet.rate[min]);
         }
-
+        tempRateSet.rate[min] = 0xff;
     }
 
     if (IS_DOT11_MODE_HT(selfStaDot11Mode))
-- 
GitLab

