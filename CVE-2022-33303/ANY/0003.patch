From e7dcbdc4df83d51ed29929d1322d81bde3850c08 Mon Sep 17 00:00:00 2001
From: Elliot Berman <quic_eberman@quicinc.com>
Date: Mon, 2 May 2022 12:36:09 -0700
Subject: [PATCH] virt: gunyah: rm_core: Remove current_recv_buffer tracking

current_recv_buffer tracks the current end of an ongoing message from
resource manager. It can be easily tracked by "conection->recv_buff +
connection->recv_buff_size". Do that instead to make code clearer.

Change-Id: I191dbdbf39c802868e1c6a262ef5420c02f127b2
Signed-off-by: Elliot Berman <quic_eberman@quicinc.com>
---
 drivers/virt/gunyah/gh_rm_core.c | 14 ++++++--------
 1 file changed, 6 insertions(+), 8 deletions(-)

diff --git a/drivers/virt/gunyah/gh_rm_core.c b/drivers/virt/gunyah/gh_rm_core.c
index da199701aa674..6fd00eeb3f355 100644
--- a/drivers/virt/gunyah/gh_rm_core.c
+++ b/drivers/virt/gunyah/gh_rm_core.c
@@ -46,7 +46,6 @@ struct gh_rm_connection {
 
 	u8 num_fragments;
 	u8 fragments_received;
-	void *current_recv_buff;
 };
 
 struct gh_rm_notif_validate {
@@ -141,6 +140,10 @@ gh_rm_init_connection_buff(struct gh_rm_connection *connection,
 	struct gh_rm_rpc_hdr *hdr = recv_buff;
 	size_t max_buf_size;
 
+	connection->num_fragments = hdr->fragments;
+	connection->fragments_received = 0;
+	connection->type = hdr->type;
+
 	/* Some of the 'reply' types doesn't contain any payload */
 	if (!payload_size)
 		return 0;
@@ -156,16 +159,12 @@ gh_rm_init_connection_buff(struct gh_rm_connection *connection,
 	/* If the data is split into multiple fragments, allocate a large
 	 * enough buffer to hold the payloads for all the fragments.
 	 */
-	connection->recv_buff = connection->current_recv_buff =
-				kzalloc(max_buf_size, GFP_KERNEL);
+	connection->recv_buff = kzalloc(max_buf_size, GFP_KERNEL);
 	if (!connection->recv_buff)
 		return -ENOMEM;
 
 	memcpy(connection->recv_buff, recv_buff + hdr_size, payload_size);
-	connection->current_recv_buff += payload_size;
 	connection->recv_buff_size = payload_size;
-	connection->num_fragments = hdr->fragments;
-	connection->type = hdr->type;
 
 	return 0;
 }
@@ -443,9 +442,8 @@ static int gh_rm_process_cont(struct gh_rm_connection *connection,
 	payload_size = recv_buff_size - sizeof(*hdr);
 
 	/* Keep appending the data to the previous fragment's end */
-	memcpy(connection->current_recv_buff,
+	memcpy(connection->recv_buff + connection->recv_buff_size,
 		recv_buff + sizeof(*hdr), payload_size);
-	connection->current_recv_buff += payload_size;
 	connection->recv_buff_size += payload_size;
 
 	if (++connection->fragments_received ==
-- 
GitLab

