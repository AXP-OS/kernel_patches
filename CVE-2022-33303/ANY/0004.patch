From f8532d564cd5d3d91e3edceb700f7a8cd15266df Mon Sep 17 00:00:00 2001
From: Elliot Berman <quic_eberman@quicinc.com>
Date: Mon, 2 May 2022 12:41:19 -0700
Subject: [PATCH] virt: gunyah: rm_core: Rename connection variables

Rename "recv_buff" and "recv_buff_size" to "payload" and "size",
respectively. gh_rm_connection on tracks received buffers, so it is
redundant to add "recv". Rename "reply_err_code" to "rm_error" to make
it clear that this field is used for the resource manager's return error
code, and not some other value. While here, re-org and document the
gh_rm_connection struct.

Change-Id: I101262dd907a0e678d8d2c5232a17745f057edaf
Signed-off-by: Elliot Berman <quic_eberman@quicinc.com>
---
 drivers/virt/gunyah/gh_rm_core.c | 67 +++++++++++++++++++-------------
 1 file changed, 39 insertions(+), 28 deletions(-)

diff --git a/drivers/virt/gunyah/gh_rm_core.c b/drivers/virt/gunyah/gh_rm_core.c
index 6fd00eeb3f355..51efb61da5d3f 100644
--- a/drivers/virt/gunyah/gh_rm_core.c
+++ b/drivers/virt/gunyah/gh_rm_core.c
@@ -34,18 +34,30 @@
 #define GH_RM_MAX_MSG_SIZE_BYTES \
 	(GH_MSGQ_MAX_MSG_SIZE_BYTES - sizeof(struct gh_rm_rpc_hdr))
 
+/**
+ * struct gh_rm_connection - Represents a complete message from resource manager
+ * @payload: Combined payload of all the fragments without any RPC headers
+ * @size: Size of the payload.
+ * @msg_id: Message ID from the header.
+ * @type: GH_RM_RPC_TYPE_RPLY or GH_RM_RPC_TYPE_NOTIF.
+ * @num_fragments: total number of fragments expected to be received for this connection.
+ * @fragments_received: fragments received so far.
+ * @rm_error: For request/reply sequences with standard replies.
+ * @seq: Sequence ID for the main message.
+ */
 struct gh_rm_connection {
+	void *payload;
+	size_t size;
 	u32 msg_id;
-	u16 seq;
 	u8 type;
-	void *recv_buff;
-	u32 reply_err_code;
-	size_t recv_buff_size;
-
-	struct completion seq_done;
 
 	u8 num_fragments;
 	u8 fragments_received;
+
+	/* only for req/reply sequence */
+	u32 rm_error;
+	u16 seq;
+	struct completion seq_done;
 };
 
 struct gh_rm_notif_validate {
@@ -159,12 +171,12 @@ gh_rm_init_connection_buff(struct gh_rm_connection *connection,
 	/* If the data is split into multiple fragments, allocate a large
 	 * enough buffer to hold the payloads for all the fragments.
 	 */
-	connection->recv_buff = kzalloc(max_buf_size, GFP_KERNEL);
-	if (!connection->recv_buff)
+	connection->payload = kzalloc(max_buf_size, GFP_KERNEL);
+	if (!connection->payload)
 		return -ENOMEM;
 
-	memcpy(connection->recv_buff, recv_buff + hdr_size, payload_size);
-	connection->recv_buff_size = payload_size;
+	memcpy(connection->payload, recv_buff + hdr_size, payload_size);
+	connection->size = payload_size;
 
 	return 0;
 }
@@ -229,8 +241,8 @@ static void gh_rm_validate_notif(struct work_struct *work)
 
 	validate_work = container_of(work, struct gh_rm_notif_validate, work);
 	connection = validate_work->conn;
-	payload = connection->recv_buff;
-	payload_size = connection->recv_buff_size;
+	payload = connection->payload;
+	payload_size = connection->size;
 	notification = connection->msg_id;
 	pr_debug("Notification received from RM-VM: %x\n", notification);
 
@@ -390,7 +402,7 @@ struct gh_rm_connection *gh_rm_process_rply(void *recv_buff, size_t recv_buff_si
 	if (ret < 0)
 		return ERR_PTR(ret);
 
-	connection->reply_err_code = reply_hdr->err_code;
+	connection->rm_error = reply_hdr->err_code;
 
 	/*
 	 * If the data is composed of a single message, wakeup the
@@ -442,9 +454,8 @@ static int gh_rm_process_cont(struct gh_rm_connection *connection,
 	payload_size = recv_buff_size - sizeof(*hdr);
 
 	/* Keep appending the data to the previous fragment's end */
-	memcpy(connection->recv_buff + connection->recv_buff_size,
-		recv_buff + sizeof(*hdr), payload_size);
-	connection->recv_buff_size += payload_size;
+	memcpy(connection->payload + connection->size, recv_buff + sizeof(*hdr), payload_size);
+	connection->size += payload_size;
 
 	if (++connection->fragments_received ==
 					connection->num_fragments) {
@@ -452,7 +463,7 @@ static int gh_rm_process_cont(struct gh_rm_connection *connection,
 		case GH_RM_RPC_TYPE_RPLY:
 			complete(&connection->seq_done);
 			/* All the processing functions would have trimmed-off the header
-			 * and copied the data to connection->recv_buff. Hence, it's okay
+			 * and copied the data to connection->payload. Hence, it's okay
 			 * to release the original packet that arrived.
 			 */
 			kfree(recv_buff);
@@ -624,7 +635,7 @@ static int gh_rm_send_request(u32 message_id,
  * @req_buff: Request buffer that contains the payload
  * @req_buff_size: Total size of the payload
  * @resp_buff_size: Size of the response buffer
- * @reply_err_code: Returns Gunyah standard error code for the response
+ * @rm_error: Returns Gunyah standard error code for the response
  *
  * Make a request to the RM-VM and expect a reply back. For a successful
  * response, the function returns the payload and its size for the response.
@@ -636,14 +647,14 @@ static int gh_rm_send_request(u32 message_id,
  */
 void *gh_rm_call(gh_rm_msgid_t message_id,
 			void *req_buff, size_t req_buff_size,
-			size_t *resp_buff_size, int *reply_err_code)
+			size_t *resp_buff_size, int *rm_error)
 {
 	struct gh_rm_connection *connection;
 	bool seq_done_needed = true;
 	int req_ret;
 	void *ret;
 
-	if (!message_id || !req_buff || !resp_buff_size || !reply_err_code)
+	if (!message_id || !req_buff || !resp_buff_size || !rm_error)
 		return ERR_PTR(-EINVAL);
 
 	connection = gh_rm_alloc_connection(message_id, seq_done_needed);
@@ -675,25 +686,25 @@ void *gh_rm_call(gh_rm_msgid_t message_id,
 	/* Wait for response */
 	wait_for_completion(&connection->seq_done);
 
-	*reply_err_code = connection->reply_err_code;
-	if (connection->reply_err_code) {
+	*rm_error = connection->rm_error;
+	if (connection->rm_error) {
 		pr_err("%s: Reply for seq:%d failed with RM err: %d\n",
-			__func__, connection->seq, connection->reply_err_code);
-		ret = ERR_PTR(gh_remap_error(connection->reply_err_code));
-		kfree(connection->recv_buff);
+			__func__, connection->seq, connection->rm_error);
+		ret = ERR_PTR(gh_remap_error(connection->rm_error));
+		kfree(connection->payload);
 		goto out;
 	}
 
 	print_hex_dump_debug("gh_rm_call RX: ", DUMP_PREFIX_OFFSET, 4, 1,
-			     connection->recv_buff, connection->recv_buff_size,
+			     connection->payload, connection->size,
 			     false);
 
 	mutex_lock(&gh_rm_call_idr_lock);
 	idr_remove(&gh_rm_call_idr, connection->seq);
 	mutex_unlock(&gh_rm_call_idr_lock);
 
-	ret = connection->recv_buff;
-	*resp_buff_size = connection->recv_buff_size;
+	ret = connection->payload;
+	*resp_buff_size = connection->size;
 
 out:
 	kfree(connection);
-- 
GitLab

