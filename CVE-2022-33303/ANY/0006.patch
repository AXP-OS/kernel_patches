From b9d45e26feb9d9ed12a089977bb21a03ed3021be Mon Sep 17 00:00:00 2001
From: Elliot Berman <quic_eberman@quicinc.com>
Date: Mon, 2 May 2022 14:14:29 -0700
Subject: [PATCH] virt: gunyah: rm_core: Guard against unexpected messages

Gracefully handle non-standard sequences of messages such as
continuation messages without receiving a reply/notification message
first, or a new reply/notification message without having finished the
last message sequence.

Change-Id: I52922fc9ccefb1f7dbb40fbffd2ad6b7fd1162b7
Signed-off-by: Elliot Berman <quic_eberman@quicinc.com>
---
 drivers/virt/gunyah/gh_rm_core.c | 47 ++++++++++++++++++++++++++++----
 1 file changed, 41 insertions(+), 6 deletions(-)

diff --git a/drivers/virt/gunyah/gh_rm_core.c b/drivers/virt/gunyah/gh_rm_core.c
index 63096d7ff7032..ddf17b8ab5634 100644
--- a/drivers/virt/gunyah/gh_rm_core.c
+++ b/drivers/virt/gunyah/gh_rm_core.c
@@ -39,6 +39,7 @@
  * @payload: Combined payload of all the fragments without any RPC headers
  * @size: Size of the payload.
  * @msg_id: Message ID from the header.
+ * @ret: Linux return code, set in case there was an error processing the connection.
  * @type: GH_RM_RPC_TYPE_RPLY or GH_RM_RPC_TYPE_NOTIF.
  * @num_fragments: total number of fragments expected to be received for this connection.
  * @fragments_received: fragments received so far.
@@ -49,6 +50,7 @@ struct gh_rm_connection {
 	void *payload;
 	size_t size;
 	u32 msg_id;
+	int ret;
 	u8 type;
 
 	u8 num_fragments;
@@ -472,6 +474,21 @@ static bool gh_rm_complete_connection(struct gh_rm_connection *connection)
 	return true;
 }
 
+static void gh_rm_abort_connection(struct gh_rm_connection *connection)
+{
+	switch (connection->type) {
+	case GH_RM_RPC_TYPE_RPLY:
+		connection->ret = -EIO;
+		complete(&connection->seq_done);
+		break;
+	case GH_RM_RPC_TYPE_NOTIF:
+		fallthrough;
+	default:
+		kfree(connection->payload);
+		kfree(connection);
+	}
+}
+
 static int gh_rm_recv_task_fn(void *data)
 {
 	struct gh_rm_connection *connection = NULL;
@@ -503,16 +520,28 @@ static int gh_rm_recv_task_fn(void *data)
 		hdr = recv_buff;
 		switch (hdr->type) {
 		case GH_RM_RPC_TYPE_NOTIF:
-			connection = gh_rm_process_notif(recv_buff,
-							recv_buff_size);
+			if (connection) {
+				/* Not possible per protocol. Do something better than BUG_ON */
+				pr_warn("Received start of new notification without finishing existing message series.\n");
+				gh_rm_abort_connection(connection);
+			}
+			connection = gh_rm_process_notif(recv_buff, recv_buff_size);
 			break;
 		case GH_RM_RPC_TYPE_RPLY:
-			connection = gh_rm_process_rply(recv_buff,
-							recv_buff_size);
+			if (connection) {
+				/* Not possible per protocol. Do something better than BUG_ON */
+				pr_warn("Received start of new reply without finishing existing message series.\n");
+				gh_rm_abort_connection(connection);
+			}
+			connection = gh_rm_process_rply(recv_buff, recv_buff_size);
 			break;
 		case GH_RM_RPC_TYPE_CONT:
-			gh_rm_process_cont(connection, recv_buff,
-							recv_buff_size);
+			if (!connection) {
+				/* Not possible per protocol. Do something better than BUG_ON */
+				pr_warn("Received a continuation message without receiving initial message\n");
+				break;
+			}
+			gh_rm_process_cont(connection, recv_buff, recv_buff_size);
 			break;
 		default:
 			pr_err("%s: Invalid message type (%d) received\n",
@@ -683,6 +712,12 @@ void *gh_rm_call(gh_rm_msgid_t message_id,
 		goto out;
 	}
 
+	if (connection->ret) {
+		ret = ERR_PTR(connection->ret);
+		kfree(connection->payload);
+		goto out;
+	}
+
 	print_hex_dump_debug("gh_rm_call RX: ", DUMP_PREFIX_OFFSET, 4, 1,
 			     connection->payload, connection->size,
 			     false);
-- 
GitLab

