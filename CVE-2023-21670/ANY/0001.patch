From 72e14447dd0cd6feed37de1b3caf79d0fa44fc67 Mon Sep 17 00:00:00 2001
From: Akhil P Oommen <quic_akhilpo@quicinc.com>
Date: Tue, 28 Mar 2023 19:43:27 +0530
Subject: [PATCH] msm: kgsl: Keep postamble packets in a privileged buffer

Postamble packets are executed in privileged mode by gpu. So we should keep
them in a privileged scratch buffer to block userspace access. For
targets with APRIV feature support, we can mark the preemption scratch
buffer as privileged too to avoid similar issues in future.

Change-Id: Ifda360dda251083f38dfde80ce1b5dc83daae902
Signed-off-by: Akhil P Oommen <quic_akhilpo@quicinc.com>
Signed-off-by: Kaushal Sanadhya <quic_ksanadhy@quicinc.com>
---
 drivers/gpu/msm/adreno.h              |  2 --
 drivers/gpu/msm/adreno_a6xx_preempt.c | 18 +++++++++---------
 drivers/gpu/msm/adreno_gen7.c         |  4 ++--
 drivers/gpu/msm/adreno_gen7_preempt.c | 27 ++++++++++++++-------------
 drivers/gpu/msm/kgsl.h                |  7 ++++++-
 5 files changed, 31 insertions(+), 27 deletions(-)

diff --git a/drivers/gpu/msm/adreno.h b/drivers/gpu/msm/adreno.h
index 48481fbf2512a..75374c78be9a1 100644
--- a/drivers/gpu/msm/adreno.h
+++ b/drivers/gpu/msm/adreno.h
@@ -28,8 +28,6 @@
 /* Used to inform CP where to save preemption counter data at the time of switch out */
 #define SET_PSEUDO_COUNTER 4
 
-/* Index to preemption scratch buffer to store KMD postamble */
-#define KMD_POSTAMBLE_IDX 100
 /* Index to preemption scratch buffer to store current QOS value */
 #define QOS_VALUE_IDX KGSL_PRIORITY_MAX_RB_LEVELS
 
diff --git a/drivers/gpu/msm/adreno_a6xx_preempt.c b/drivers/gpu/msm/adreno_a6xx_preempt.c
index 51b7c255c7541..515504792e3c6 100644
--- a/drivers/gpu/msm/adreno_a6xx_preempt.c
+++ b/drivers/gpu/msm/adreno_a6xx_preempt.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include "adreno.h"
@@ -542,9 +542,7 @@ u32 a6xx_preemption_pre_ibsubmit(struct adreno_device *adreno_dev,
 
 		/* Add a KMD post amble to clear the perf counters during preemption */
 		if (!adreno_dev->perfcounter) {
-			u64 kmd_postamble_addr =
-					PREEMPT_SCRATCH_ADDR(adreno_dev, KMD_POSTAMBLE_IDX);
-
+			u64 kmd_postamble_addr = SCRATCH_POSTAMBLE_ADDR(KGSL_DEVICE(adreno_dev));
 			*cmds++ = cp_type7_packet(CP_SET_AMBLE, 3);
 			*cmds++ = lower_32_bits(kmd_postamble_addr);
 			*cmds++ = upper_32_bits(kmd_postamble_addr);
@@ -696,6 +694,7 @@ static int a6xx_preemption_ringbuffer_init(struct adreno_device *adreno_dev,
 
 int a6xx_preemption_init(struct adreno_device *adreno_dev)
 {
+	u32 flags = ADRENO_FEATURE(adreno_dev, ADRENO_APRIV) ? KGSL_MEMDESC_PRIVILEGED : 0;
 	struct kgsl_device *device = KGSL_DEVICE(adreno_dev);
 	struct kgsl_iommu *iommu = KGSL_IOMMU(device);
 	struct adreno_preemption *preempt = &adreno_dev->preempt;
@@ -717,7 +716,7 @@ int a6xx_preemption_init(struct adreno_device *adreno_dev)
 	}
 
 	ret = adreno_allocate_global(device, &preempt->scratch,
-		PAGE_SIZE, 0, 0, 0, "preempt_scratch");
+		PAGE_SIZE, 0, 0, flags, "preempt_scratch");
 	if (ret)
 		return ret;
 
@@ -731,12 +730,13 @@ int a6xx_preemption_init(struct adreno_device *adreno_dev)
 	}
 
 	/*
-	 * First 8 dwords of the preemption scratch buffer is used to store the address for CP
-	 * to save/restore VPC data. Reserve 11 dwords in the preemption scratch buffer from
-	 * index KMD_POSTAMBLE_IDX for KMD postamble pm4 packets
+	 * First 28 dwords of the device scratch buffer are used to store shadow rb data.
+	 * Reserve 11 dwords in the device scratch buffer from SCRATCH_POSTAMBLE_OFFSET for
+	 * KMD postamble pm4 packets. This should be in *device->scratch* so that userspace
+	 * cannot access it.
 	 */
 	if (!adreno_dev->perfcounter) {
-		u32 *postamble = preempt->scratch->hostptr + (KMD_POSTAMBLE_IDX * sizeof(u64));
+		u32 *postamble = device->scratch->hostptr + SCRATCH_POSTAMBLE_OFFSET;
 		u32 count = 0;
 
 		postamble[count++] = cp_type7_packet(CP_REG_RMW, 3);
diff --git a/drivers/gpu/msm/adreno_gen7.c b/drivers/gpu/msm/adreno_gen7.c
index 552abffe08a7e..f8d0d758b5701 100644
--- a/drivers/gpu/msm/adreno_gen7.c
+++ b/drivers/gpu/msm/adreno_gen7.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/io.h>
@@ -668,7 +668,7 @@ static int gen7_post_start(struct adreno_device *adreno_dev)
 	if (!adreno_is_preemption_enabled(adreno_dev))
 		return 0;
 
-	kmd_postamble_addr = PREEMPT_SCRATCH_ADDR(adreno_dev, KMD_POSTAMBLE_IDX);
+	kmd_postamble_addr = SCRATCH_POSTAMBLE_ADDR(KGSL_DEVICE(adreno_dev));
 	gen7_preemption_prepare_postamble(adreno_dev);
 
 	cmds = adreno_ringbuffer_allocspace(rb, (preempt->postamble_len ? 16 : 12));
diff --git a/drivers/gpu/msm/adreno_gen7_preempt.c b/drivers/gpu/msm/adreno_gen7_preempt.c
index f1493ad72a89d..840ce1a87383e 100644
--- a/drivers/gpu/msm/adreno_gen7_preempt.c
+++ b/drivers/gpu/msm/adreno_gen7_preempt.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include "adreno.h"
@@ -450,19 +450,20 @@ void gen7_preemption_callback(struct adreno_device *adreno_dev, int bit)
 
 void gen7_preemption_prepare_postamble(struct adreno_device *adreno_dev)
 {
+	struct kgsl_device *device = KGSL_DEVICE(adreno_dev);
 	const struct adreno_gen7_core *gen7_core = to_gen7_core(adreno_dev);
 	struct adreno_preemption *preempt = &adreno_dev->preempt;
 	u32 *postamble, count = 0;
 
-	postamble = preempt->scratch->hostptr +
-		PREEMPT_SCRATCH_OFFSET(KMD_POSTAMBLE_IDX);
-
 	/*
-	 * First 8 dwords of the preemption scratch buffer is used to store
-	 * the address for CP to save/restore VPC data. Reserve 11 dwords in
-	 * the preemption scratch buffer from index KMD_POSTAMBLE_IDX to clear
-	 * perfcounters.
+	 * First 28 dwords of the device scratch buffer are used to store shadow rb data.
+	 * Reserve 15 dwords in the device scratch buffer from SCRATCH_POSTAMBLE_OFFSET for
+	 * KMD postamble pm4 packets. This should be in *device->scratch* so that userspace
+	 * cannot access it.
 	 */
+	postamble = device->scratch->hostptr + SCRATCH_POSTAMBLE_OFFSET;
+
+	/* Reserve 11 dwords in the device scratch buffer to clear perfcounters */
 	if (!adreno_dev->perfcounter) {
 		postamble[count++] = cp_type7_packet(CP_REG_RMW, 3);
 		postamble[count++] = GEN7_RBBM_PERFCTR_SRAM_INIT_CMD;
@@ -479,8 +480,8 @@ void gen7_preemption_prepare_postamble(struct adreno_device *adreno_dev)
 	}
 
 	/*
-	 * Reserve 4 more dwords in preemption scratch buffer for dynamic QOS
-	 * control feature.
+	 * Reserve 4 dwords in the scratch buffer for dynamic QOS control feature. To ensure QOS
+	 * value is updated for first preemption, send it during bootup.
 	 */
 	if (gen7_core->qos_value) {
 		postamble[count++] = cp_type7_packet(CP_MEM_TO_REG, 3);
@@ -560,8 +561,7 @@ u32 gen7_preemption_pre_ibsubmit(struct adreno_device *adreno_dev,
 		*cmds++ = upper_32_bits(gpuaddr);
 
 		if (adreno_dev->preempt.postamble_len) {
-			u64 kmd_postamble_addr =
-					PREEMPT_SCRATCH_ADDR(adreno_dev, KMD_POSTAMBLE_IDX);
+			u64 kmd_postamble_addr = SCRATCH_POSTAMBLE_ADDR(KGSL_DEVICE(adreno_dev));
 
 			*cmds++ = cp_type7_packet(CP_SET_AMBLE, 3);
 			*cmds++ = lower_32_bits(kmd_postamble_addr);
@@ -719,6 +719,7 @@ static int gen7_preemption_ringbuffer_init(struct adreno_device *adreno_dev,
 
 int gen7_preemption_init(struct adreno_device *adreno_dev)
 {
+	u32 flags = ADRENO_FEATURE(adreno_dev, ADRENO_APRIV) ? KGSL_MEMDESC_PRIVILEGED : 0;
 	struct kgsl_device *device = KGSL_DEVICE(adreno_dev);
 	struct kgsl_iommu *iommu = KGSL_IOMMU(device);
 	struct adreno_preemption *preempt = &adreno_dev->preempt;
@@ -740,7 +741,7 @@ int gen7_preemption_init(struct adreno_device *adreno_dev)
 	}
 
 	ret = adreno_allocate_global(device, &preempt->scratch, PAGE_SIZE,
-			0, 0, 0, "preempt_scratch");
+			0, 0, flags, "preempt_scratch");
 	if (ret)
 		return ret;
 
diff --git a/drivers/gpu/msm/kgsl.h b/drivers/gpu/msm/kgsl.h
index d8dc8d260071a..111e2982170c2 100644
--- a/drivers/gpu/msm/kgsl.h
+++ b/drivers/gpu/msm/kgsl.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2008-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 #ifndef __KGSL_H
 #define __KGSL_H
@@ -90,6 +90,11 @@ struct adreno_rb_shadow {
 #define SCRATCH_RB_GPU_ADDR(dev, id, _field) \
 	((dev)->scratch->gpuaddr + SCRATCH_RB_OFFSET(id, _field))
 
+/* OFFSET to KMD postamble packets in scratch buffer */
+#define SCRATCH_POSTAMBLE_OFFSET (100 * sizeof(u64))
+#define SCRATCH_POSTAMBLE_ADDR(dev) \
+	((dev)->scratch->gpuaddr + SCRATCH_POSTAMBLE_OFFSET)
+
 /* Timestamp window used to detect rollovers (half of integer range) */
 #define KGSL_TIMESTAMP_WINDOW 0x80000000
 
-- 
GitLab

