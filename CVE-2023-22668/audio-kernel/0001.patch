From 9e0c5feb300272820a543dc79dee7e54a74e9da0 Mon Sep 17 00:00:00 2001
From: Kogara Naveen Kumar <quic_nkogara@quicinc.com>
Date: Thu, 9 Feb 2023 14:16:16 +0530
Subject: [PATCH] dsp: add lock in ion free to avoid use after free

add lock in ion free to protect dma buff and avoid
use after free.

Change-Id: I0b0b231d1f3c507e370dbebf1aec598a9da2f8d3
---
 dsp/msm_audio_ion.c | 30 +++++++++++++++++++++---------
 1 file changed, 21 insertions(+), 9 deletions(-)

diff --git a/dsp/msm_audio_ion.c b/dsp/msm_audio_ion.c
index 150aab9c..4dd2d195 100755
--- a/dsp/msm_audio_ion.c
+++ b/dsp/msm_audio_ion.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022, 2023 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/init.h>
@@ -114,6 +114,7 @@ static void msm_audio_ion_add_allocation(
 	mutex_unlock(&(msm_audio_ion_data->list_mutex));
 }
 
+/* This function is called with ion_data list mutex lock */
 static void *msm_audio_ion_map_kernel(struct dma_buf *dma_buf)
 {
 	int rc = 0;
@@ -151,6 +152,7 @@ exit:
 	return addr;
 }
 
+/* This function is called with ion_data list mutex lock */
 static int msm_audio_dma_buf_map(struct dma_buf *dma_buf,
 				 dma_addr_t *addr, size_t *len, bool is_iova,
 				 bool cma_mem)
@@ -260,7 +262,6 @@ static int msm_audio_dma_buf_unmap(struct dma_buf *dma_buf, bool cma_mem)
 	 * should be explicitly acquired to avoid race condition
 	 * on adding elements to the list.
 	 */
-	mutex_lock(&(msm_audio_ion_data.list_mutex));
 	list_for_each_safe(ptr, next,
 			    &(msm_audio_ion_data.alloc_list)) {
 
@@ -284,7 +285,6 @@ static int msm_audio_dma_buf_unmap(struct dma_buf *dma_buf, bool cma_mem)
 			break;
 		}
 	}
-	mutex_unlock(&(msm_audio_ion_data.list_mutex));
 
 	if (!found) {
 		dev_err(cb_dev,
@@ -370,7 +370,6 @@ static int msm_audio_ion_unmap_kernel(struct dma_buf *dma_buf)
 	 * TBD: remove the below section once new API
 	 * for unmapping kernel virtual address is available.
 	 */
-	mutex_lock(&(msm_audio_ion_data.list_mutex));
 	list_for_each_entry(alloc_data, &(msm_audio_ion_data.alloc_list),
 			    list) {
 		if (alloc_data->dma_buf == dma_buf) {
@@ -378,7 +377,6 @@ static int msm_audio_ion_unmap_kernel(struct dma_buf *dma_buf)
 			break;
 		}
 	}
-	mutex_unlock(&(msm_audio_ion_data.list_mutex));
 
 	if (!vaddr) {
 		dev_err(cb_dev,
@@ -401,7 +399,8 @@ err:
 	return rc;
 }
 
-static int msm_audio_ion_map_buf(struct dma_buf *dma_buf, dma_addr_t *paddr,
+/* This function is called with ion_data list mutex lock */
+static int msm_audio_ion_buf_map(struct dma_buf *dma_buf, dma_addr_t *paddr,
 				 size_t *plen, void **vaddr)
 {
 	int rc = 0;
@@ -424,7 +423,9 @@ static int msm_audio_ion_map_buf(struct dma_buf *dma_buf, dma_addr_t *paddr,
 	if (IS_ERR_OR_NULL(*vaddr)) {
 		pr_err("%s: ION memory mapping for AUDIO failed\n", __func__);
 		rc = -ENOMEM;
+		mutex_lock(&(msm_audio_ion_data.list_mutex));
 		msm_audio_dma_buf_unmap(dma_buf, false);
+		mutex_unlock(&(msm_audio_ion_data.list_mutex));
 		goto err;
 	}
 
@@ -484,7 +485,7 @@ int spf_msm_audio_ion_alloc(struct dma_buf **dma_buf, size_t bufsz,
 		goto err;
 	}
 
-	rc = msm_audio_ion_map_buf(*dma_buf, paddr, plen, vaddr);
+	rc = msm_audio_ion_buf_map(*dma_buf, paddr, plen, vaddr);
 	if (rc) {
 		pr_err("%s: failed to map ION buf, rc = %d\n", __func__, rc);
 		goto err;
@@ -597,6 +598,11 @@ void msm_audio_delete_fd_entry(void *handle)
 	struct msm_audio_fd_data *msm_audio_fd_data = NULL;
 	struct list_head *ptr, *next;
 
+	if (!handle) {
+		pr_err("%s Invalid handle\n", __func__);
+		return;
+	}
+
 	mutex_lock(&(msm_audio_ion_fd_list.list_mutex));
 	list_for_each_safe(ptr, next,
 			&msm_audio_ion_fd_list.fd_list) {
@@ -647,6 +653,7 @@ void msm_audio_get_handle(int fd, void **handle)
 
 	pr_debug("%s fd %d\n", __func__, fd);
 	mutex_lock(&(msm_audio_ion_fd_list.list_mutex));
+	*handle = NULL;
 	list_for_each_entry(msm_audio_fd_data,
 			&msm_audio_ion_fd_list.fd_list, list) {
 		if (msm_audio_fd_data->fd == fd) {
@@ -706,7 +713,7 @@ int spf_msm_audio_ion_import(struct dma_buf **dma_buf, int fd,
 		}
 	}
 
-	rc = msm_audio_ion_map_buf(*dma_buf, paddr, plen, vaddr);
+	rc = msm_audio_ion_buf_map(*dma_buf, paddr, plen, vaddr);
 	if (rc) {
 		pr_err("%s: failed to map ION buf, rc = %d\n", __func__, rc);
 		goto err;
@@ -793,6 +800,7 @@ EXPORT_SYMBOL(spf_msm_audio_ion_import_cma);
  *
  * Returns 0 on success or error on failure
  */
+/* This function is called with ion_data list mutex lock */
 int spf_msm_audio_ion_free(struct dma_buf *dma_buf)
 {
 	int ret = 0;
@@ -802,12 +810,16 @@ int spf_msm_audio_ion_free(struct dma_buf *dma_buf)
 		return -EINVAL;
 	}
 
+	mutex_lock(&(msm_audio_ion_data.list_mutex));
 	ret = msm_audio_ion_unmap_kernel(dma_buf);
-	if (ret)
+	if (ret) {
+		mutex_unlock(&(msm_audio_ion_data.list_mutex));
 		return ret;
+	}
 
 	msm_audio_dma_buf_unmap(dma_buf, false);
 
+	mutex_unlock(&(msm_audio_ion_data.list_mutex));
 	return 0;
 }
 EXPORT_SYMBOL(spf_msm_audio_ion_free);
-- 
GitLab

