diff --git a/drivers/media/platform/camx/cam_cdm/cam_cdm_util.c b/drivers/media/platform/camx/cam_cdm/cam_cdm_util.c
index 4897ec01..73d4a3d 100644
--- a/drivers/media/platform/camx/cam_cdm/cam_cdm_util.c
+++ b/drivers/media/platform/camx/cam_cdm/cam_cdm_util.c
@@ -21,6 +21,7 @@
 #include "cam_cdm_virtual.h"
 #include "cam_cdm.h"
 #include "cam_io_util.h"
+#include "cam_common_util.h"
 
 #define CAM_CDM_DWORD 4
 
@@ -272,11 +273,13 @@
 }
 
 static int cam_cdm_util_reg_cont_write(void __iomem *base_addr,
-	uint32_t *cmd_buf, uint32_t cmd_buf_size, uint32_t *used_bytes)
+	uint32_t *cmd_buf, uint32_t cmd_buf_size, uint32_t *used_bytes,
+	uint32_t base_array_size,
+	struct cam_soc_reg_map *base_table[CAM_SOC_MAX_BLOCK])
 {
-	int ret = 0;
-	uint32_t *data;
-	struct cdm_regcontinuous_cmd *reg_cont;
+	uint32_t *data, i;
+	struct cdm_regcontinuous_cmd reg_cont;
+	resource_size_t size = 0;
 
 	if (cmd_buf_size < cdm_get_cmd_header_size(CAM_CDM_CMD_REG_CONT) ||
 	    !base_addr) {
@@ -285,95 +288,168 @@
 		return -EINVAL;
 	}
 
-	reg_cont = (struct cdm_regcontinuous_cmd *)cmd_buf;
-	if (!reg_cont->count ||
-	    reg_cont->count * sizeof(uint32_t) +
-	     cdm_get_cmd_header_size(CAM_CDM_CMD_REG_CONT) > cmd_buf_size) {
-		CAM_ERR(CAM_CDM, "buffer size %d is not sufficient for count%d",
-			cmd_buf_size, reg_cont->count);
+	memcpy(&reg_cont, cmd_buf, sizeof(struct cdm_regcontinuous_cmd));
+	for (i = 0; i < base_array_size; i++) {
+		if ((base_table[i]) &&
+			((base_table[i])->mem_base == base_addr)) {
+			size = (base_table[i])->size;
+			break;
+		}
+	}
+
+	if (size == 0) {
+		CAM_ERR(CAM_CDM, "Could not retrieve ioremap size, address not mapped!");
 		return -EINVAL;
 	}
+
+	if ((!reg_cont.count) || (((reg_cont.count * sizeof(uint32_t)) +
+	     cdm_get_cmd_header_size(CAM_CDM_CMD_REG_CONT)) > cmd_buf_size)) {
+		CAM_ERR(CAM_CDM, "buffer size %d is not sufficient for count%d",
+			cmd_buf_size, reg_cont.count);
+		return -EINVAL;
+	}
+
 	data = cmd_buf + cdm_get_cmd_header_size(CAM_CDM_CMD_REG_CONT);
-	cam_io_memcpy(base_addr + reg_cont->offset,	data,
-		reg_cont->count * sizeof(uint32_t));
 
-	*used_bytes = reg_cont->count * sizeof(uint32_t) +
+	if ((reg_cont.offset <= size) && ((reg_cont.offset +
+		(reg_cont.count * sizeof(uint32_t))) <= size)) {
+		cam_io_memcpy(base_addr + reg_cont.offset,	data,
+			reg_cont.count * sizeof(uint32_t));
+	} else {
+		CAM_ERR(CAM_CDM, "Offset out of mapped range! size: %lu, offset: %u",
+			size, reg_cont.offset);
+		return -EINVAL;
+	}
+
+	*used_bytes = reg_cont.count * sizeof(uint32_t) +
 		      cdm_get_cmd_header_size(CAM_CDM_CMD_REG_CONT) * 4;
-
-	return ret;
+	return 0;
 }
 
 static int cam_cdm_util_reg_random_write(void __iomem *base_addr,
-	uint32_t *cmd_buf, uint32_t cmd_buf_size, uint32_t *used_bytes)
+	uint32_t *cmd_buf, uint32_t cmd_buf_size, uint32_t *used_bytes,
+	uint32_t base_array_size,
+	struct cam_soc_reg_map *base_table[CAM_SOC_MAX_BLOCK])
 {
 	uint32_t i;
-	struct cdm_regrandom_cmd *reg_random;
-	uint32_t *data;
+	struct cdm_regrandom_cmd reg_random;
+	uint32_t *data, offset;
+	resource_size_t size = 0;
 
 	if (!base_addr) {
 		CAM_ERR(CAM_CDM, "invalid base address");
 		return -EINVAL;
 	}
 
-	reg_random = (struct cdm_regrandom_cmd *) cmd_buf;
-	if (!reg_random->count ||
-	    (((reg_random->count * (sizeof(uint32_t) * 2)) +
-	      cdm_get_cmd_header_size(CAM_CDM_CMD_REG_RANDOM)) >
-	     cmd_buf_size)) {
+	memcpy(&reg_random, cmd_buf, sizeof(struct cdm_regrandom_cmd));
+	for (i = 0; i < base_array_size; i++) {
+		if ((base_table[i]) &&
+			((base_table[i])->mem_base == base_addr)) {
+			size = (base_table[i])->size;
+			break;
+		}
+	}
+
+	if (size == 0) {
+		CAM_ERR(CAM_CDM, "Could not retrieve ioremap size, address not mapped!");
+		return -EINVAL;
+	}
+
+	if ((!reg_random.count) || (((reg_random.count * (sizeof(uint32_t) * 2)) +
+		cdm_get_cmd_header_size(CAM_CDM_CMD_REG_RANDOM)) > cmd_buf_size)) {
 		CAM_ERR(CAM_CDM, "invalid reg_count  %d cmd_buf_size %d",
-			reg_random->count, cmd_buf_size);
+			reg_random.count, cmd_buf_size);
 		return -EINVAL;
 	}
 	data = cmd_buf + cdm_get_cmd_header_size(CAM_CDM_CMD_REG_RANDOM);
-
-	for (i = 0; i < reg_random->count; i++) {
-		CAM_DBG(CAM_CDM, "reg random: offset %pK, value 0x%x",
-			((void __iomem *)(base_addr + data[0])),
-			data[1]);
-		cam_io_w(data[1], base_addr + data[0]);
-		data += 2;
+	for (i = 0; i < reg_random.count; i++) {
+		offset = data[0];
+		if (offset <= size) {
+			CAM_DBG(CAM_CDM, "reg random: offset %pK, value 0x%x",
+				((void __iomem *)(base_addr + offset)),
+				data[1]);
+			cam_io_w(data[1], base_addr + offset);
+			data += 2;
+		} else {
+			CAM_ERR(CAM_CDM, "Offset out of mapped range! size: %llu, offset: %u",
+				size, offset);
+			return -EINVAL;
+		}
 	}
 
-	*used_bytes = ((reg_random->count * (sizeof(uint32_t) * 2)) +
+	*used_bytes = ((reg_random.count * (sizeof(uint32_t) * 2)) +
 		(4 * cdm_get_cmd_header_size(CAM_CDM_CMD_REG_RANDOM)));
-
 	return 0;
 }
 
 static int cam_cdm_util_swd_dmi_write(uint32_t cdm_cmd_type,
 	void __iomem *base_addr, uint32_t *cmd_buf, uint32_t cmd_buf_size,
-	uint32_t *used_bytes)
+	uint32_t *used_bytes, uint32_t base_array_size,
+	struct cam_soc_reg_map *base_table[CAM_SOC_MAX_BLOCK])
 {
 	uint32_t i;
-	struct cdm_dmi_cmd *swd_dmi;
+	struct cdm_dmi_cmd swd_dmi;
 	uint32_t *data;
+	resource_size_t size = 0;
 
-	swd_dmi = (struct cdm_dmi_cmd *)cmd_buf;
+	memcpy(&swd_dmi, cmd_buf, sizeof(struct cdm_dmi_cmd));
+	for (i = 0; i < base_array_size; i++) {
+		if ((base_table[i]) &&
+			((base_table[i])->mem_base == base_addr)) {
+			size = (base_table[i])->size;
+			break;
+		}
+	}
 
-	if (cmd_buf_size < (cdm_required_size_dmi() + swd_dmi->length + 1)) {
+	if (size == 0) {
+		CAM_ERR(CAM_CDM, "Could not retrieve ioremap size, address not mapped!");
+		return -EINVAL;
+	}
+
+	if (cmd_buf_size < (cdm_required_size_dmi() + swd_dmi.length + 1)) {
 		CAM_ERR(CAM_CDM, "invalid CDM_SWD_DMI length %d",
-			swd_dmi->length + 1);
+			swd_dmi.length + 1);
 		return -EINVAL;
 	}
 	data = cmd_buf + cdm_required_size_dmi();
 
 	if (cdm_cmd_type == CAM_CDM_CMD_SWD_DMI_64) {
-		for (i = 0; i < (swd_dmi->length + 1)/8; i++) {
-			cam_io_w_mb(data[0], base_addr +
-				swd_dmi->DMIAddr + CAM_CDM_DMI_DATA_LO_OFFSET);
-			cam_io_w_mb(data[1], base_addr +
-				swd_dmi->DMIAddr + CAM_CDM_DMI_DATA_HI_OFFSET);
+		for (i = 0; i < (swd_dmi.length + 1)/8; i++) {
+			if (swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_LO_OFFSET <= size)
+				cam_io_w_mb(data[0], base_addr +
+					swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_LO_OFFSET);
+			else {
+				CAM_ERR(CAM_CDM,
+					"Offset out of mapped range! size: %llu, offset: %u",
+					size, swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_LO_OFFSET);
+				return -EINVAL;
+			}
+			if (swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_HI_OFFSET <= size)
+				cam_io_w_mb(data[1], base_addr +
+					swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_HI_OFFSET);
+			else {
+				CAM_ERR(CAM_CDM,
+					"Offset out of mapped range! size: %llu, offset: %u",
+					size, swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_HI_OFFSET);
+				return -EINVAL;
+			}
 			data += 2;
 		}
 	} else {
-		for (i = 0; i < (swd_dmi->length + 1)/4; i++) {
-			cam_io_w_mb(data[0], base_addr +
-				swd_dmi->DMIAddr + CAM_CDM_DMI_DATA_LO_OFFSET);
+		for (i = 0; i < (swd_dmi.length + 1)/4; i++) {
+			if (swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_LO_OFFSET <= size)
+				cam_io_w_mb(data[0], base_addr +
+					swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_LO_OFFSET);
+			else {
+				CAM_ERR(CAM_CDM,
+					"Offset out of mapped range! size: %llu, offset: %u",
+					size, swd_dmi.DMIAddr + CAM_CDM_DMI_DATA_LO_OFFSET);
+				return -EINVAL;
+			}
 			data += 1;
 		}
 	}
-	*used_bytes = (4 * cdm_required_size_dmi()) + swd_dmi->length + 1;
-
+	*used_bytes = (4 * cdm_required_size_dmi()) + swd_dmi.length + 1;
 	return 0;
 }
 
@@ -392,7 +468,8 @@
 		switch (cdm_cmd_type) {
 		case CAM_CDM_CMD_REG_CONT: {
 			ret = cam_cdm_util_reg_cont_write(*current_device_base,
-				cmd_buf, cmd_buf_size, &used_bytes);
+				cmd_buf, cmd_buf_size, &used_bytes,
+				base_array_size, base_table);
 			if (ret)
 				break;
 
@@ -405,7 +482,7 @@
 		case CAM_CDM_CMD_REG_RANDOM: {
 			ret = cam_cdm_util_reg_random_write(
 				*current_device_base, cmd_buf, cmd_buf_size,
-				&used_bytes);
+				&used_bytes, base_array_size, base_table);
 			if (ret)
 				break;
 
@@ -426,7 +503,7 @@
 			}
 			ret = cam_cdm_util_swd_dmi_write(cdm_cmd_type,
 				*current_device_base, cmd_buf, cmd_buf_size,
-				&used_bytes);
+				&used_bytes, base_array_size, base_table);
 			if (ret)
 				break;
 
diff --git a/drivers/media/platform/camx/cam_core/cam_context_utils.c b/drivers/media/platform/camx/cam_core/cam_context_utils.c
index 29fb05c..9799af3 100644
--- a/drivers/media/platform/camx/cam_core/cam_context_utils.c
+++ b/drivers/media/platform/camx/cam_core/cam_context_utils.c
@@ -26,6 +26,7 @@
 #include "cam_sync_api.h"
 #include "cam_trace.h"
 #include "cam_debug_util.h"
+#include "cam_common_util.h"
 
 static uint cam_debug_ctx_req_list;
 module_param(cam_debug_ctx_req_list, uint, 0644);
@@ -162,11 +163,12 @@
 
 	rc = ctx->hw_mgr_intf->hw_config(ctx->hw_mgr_intf->hw_mgr_priv, &cfg);
 	if (rc) {
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		spin_lock(&ctx->lock);
 		list_del_init(&req->list);
 		list_add_tail(&req->list, &ctx->free_req_list);
 		spin_unlock(&ctx->lock);
-
 		if (cam_debug_ctx_req_list & ctx->dev_id)
 			CAM_INFO(CAM_CTXT,
 				"[%s][%d] : Moving req[%llu] from active_list to free_list",
@@ -222,12 +224,13 @@
 		} else {
 			req->flushed = 0;
 			req->ctx = NULL;
+			cam_common_mem_free(req->pf_data.packet);
+			req->pf_data.packet = NULL;
 			mutex_unlock(&ctx->sync_mutex);
 			spin_lock(&ctx->lock);
 			list_del_init(&req->list);
 			list_add_tail(&req->list, &ctx->free_req_list);
 			spin_unlock(&ctx->lock);
-
 			if (cam_debug_ctx_req_list & ctx->dev_id)
 				CAM_INFO(CAM_CTXT,
 					"[%s][%d] : Moving req[%llu] from pending_list to free_list",
@@ -276,6 +279,8 @@
 	struct cam_hw_stream_setttings cfg;
 	uintptr_t packet_addr;
 	struct cam_packet *packet;
+	struct cam_packet *packet_local = NULL;
+	uint32_t header_size;
 
 	if (!ctx || !cmd) {
 		CAM_ERR(CAM_CTXT, "Invalid input params %pK %pK", ctx, cmd);
@@ -308,15 +313,29 @@
 	if ((len < sizeof(struct cam_packet)) ||
 		(cmd->offset >= (len - sizeof(struct cam_packet)))) {
 		CAM_ERR(CAM_CTXT, "Not enough buf");
-		cam_mem_put_cpu_buf((int32_t) cmd->packet_handle);
-		return -EINVAL;
+		rc = -EINVAL;
+		goto free_cpu_buf;
 
 	}
 	packet = (struct cam_packet *) ((uint8_t *)packet_addr +
 		(uint32_t)cmd->offset);
+	header_size = packet->header.size;
+
+	packet_local = (struct cam_packet*)(cam_common_mem_kdup(packet, header_size));
+	if (!packet_local) {
+		CAM_ERR(CAM_CTXT, "Alloc and copy fail");
+		rc = -ENOMEM;
+		goto free_cpu_buf;
+	}
+
+	if (header_size != packet->header.size) {
+		CAM_ERR(CAM_CTXT, "Header size mismatch, reject packet");
+		rc = -EINVAL;
+		goto free_cpu_buf;
+	}
 
 	memset(&cfg, 0, sizeof(cfg));
-	cfg.packet = packet;
+	cfg.packet = packet_local;
 	cfg.ctxt_to_hw_map = ctx->ctxt_to_hw_map;
 	cfg.priv = NULL;
 
@@ -330,8 +349,9 @@
 		rc = -EFAULT;
 	}
 
+free_cpu_buf:
 	cam_mem_put_cpu_buf((int32_t) cmd->packet_handle);
-
+	cam_common_mem_free(packet_local);
 	return rc;
 }
 
@@ -343,9 +363,11 @@
 	struct cam_hw_prepare_update_args cfg;
 	uintptr_t packet_addr;
 	struct cam_packet *packet;
+	struct cam_packet *packet_local = NULL;
 	size_t len = 0;
 	size_t remain_len = 0;
 	int32_t i = 0, j = 0;
+	uint32_t header_size;
 
 	if (!ctx || !cmd) {
 		CAM_ERR(CAM_CTXT, "Invalid input params %pK %pK", ctx, cmd);
@@ -397,25 +419,39 @@
 		rc = -EINVAL;
 		goto free_cpu_buf;
 	}
-
+	memset(&req->pf_data, 0, sizeof(struct cam_hw_mgr_dump_pf_data));
 	remain_len -= (size_t)cmd->offset;
 	packet = (struct cam_packet *) ((uint8_t *)packet_addr +
 		(uint32_t)cmd->offset);
+	header_size = packet->header.size;
 
-	if (packet->header.request_id <= ctx->last_flush_req) {
-		CAM_ERR(CAM_CORE,
-			"request %lld has been flushed, reject packet",
-			packet->header.request_id);
+	packet_local = (struct cam_packet*)(cam_common_mem_kdup(packet, header_size));
+	if (!packet_local) {
+		CAM_ERR(CAM_CTXT, "Alloc and copy fail");
+		rc = -ENOMEM;
+		goto free_cpu_buf;
+	}
+
+	if (header_size != packet->header.size) {
+		CAM_ERR(CAM_CTXT, "Header size mismatch, reject packet");
 		rc = -EINVAL;
 		goto free_cpu_buf;
 	}
 
-	if (packet->header.request_id > ctx->last_flush_req)
+	if (packet_local->header.request_id <= ctx->last_flush_req) {
+		CAM_ERR(CAM_CORE,
+			"request %lld has been flushed, reject packet",
+			packet_local->header.request_id);
+		rc = -EINVAL;
+		goto free_cpu_buf;
+	}
+
+	if (packet_local->header.request_id > ctx->last_flush_req)
 		ctx->last_flush_req = 0;
 
 	/* preprocess the configuration */
 	memset(&cfg, 0, sizeof(cfg));
-	cfg.packet = packet;
+	cfg.packet = packet_local;
 	cfg.remain_len = remain_len;
 	cfg.ctxt_to_hw_map = ctx->ctxt_to_hw_map;
 	cfg.max_hw_update_entries = CAM_CTX_CFG_MAX;
@@ -440,7 +476,7 @@
 	req->num_out_map_entries = cfg.num_out_map_entries;
 	req->num_in_map_entries = cfg.num_in_map_entries;
 	atomic_set(&req->num_in_acked, 0);
-	req->request_id = packet->header.request_id;
+	req->request_id = packet_local->header.request_id;
 	req->status = 1;
 	req->req_priv = cfg.priv;
 
@@ -517,11 +553,11 @@
 free_cpu_buf:
 	cam_mem_put_cpu_buf((int32_t) cmd->packet_handle);
 free_req:
+	cam_common_mem_free(packet_local);
 	spin_lock(&ctx->lock);
 	list_add_tail(&req->list, &ctx->free_req_list);
 	req->ctx = NULL;
 	spin_unlock(&ctx->lock);
-
 	return rc;
 }
 
@@ -694,6 +730,8 @@
 		 * not be put on the free list. So put it on the free list here
 		 */
 		if (free_req) {
+			cam_common_mem_free(req->pf_data.packet);
+			req->pf_data.packet = NULL;
 			req->ctx = NULL;
 			spin_lock(&ctx->lock);
 			list_add_tail(&req->list, &ctx->free_req_list);
@@ -763,10 +801,12 @@
 			}
 		}
 
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
+		req->ctx = NULL;
 		spin_lock(&ctx->lock);
 		list_add_tail(&req->list, &ctx->free_req_list);
 		spin_unlock(&ctx->lock);
-		req->ctx = NULL;
 
 		if (cam_debug_ctx_req_list & ctx->dev_id)
 			CAM_INFO(CAM_CTXT,
diff --git a/drivers/media/platform/camx/cam_isp/cam_isp_context.c b/drivers/media/platform/camx/cam_isp/cam_isp_context.c
index d011392..e8c80d9 100644
--- a/drivers/media/platform/camx/cam_isp/cam_isp_context.c
+++ b/drivers/media/platform/camx/cam_isp/cam_isp_context.c
@@ -447,6 +447,8 @@
 				sizeof(req_isp_new->cfg[0])*
 				req_isp_new->num_cfg);
 			req_isp_old->num_cfg += req_isp_new->num_cfg;
+			cam_common_mem_free(req_old->pf_data.packet);
+			req_old->pf_data.packet = NULL;
 
 			memcpy(&req_old->pf_data, &req->pf_data,
 				sizeof(struct cam_hw_mgr_dump_pf_data));
@@ -726,8 +728,11 @@
 		__cam_isp_ctx_update_event_record(ctx_isp,
 			CAM_ISP_CTX_EVENT_BUFDONE, req);
 	} else {
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_del_init(&req->list);
 		list_add_tail(&req->list, &ctx->free_req_list);
+
 		req_isp->reapply = false;
 
 		CAM_DBG(CAM_REQ,
@@ -759,8 +764,11 @@
 					rc);
 			req_isp->fence_map_out[j].sync_id = -1;
 		}
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_del_init(&req->list);
 		list_add_tail(&req->list, &ctx->free_req_list);
+
 		ctx_isp->active_req_cnt--;
 	}
 	ctx_isp->irq_delay_detect = false;
@@ -909,7 +917,10 @@
 
 	} else {
 		/* no io config, so the request is completed. */
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_add_tail(&req->list, &ctx->free_req_list);
+
 		CAM_DBG(CAM_ISP,
 			"move active request %lld to free list(cnt = %d), ctx %u",
 			req->request_id, ctx_isp->active_req_cnt, ctx->ctx_id);
@@ -1052,6 +1063,8 @@
 		CAM_INFO_RATE_LIMIT(CAM_REQ,
 			"Move active req %lld to free [all fences done] ctx %u",
 			req->request_id, ctx->ctx_id);
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_del_init(&req->list);
 		list_add_tail(&req->list, &ctx->free_req_list);
 	}
@@ -1158,8 +1171,11 @@
 			struct cam_ctx_request, list);
 		list_del_init(&req->list);
 		req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-		if (req_isp->num_fence_map_out == req_isp->num_acked)
+		if (req_isp->num_fence_map_out == req_isp->num_acked) {
+			cam_common_mem_free(req->pf_data.packet);
+			req->pf_data.packet = NULL;
 			list_add_tail(&req->list, &ctx->free_req_list);
+		}
 		else
 			CAM_ERR(CAM_ISP,
 				"receive rup in unexpected state");
@@ -1540,8 +1556,11 @@
 					fence_map_out->sync_id = -1;
 				}
 			}
+			cam_common_mem_free(req->pf_data.packet);
+			req->pf_data.packet = NULL;
 			list_del_init(&req->list);
 			list_add_tail(&req->list, &ctx->free_req_list);
+
 			ctx_isp->active_req_cnt--;
 		} else {
 			found = 1;
@@ -1571,8 +1590,11 @@
 					fence_map_out->sync_id = -1;
 				}
 			}
+			cam_common_mem_free(req->pf_data.packet);
+			req->pf_data.packet = NULL;
 			list_del_init(&req->list);
 			list_add_tail(&req->list, &ctx->free_req_list);
+
 			ctx_isp->active_req_cnt--;
 		} else {
 			found = 1;
@@ -1634,6 +1656,8 @@
 					CAM_SYNC_STATE_SIGNALED_ERROR);
 			req_isp->fence_map_out[i].sync_id = -1;
 		}
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_del_init(&req->list);
 		list_add_tail(&req->list, &ctx->free_req_list);
 
@@ -1844,8 +1868,11 @@
 			struct cam_ctx_request, list);
 		list_del_init(&req->list);
 		req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-		if (req_isp->num_fence_map_out == req_isp->num_acked)
+		if (req_isp->num_fence_map_out == req_isp->num_acked) {
+			cam_common_mem_free(req->pf_data.packet);
+			req->pf_data.packet = NULL;
 			list_add_tail(&req->list, &ctx->free_req_list);
+		}
 		else
 			CAM_ERR(CAM_ISP,
 				"receive rup in unexpected state");
@@ -1884,6 +1911,8 @@
 			 req->request_id, ctx_isp->active_req_cnt);
 	} else {
 		/* no io config, so the request is completed. */
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_add_tail(&req->list, &ctx->free_req_list);
 	}
 
@@ -2460,6 +2489,8 @@
 			}
 		}
 		req_isp->reapply = false;
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_add_tail(&req->list, &ctx->free_req_list);
 	}
 
@@ -2918,6 +2949,8 @@
 					req_isp->fence_map_out[i].sync_id,
 					CAM_SYNC_STATE_SIGNALED_ERROR);
 			}
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_add_tail(&req->list, &ctx->free_req_list);
 		ctx_isp->active_req_cnt--;
 	}
@@ -2990,7 +3023,10 @@
 			request_id = req->request_id;
 		} else {
 			/* no io config, so the request is completed. */
+			cam_common_mem_free(req->pf_data.packet);
+			req->pf_data.packet = NULL;
 			list_add_tail(&req->list, &ctx->free_req_list);
+
 			CAM_DBG(CAM_ISP,
 				"move active req %lld to free list(cnt=%d)",
 				req->request_id, ctx_isp->active_req_cnt);
@@ -3300,12 +3336,14 @@
 	struct cam_isp_ctx_req           *req_isp = NULL;
 	uintptr_t                         packet_addr;
 	struct cam_packet                *packet;
+	struct cam_packet                *packet_local = NULL;
 	size_t                            len = 0;
 	size_t                            remain_len = 0;
 	struct cam_hw_prepare_update_args cfg;
 	struct cam_req_mgr_add_request    add_req;
 	struct cam_isp_context           *ctx_isp =
 		(struct cam_isp_context *) ctx->ctx_priv;
+	uint32_t header_size;
 
 	CAM_DBG(CAM_ISP, "get free request object......");
 
@@ -3345,27 +3383,42 @@
 
 	remain_len -= (size_t)cmd->offset;
 	packet = (struct cam_packet *)(packet_addr + (uint32_t)cmd->offset);
+
+	header_size = packet->header.size;
+	packet_local = (struct cam_packet*)(cam_common_mem_kdup(packet, header_size));
+	if (!packet_local) {
+		CAM_ERR(CAM_ISP, "Alloc and copy fail");
+		rc = -ENOMEM;
+		goto free_cpu_buf;
+	}
+
+	if (header_size != packet->header.size) {
+		CAM_ERR(CAM_CTXT, "Header size mismatch, reject packet");
+		rc = -EINVAL;
+		goto free_cpu_buf;
+	}
+
 	CAM_DBG(CAM_ISP, "pack_handle %llx", cmd->packet_handle);
 	CAM_DBG(CAM_ISP, "packet address is 0x%zx", packet_addr);
 	CAM_DBG(CAM_ISP, "packet with length %zu, offset 0x%llx",
 		len, cmd->offset);
 	CAM_DBG(CAM_ISP, "Packet request id %lld",
-		packet->header.request_id);
-	CAM_DBG(CAM_ISP, "Packet size 0x%x", packet->header.size);
-	CAM_DBG(CAM_ISP, "packet op %d", packet->header.op_code);
+		packet_local->header.request_id);
+	CAM_DBG(CAM_ISP, "Packet size 0x%x", packet_local->header.size);
+	CAM_DBG(CAM_ISP, "packet op %d", packet_local->header.op_code);
 
-	if ((((packet->header.op_code + 1) & 0xF) == CAM_ISP_PACKET_UPDATE_DEV)
-		&& (packet->header.request_id <= ctx->last_flush_req)) {
+	if ((((packet_local->header.op_code + 1) & 0xF) == CAM_ISP_PACKET_UPDATE_DEV)
+		&& (packet_local->header.request_id <= ctx->last_flush_req)) {
 		CAM_INFO(CAM_ISP,
 			"request %lld has been flushed, reject packet",
-			packet->header.request_id);
+			packet_local->header.request_id);
 		rc = -EBADR;
 		goto free_cpu_buf;
 	}
 
 	/* preprocess the configuration */
 	memset(&cfg, 0, sizeof(cfg));
-	cfg.packet = packet;
+	cfg.packet = packet_local;
 	cfg.remain_len = remain_len;
 	cfg.ctxt_to_hw_map = ctx_isp->hw_ctx;
 	cfg.max_hw_update_entries = CAM_ISP_CTX_CFG_MAX;
@@ -3392,6 +3445,7 @@
 	req_isp->num_fence_map_in = cfg.num_in_map_entries;
 	req_isp->num_acked = 0;
 	req_isp->bubble_detected = false;
+	req->pf_data.packet = packet_local;
 
 	for (i = 0; i < req_isp->num_fence_map_out; i++) {
 		rc = cam_sync_get_obj_ref(req_isp->fence_map_out[i].sync_id);
@@ -3406,11 +3460,11 @@
 		req_isp->num_cfg, req_isp->num_fence_map_out,
 		req_isp->num_fence_map_in);
 
-	req->request_id = packet->header.request_id;
+	req->request_id = packet_local->header.request_id;
 	req->status = 1;
 
 	CAM_DBG(CAM_ISP, "Packet request id %lld packet opcode:%d",
-		packet->header.request_id,
+		packet_local->header.request_id,
 		req_isp->hw_update_data.packet_opcode_type);
 
 	if (req_isp->hw_update_data.packet_opcode_type ==
@@ -3463,6 +3517,7 @@
 free_cpu_buf:
 	cam_mem_put_cpu_buf((int32_t) cmd->packet_handle);
 free_req:
+	cam_common_mem_free(packet_local);
 	spin_lock_bh(&ctx->lock);
 	list_add_tail(&req->list, &ctx->free_req_list);
 	spin_unlock_bh(&ctx->lock);
@@ -3988,6 +4043,8 @@
 					req_isp->fence_map_out[i].sync_id,
 					CAM_SYNC_STATE_SIGNALED_ERROR);
 			}
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_add_tail(&req->list, &ctx->free_req_list);
 	}
 
@@ -4004,6 +4061,8 @@
 					req_isp->fence_map_out[i].sync_id,
 					CAM_SYNC_STATE_SIGNALED_ERROR);
 			}
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_add_tail(&req->list, &ctx->free_req_list);
 	}
 
@@ -4020,6 +4079,8 @@
 					req_isp->fence_map_out[i].sync_id,
 					CAM_SYNC_STATE_SIGNALED_ERROR);
 			}
+		cam_common_mem_free(req->pf_data.packet);
+		req->pf_data.packet = NULL;
 		list_add_tail(&req->list, &ctx->free_req_list);
 	}
 	ctx_isp->frame_id = 0;
diff --git a/drivers/media/platform/camx/cam_isp/isp_hw_mgr/hw_utils/cam_isp_packet_parser.c b/drivers/media/platform/camx/cam_isp/isp_hw_mgr/hw_utils/cam_isp_packet_parser.c
index b824156c..694e544 100644
--- a/drivers/media/platform/camx/cam_isp/isp_hw_mgr/hw_utils/cam_isp_packet_parser.c
+++ b/drivers/media/platform/camx/cam_isp/isp_hw_mgr/hw_utils/cam_isp_packet_parser.c
@@ -18,6 +18,7 @@
 #include "cam_vfe_hw_intf.h"
 #include "cam_isp_packet_parser.h"
 #include "cam_debug_util.h"
+#include "cam_common_util.h"
 
 int cam_isp_add_change_base(
 	struct cam_hw_prepare_update_args      *prepare,
@@ -110,6 +111,7 @@
 	uint32_t                                    ports_plane_idx;
 	size_t                                      len = 0, remain_len = 0;
 	uint32_t                                   *cpu_addr;
+	uint32_t                                   *cpu_addr_local = NULL;
 	uint32_t                                    i, j;
 
 	CAM_DBG(CAM_UTIL, "cmd des size %d, length: %d",
@@ -124,17 +126,25 @@
 		(cmd_desc->offset >=
 		(len - sizeof(struct cam_isp_dual_config)))) {
 		CAM_ERR(CAM_UTIL, "not enough buffer provided");
-		return -EINVAL;
+		rc = -EINVAL;
+		goto put_buf;
 	}
 	remain_len = len - cmd_desc->offset;
 	cpu_addr += (cmd_desc->offset / 4);
-	dual_config = (struct cam_isp_dual_config *)cpu_addr;
+	cpu_addr_local = (uint32_t *)cam_common_mem_kdup(cpu_addr, cmd_desc->length);
+	if (!cpu_addr_local) {
+		CAM_ERR(CAM_ISP, "Alloc and copy fail");
+		rc = -ENOMEM;
+		goto put_buf;
+	}
+	dual_config = (struct cam_isp_dual_config *)cpu_addr_local;
 
 	if ((dual_config->num_ports *
 		sizeof(struct cam_isp_dual_stripe_config)) >
 		(remain_len - offsetof(struct cam_isp_dual_config, stripes))) {
 		CAM_ERR(CAM_UTIL, "not enough buffer for all the dual configs");
-		return -EINVAL;
+		rc = -EINVAL;
+		goto put_buf;
 	}
 	for (i = 0; i < dual_config->num_ports; i++) {
 
@@ -184,7 +194,7 @@
 
 put_buf:
 	cam_mem_put_cpu_buf(cmd_desc->mem_handle);
-
+	cam_common_mem_free(cpu_addr_local);
 	return rc;
 }
 
@@ -262,6 +272,7 @@
 	uint32_t                           base_idx;
 	enum cam_isp_hw_split_id           split_id;
 	struct cam_cmd_buf_desc           *cmd_desc = NULL;
+	struct cam_cmd_buf_desc            cmd_desc_local;
 	struct cam_hw_update_entry        *hw_entry;
 
 	hw_entry = prepare->hw_update_entries;
@@ -281,7 +292,8 @@
 
 	for (i = 0; i < prepare->packet->num_cmd_buf; i++) {
 		num_ent = prepare->num_hw_update_entries;
-		if (!cmd_desc[i].length)
+		memcpy(&cmd_desc_local, &cmd_desc[i], sizeof(struct cam_cmd_buf_desc));
+		if (!cmd_desc_local.length)
 			continue;
 
 		/* One hw entry space required for left or right or common */
@@ -291,11 +303,11 @@
 			return -EINVAL;
 		}
 
-		rc = cam_packet_util_validate_cmd_desc(&cmd_desc[i]);
+		rc = cam_packet_util_validate_cmd_desc(&cmd_desc_local);
 		if (rc)
 			return rc;
 
-		cmd_meta_data = cmd_desc[i].meta_data;
+		cmd_meta_data = cmd_desc_local.meta_data;
 
 		CAM_DBG(CAM_ISP, "meta type: %d, split_id: %d",
 			cmd_meta_data, split_id);
@@ -305,10 +317,10 @@
 		case CAM_ISP_PACKET_META_LEFT:
 		case CAM_ISP_PACKET_META_DMI_LEFT:
 			if (split_id == CAM_ISP_HW_SPLIT_LEFT) {
-				hw_entry[num_ent].len = cmd_desc[i].length;
+				hw_entry[num_ent].len = cmd_desc_local.length;
 				hw_entry[num_ent].handle =
-					cmd_desc[i].mem_handle;
-				hw_entry[num_ent].offset = cmd_desc[i].offset;
+					cmd_desc_local.mem_handle;
+				hw_entry[num_ent].offset = cmd_desc_local.offset;
 				CAM_DBG(CAM_ISP,
 					"Meta_Left num_ent=%d handle=0x%x, len=%u, offset=%u",
 					num_ent,
@@ -323,10 +335,10 @@
 		case CAM_ISP_PACKET_META_RIGHT:
 		case CAM_ISP_PACKET_META_DMI_RIGHT:
 			if (split_id == CAM_ISP_HW_SPLIT_RIGHT) {
-				hw_entry[num_ent].len = cmd_desc[i].length;
+				hw_entry[num_ent].len = cmd_desc_local.length;
 				hw_entry[num_ent].handle =
-					cmd_desc[i].mem_handle;
-				hw_entry[num_ent].offset = cmd_desc[i].offset;
+					cmd_desc_local.mem_handle;
+				hw_entry[num_ent].offset = cmd_desc_local.offset;
 				CAM_DBG(CAM_ISP,
 					"Meta_Right num_ent=%d handle=0x%x, len=%u, offset=%u",
 					num_ent,
@@ -340,10 +352,10 @@
 			break;
 		case CAM_ISP_PACKET_META_COMMON:
 		case CAM_ISP_PACKET_META_DMI_COMMON:
-			hw_entry[num_ent].len = cmd_desc[i].length;
+			hw_entry[num_ent].len = cmd_desc_local.length;
 			hw_entry[num_ent].handle =
-				cmd_desc[i].mem_handle;
-			hw_entry[num_ent].offset = cmd_desc[i].offset;
+				cmd_desc_local.mem_handle;
+			hw_entry[num_ent].offset = cmd_desc_local.offset;
 			CAM_DBG(CAM_ISP,
 				"Meta_Common num_ent=%d handle=0x%x, len=%u, offset=%u",
 				num_ent,
@@ -356,7 +368,7 @@
 			break;
 		case CAM_ISP_PACKET_META_DUAL_CONFIG:
 			rc = cam_isp_update_dual_config(prepare,
-				&cmd_desc[i], split_id, base_idx,
+				&cmd_desc_local, split_id, base_idx,
 				res_list_isp_out, size_isp_out);
 
 			if (rc)
@@ -372,7 +384,7 @@
 				blob_info.kmd_buf_info = kmd_buf_info;
 
 				rc = cam_packet_util_process_generic_cmd_buffer(
-					&cmd_desc[i],
+					&cmd_desc_local,
 					blob_handler_cb,
 					&blob_info);
 				if (rc) {
@@ -395,7 +407,7 @@
 				blob_info.kmd_buf_info = kmd_buf_info;
 
 				rc = cam_packet_util_process_generic_cmd_buffer(
-					&cmd_desc[i],
+					&cmd_desc_local,
 					blob_handler_cb,
 					&blob_info);
 				if (rc) {
@@ -417,7 +429,7 @@
 			blob_info.kmd_buf_info = kmd_buf_info;
 
 			rc = cam_packet_util_process_generic_cmd_buffer(
-				&cmd_desc[i],
+				&cmd_desc_local,
 				blob_handler_cb,
 				&blob_info);
 			if (rc) {
diff --git a/drivers/media/platform/camx/cam_utils/cam_common_util.c b/drivers/media/platform/camx/cam_utils/cam_common_util.c
index 8cf3483..eadbf38 100644
--- a/drivers/media/platform/camx/cam_utils/cam_common_util.c
+++ b/drivers/media/platform/camx/cam_utils/cam_common_util.c
@@ -14,9 +14,14 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/slab.h>
-
+#include <linux/timer.h>
+#include <linux/completion.h>
+#include <linux/module.h>
+#include <linux/iopoll.h>
+#include <linux/moduleparam.h>
 #include "cam_common_util.h"
 #include "cam_debug_util.h"
+#include "cam_hw.h"
 
 int cam_common_util_get_string_index(const char **strings,
 	uint32_t num_strings, char *matching_string, uint32_t *index)
@@ -62,3 +67,24 @@
 	return ktime_get_boottime();
 }
 
+void *cam_common_mem_kdup(void *from, size_t len)
+{
+	void *to = kvzalloc(len, GFP_KERNEL);
+
+	if (!to) {
+		CAM_ERR(CAM_UTIL, "Failed to allocate header memory");
+		return to;
+	}
+
+	CAM_DBG(CAM_UTIL, "Allocate and copy header with size: %d", len);
+	memcpy(to, from, len);
+
+	return to;
+}
+EXPORT_SYMBOL(cam_common_mem_kdup);
+
+void cam_common_mem_free(void *memory)
+{
+	kvfree(memory);
+}
+EXPORT_SYMBOL(cam_common_mem_free);
diff --git a/drivers/media/platform/camx/cam_utils/cam_common_util.h b/drivers/media/platform/camx/cam_utils/cam_common_util.h
index 5e8bb14..36fc469 100644
--- a/drivers/media/platform/camx/cam_utils/cam_common_util.h
+++ b/drivers/media/platform/camx/cam_utils/cam_common_util.h
@@ -63,4 +63,26 @@
  * @return:               void
  */
 ktime_t cam_common_util_get_curr_timestamp(void);
+
+/**
+ * @brief: Memory alloc and copy
+ *
+ * @from : Source address of memory
+ * @len    : Length of memory
+ *
+ * @return Address of destination address of memory.
+ */
+
+void *cam_common_mem_kdup(void *from, size_t len);
+
+/**
+ * @brief : Free the memory
+ *
+ * @memory: Address of memory
+ *
+ * @return Void.
+ */
+
+void cam_common_mem_free(void *memory);
+
 #endif /* _CAM_COMMON_UTIL_H_ */
diff --git a/drivers/media/platform/camx/cam_utils/cam_packet_util.c b/drivers/media/platform/camx/cam_utils/cam_packet_util.c
index d41186e..efb0e60 100644
--- a/drivers/media/platform/camx/cam_utils/cam_packet_util.c
+++ b/drivers/media/platform/camx/cam_utils/cam_packet_util.c
@@ -17,6 +17,7 @@
 #include "cam_mem_mgr.h"
 #include "cam_packet_util.h"
 #include "cam_debug_util.h"
+#include "cam_common_util.h"
 
 int cam_packet_util_get_cmd_mem_addr(int handle, uint32_t **buf_addr,
 	size_t *len)
@@ -102,6 +103,7 @@
 	size_t                   len = 0;
 	size_t                   remain_len = 0;
 	struct cam_cmd_buf_desc *cmd_desc;
+	struct cam_cmd_buf_desc cmd_desc_local;
 	uint32_t                *cpu_addr;
 
 	if (!packet || !kmd_buf) {
@@ -119,26 +121,27 @@
 	cmd_desc = (struct cam_cmd_buf_desc *) ((uint8_t *)
 		&packet->payload + packet->cmd_buf_offset);
 	cmd_desc += packet->kmd_cmd_buf_index;
+	memcpy(&cmd_desc_local, cmd_desc, sizeof(struct cam_cmd_buf_desc));
 
-	rc = cam_packet_util_validate_cmd_desc(cmd_desc);
+	rc = cam_packet_util_validate_cmd_desc(&cmd_desc_local);
 	if (rc)
 		return rc;
 
-	rc = cam_packet_util_get_cmd_mem_addr(cmd_desc->mem_handle, &cpu_addr,
+	rc = cam_packet_util_get_cmd_mem_addr(cmd_desc_local.mem_handle, &cpu_addr,
 		&len);
 	if (rc)
 		return rc;
 
 	remain_len = len;
-	if (((size_t)cmd_desc->offset >= len) ||
-		((size_t)cmd_desc->size > (len - (size_t)cmd_desc->offset))) {
+	if (((size_t)cmd_desc_local.offset >= len) ||
+		((size_t)cmd_desc_local.size > (len - (size_t)cmd_desc_local.offset))) {
 		CAM_ERR(CAM_UTIL, "invalid memory len:%zd and cmd desc size:%d",
-			len, cmd_desc->size);
+			len, cmd_desc_local.size);
 		rc = -EINVAL;
 		goto rel_kmd_buf;
 	}
 
-	remain_len -= (size_t)cmd_desc->offset;
+	remain_len -= (size_t)cmd_desc_local.offset;
 	if ((size_t)packet->kmd_cmd_buf_offset >= remain_len) {
 		CAM_ERR(CAM_UTIL, "Invalid kmd cmd buf offset: %zu",
 			(size_t)packet->kmd_cmd_buf_offset);
@@ -146,23 +149,22 @@
 		goto rel_kmd_buf;
 	}
 
-	cpu_addr += (cmd_desc->offset / 4) + (packet->kmd_cmd_buf_offset / 4);
+	cpu_addr += (cmd_desc_local.offset / 4) + (packet->kmd_cmd_buf_offset / 4);
 	CAM_DBG(CAM_UTIL, "total size %d, cmd size: %d, KMD buffer size: %d",
-		cmd_desc->size, cmd_desc->length,
-		cmd_desc->size - cmd_desc->length);
+		cmd_desc_local.size, cmd_desc_local.length,
+		cmd_desc_local.size - cmd_desc_local.length);
 	CAM_DBG(CAM_UTIL, "hdl 0x%x, cmd offset %d, kmd offset %d, addr 0x%pK",
-		cmd_desc->mem_handle, cmd_desc->offset,
+		cmd_desc_local.mem_handle, cmd_desc_local.offset,
 		packet->kmd_cmd_buf_offset, cpu_addr);
 
 	kmd_buf->cpu_addr   = cpu_addr;
-	kmd_buf->handle     = cmd_desc->mem_handle;
-	kmd_buf->offset     = cmd_desc->offset + packet->kmd_cmd_buf_offset;
-	kmd_buf->size       = cmd_desc->size - cmd_desc->length;
+	kmd_buf->handle     = cmd_desc_local.mem_handle;
+	kmd_buf->offset     = cmd_desc_local.offset + packet->kmd_cmd_buf_offset;
+	kmd_buf->size       = cmd_desc_local.size - cmd_desc_local.length;
 	kmd_buf->used_bytes = 0;
 
 rel_kmd_buf:
-	cam_mem_put_cpu_buf(cmd_desc->mem_handle);
-
+	cam_mem_put_cpu_buf(cmd_desc_local.mem_handle);
 	return rc;
 }
 
@@ -304,6 +306,8 @@
 	size_t    buf_size;
 	size_t    remain_len = 0;
 	uint32_t *blob_ptr;
+	uint32_t *blob_ptr_local = NULL;
+	uint32_t *blob_ptr_local_head = NULL;
 	uint32_t  blob_type, blob_size, blob_block_size, len_read;
 
 	if (!cmd_buf || !blob_handler_cb) {
@@ -342,18 +346,24 @@
 
 	blob_ptr = (uint32_t *)(((uint8_t *)cpu_addr) +
 		cmd_buf->offset);
-
+	blob_ptr_local = (uint32_t *)(cam_common_mem_kdup(blob_ptr, cmd_buf->length));
+	if (!blob_ptr_local) {
+		CAM_ERR(CAM_UTIL, "Alloc and copy fail");
+		rc = -ENOMEM;
+		goto rel_cmd_buf;
+	}
+	blob_ptr_local_head = blob_ptr_local;
 	CAM_DBG(CAM_UTIL,
 		"GenericCmdBuffer cpuaddr=%pK, blobptr=%pK, len=%d",
-		(void *)cpu_addr, (void *)blob_ptr, cmd_buf->length);
+		(void *)cpu_addr, (void *)blob_ptr_local, cmd_buf->length);
 
 	len_read = 0;
 	while (len_read < cmd_buf->length) {
 		blob_type =
-			((*blob_ptr) & CAM_GENERIC_BLOB_CMDBUFFER_TYPE_MASK) >>
+			((*blob_ptr_local) & CAM_GENERIC_BLOB_CMDBUFFER_TYPE_MASK) >>
 			CAM_GENERIC_BLOB_CMDBUFFER_TYPE_SHIFT;
 		blob_size =
-			((*blob_ptr) & CAM_GENERIC_BLOB_CMDBUFFER_SIZE_MASK) >>
+			((*blob_ptr_local) & CAM_GENERIC_BLOB_CMDBUFFER_SIZE_MASK) >>
 			CAM_GENERIC_BLOB_CMDBUFFER_SIZE_SHIFT;
 
 		blob_block_size = sizeof(uint32_t) +
@@ -376,19 +386,19 @@
 		len_read += blob_block_size;
 
 		rc = blob_handler_cb(user_data, blob_type, blob_size,
-			(uint8_t *)(blob_ptr + 1));
+			(uint8_t *)(blob_ptr_local + 1));
 		if (rc) {
 			CAM_ERR(CAM_UTIL, "Error in handling blob type %d %d",
 				blob_type, blob_size);
 			goto rel_cmd_buf;
 		}
 
-		blob_ptr += (blob_block_size / sizeof(uint32_t));
+		blob_ptr_local += (blob_block_size / sizeof(uint32_t));
 	}
 
 rel_cmd_buf:
 	cam_mem_put_cpu_buf(cmd_buf->mem_handle);
-
+	cam_common_mem_free(blob_ptr_local_head);
 	return rc;
 }
 
