diff --git a/drivers/media/platform/camx/cam_sensor_module/cam_actuator/cam_actuator_core.c b/drivers/media/platform/camx/cam_sensor_module/cam_actuator/cam_actuator_core.c
index 38b1c9f..b48ad90 100644
--- a/drivers/media/platform/camx/cam_sensor_module/cam_actuator/cam_actuator_core.c
+++ b/drivers/media/platform/camx/cam_sensor_module/cam_actuator/cam_actuator_core.c
@@ -419,17 +419,20 @@
 	size_t   remain_len = 0;
 	uint32_t *offset = NULL;
 	uint32_t *cmd_buf = NULL;
+	uint32_t *cmd_buf_local = NULL;
 	uintptr_t generic_ptr;
 	uintptr_t generic_pkt_ptr;
 	struct common_header      *cmm_hdr = NULL;
 	struct cam_control        *ioctl_ctrl = NULL;
 	struct cam_packet         *csl_packet = NULL;
+	struct cam_packet         *csl_packet_local = NULL;
 	struct cam_config_dev_cmd config;
 	struct i2c_data_settings  *i2c_data = NULL;
 	struct i2c_settings_array *i2c_reg_settings = NULL;
 	struct cam_cmd_buf_desc   *cmd_desc = NULL;
 	struct cam_actuator_soc_private *soc_private = NULL;
 	struct cam_sensor_power_ctrl_t  *power_info = NULL;
+	uint32_t header_size;
 
 	if (!a_ctrl || !arg) {
 		CAM_ERR(CAM_ACTUATOR, "Invalid Args");
@@ -468,38 +471,46 @@
 	remain_len -= (size_t)config.offset;
 	csl_packet = (struct cam_packet *)
 			(generic_pkt_ptr + (uint32_t)config.offset);
+	header_size = csl_packet->header.size;
 
-	if (cam_packet_util_validate_packet(csl_packet,
+	csl_packet_local =(struct cam_packet *) cam_common_mem_kdup(csl_packet, header_size);
+
+	if (!csl_packet_local) {
+		CAM_ERR(CAM_ACTUATOR, "Alloc and copy fail");
+		rc = -EINVAL;
+		goto rel_pkt_buf;
+	}
+	if (cam_packet_util_validate_packet(csl_packet_local,
 		remain_len)) {
 		CAM_ERR(CAM_ACTUATOR, "Invalid packet params");
 		rc = -EINVAL;
 		goto rel_pkt_buf;
 	}
 
-	CAM_DBG(CAM_ACTUATOR, "Pkt opcode: %d",	csl_packet->header.op_code);
+	CAM_DBG(CAM_ACTUATOR, "Pkt opcode: %d",	csl_packet_local->header.op_code);
 
-	if ((csl_packet->header.op_code & 0xFFFFFF) !=
+	if ((csl_packet_local->header.op_code & 0xFFFFFF) !=
 		CAM_ACTUATOR_PACKET_OPCODE_INIT &&
-		csl_packet->header.request_id <= a_ctrl->last_flush_req
+		csl_packet_local->header.request_id <= a_ctrl->last_flush_req
 		&& a_ctrl->last_flush_req != 0) {
 		CAM_DBG(CAM_ACTUATOR,
 			"reject request %lld, last request to flush %u",
-			csl_packet->header.request_id, a_ctrl->last_flush_req);
+			csl_packet_local->header.request_id, a_ctrl->last_flush_req);
 		rc = -EINVAL;
 		goto rel_pkt_buf;
 	}
 
-	if (csl_packet->header.request_id > a_ctrl->last_flush_req)
+	if (csl_packet_local->header.request_id > a_ctrl->last_flush_req)
 		a_ctrl->last_flush_req = 0;
 
-	switch (csl_packet->header.op_code & 0xFFFFFF) {
+	switch (csl_packet_local->header.op_code & 0xFFFFFF) {
 	case CAM_ACTUATOR_PACKET_OPCODE_INIT:
-		offset = (uint32_t *)&csl_packet->payload;
-		offset += (csl_packet->cmd_buf_offset / sizeof(uint32_t));
+		offset = (uint32_t *)&csl_packet_local->payload;
+		offset += (csl_packet_local->cmd_buf_offset / sizeof(uint32_t));
 		cmd_desc = (struct cam_cmd_buf_desc *)(offset);
 
 		/* Loop through multiple command buffers */
-		for (i = 0; i < csl_packet->num_cmd_buf; i++) {
+		for (i = 0; i < csl_packet_local->num_cmd_buf; i++) {
 			total_cmd_buf_in_bytes = cmd_desc[i].length;
 			if (!total_cmd_buf_in_bytes)
 				continue;
@@ -524,14 +535,23 @@
 			}
 			remain_len = len_of_buff - cmd_desc[i].offset;
 			cmd_buf += cmd_desc[i].offset / sizeof(uint32_t);
-			cmm_hdr = (struct common_header *)cmd_buf;
+
+			cmd_buf_local = (uint32_t *)cam_common_mem_kdup(cmd_buf, total_cmd_buf_in_bytes);
+
+			if (!cmd_buf_local) {
+				CAM_ERR(CAM_ACTUATOR, "Alloc and copy fail");
+				rc = -EINVAL;
+				goto rel_cmd_buf;
+			}
+
+			cmm_hdr = (struct common_header *)cmd_buf_local;
 
 			switch (cmm_hdr->cmd_type) {
 			case CAMERA_SENSOR_CMD_TYPE_I2C_INFO:
 				CAM_DBG(CAM_ACTUATOR,
 					"Received slave info buffer");
 				rc = cam_actuator_slaveInfo_pkt_parser(
-					a_ctrl, cmd_buf, remain_len);
+					a_ctrl, cmd_buf_local, remain_len);
 				if (rc < 0) {
 					CAM_ERR(CAM_ACTUATOR,
 					"Failed to parse slave info: %d", rc);
@@ -543,7 +563,7 @@
 				CAM_DBG(CAM_ACTUATOR,
 					"Received power settings buffer");
 				rc = cam_sensor_update_power_settings(
-					cmd_buf,
+					cmd_buf_local,
 					total_cmd_buf_in_bytes,
 					power_info, remain_len);
 				if (rc) {
@@ -575,6 +595,8 @@
 				break;
 			}
 			cam_mem_put_cpu_buf(cmd_desc[i].mem_handle);
+			cam_common_mem_free(cmd_buf_local);
+			cmd_buf_local = NULL;
 		}
 
 		if (a_ctrl->cam_act_state == CAM_ACTUATOR_ACQUIRE) {
@@ -616,10 +638,10 @@
 		i2c_reg_settings = &i2c_data->init_settings;
 
 		i2c_data->init_settings.request_id =
-			csl_packet->header.request_id;
+			csl_packet_local->header.request_id;
 		i2c_reg_settings->is_settings_valid = 1;
-		offset = (uint32_t *)&csl_packet->payload;
-		offset += csl_packet->cmd_buf_offset / sizeof(uint32_t);
+		offset = (uint32_t *)&csl_packet_local->payload;
+		offset += csl_packet_local->cmd_buf_offset / sizeof(uint32_t);
 		cmd_desc = (struct cam_cmd_buf_desc *)(offset);
 		rc = cam_sensor_i2c_command_parser(
 			&a_ctrl->io_master_info,
@@ -630,7 +652,7 @@
 				"Auto move lens parsing failed: %d", rc);
 			goto rel_pkt_buf;
 		}
-		cam_actuator_update_req_mgr(a_ctrl, csl_packet);
+		cam_actuator_update_req_mgr(a_ctrl, csl_packet_local);
 		break;
 	case CAM_ACTUATOR_PACKET_MANUAL_MOVE_LENS:
 		if (a_ctrl->cam_act_state < CAM_ACTUATOR_CONFIG) {
@@ -644,13 +666,13 @@
 		a_ctrl->setting_apply_state = ACT_APPLY_SETTINGS_LATER;
 		i2c_data = &(a_ctrl->i2c_data);
 		i2c_reg_settings = &i2c_data->per_frame[
-			csl_packet->header.request_id % MAX_PER_FRAME_ARRAY];
+			csl_packet_local->header.request_id % MAX_PER_FRAME_ARRAY];
 
 		 i2c_reg_settings->request_id =
-			csl_packet->header.request_id;
+			csl_packet_local->header.request_id;
 		i2c_reg_settings->is_settings_valid = 1;
-		offset = (uint32_t *)&csl_packet->payload;
-		offset += csl_packet->cmd_buf_offset / sizeof(uint32_t);
+		offset = (uint32_t *)&csl_packet_local->payload;
+		offset += csl_packet_local->cmd_buf_offset / sizeof(uint32_t);
 		cmd_desc = (struct cam_cmd_buf_desc *)(offset);
 		rc = cam_sensor_i2c_command_parser(
 			&a_ctrl->io_master_info,
@@ -662,7 +684,7 @@
 			goto rel_pkt_buf;
 		}
 
-		cam_actuator_update_req_mgr(a_ctrl, csl_packet);
+		cam_actuator_update_req_mgr(a_ctrl, csl_packet_local);
 		break;
 	case CAM_PKT_NOP_OPCODE:
 		if (a_ctrl->cam_act_state < CAM_ACTUATOR_CONFIG) {
@@ -671,24 +693,29 @@
 				a_ctrl->cam_act_state);
 			goto rel_pkt_buf;
 		}
-		cam_actuator_update_req_mgr(a_ctrl, csl_packet);
+		cam_actuator_update_req_mgr(a_ctrl, csl_packet_local);
 		break;
 	default:
 		CAM_ERR(CAM_ACTUATOR, "Wrong Opcode: %d",
-			csl_packet->header.op_code & 0xFFFFFF);
+			csl_packet_local->header.op_code & 0xFFFFFF);
 		rc = -EINVAL;
 		goto rel_pkt_buf;
 	}
 
 	cam_mem_put_cpu_buf(config.packet_handle);
 
+	cam_common_mem_free(csl_packet_local);
 	return rc;
 
 rel_cmd_buf:
 	cam_mem_put_cpu_buf(cmd_desc[i].mem_handle);
+	cam_mem_put_cpu_buf(config.packet_handle);
+	cam_common_mem_free(cmd_buf_local);
+	cam_common_mem_free(csl_packet_local);
+	return rc;
 rel_pkt_buf:
 	cam_mem_put_cpu_buf(config.packet_handle);
-
+	cam_common_mem_free(csl_packet_local);
 	return rc;
 }
 
diff --git a/drivers/media/platform/camx/cam_sensor_module/cam_csiphy/cam_csiphy_core.c b/drivers/media/platform/camx/cam_sensor_module/cam_csiphy/cam_csiphy_core.c
index ea65e57..f6eb167 100644
--- a/drivers/media/platform/camx/cam_sensor_module/cam_csiphy/cam_csiphy_core.c
+++ b/drivers/media/platform/camx/cam_sensor_module/cam_csiphy/cam_csiphy_core.c
@@ -170,11 +170,14 @@
 	uintptr_t                generic_ptr;
 	uintptr_t                generic_pkt_ptr;
 	struct cam_packet       *csl_packet = NULL;
+	struct cam_packet       *csl_packet_local = NULL;
 	struct cam_cmd_buf_desc *cmd_desc = NULL;
 	uint32_t                *cmd_buf = NULL;
+	uint32_t                *cmd_buf_local = NULL;
 	struct cam_csiphy_info  *cam_cmd_csiphy_info = NULL;
 	size_t                  len;
 	size_t                  remain_len;
+	uint32_t                header_size;
 
 	if (!cfg_dev || !csiphy_dev) {
 		CAM_ERR(CAM_CSIPHY, "Invalid Args");
@@ -201,8 +204,17 @@
 	remain_len -= (size_t)cfg_dev->offset;
 	csl_packet = (struct cam_packet *)
 		(generic_pkt_ptr + (uint32_t)cfg_dev->offset);
+	header_size = csl_packet->header.size;
 
-	if (cam_packet_util_validate_packet(csl_packet,
+	csl_packet_local = (struct cam_packet *)cam_common_mem_kdup(csl_packet, header_size);
+
+	if (!csl_packet_local) {
+		CAM_ERR(CAM_CSIPHY, "Alloc and copy fail");
+		rc = -EINVAL;
+		goto rel_pkt_buf;
+	}
+
+	if (cam_packet_util_validate_packet(csl_packet_local,
 		remain_len)) {
 		CAM_ERR(CAM_CSIPHY, "Invalid packet params");
 		rc = -EINVAL;
@@ -210,8 +222,8 @@
 	}
 
 	cmd_desc = (struct cam_cmd_buf_desc *)
-		((uint32_t *)&csl_packet->payload +
-		csl_packet->cmd_buf_offset / 4);
+		((uint32_t *)&csl_packet_local->payload +
+		csl_packet_local->cmd_buf_offset / 4);
 
 	rc = cam_mem_get_cpu_buf(cmd_desc->mem_handle,
 		&generic_ptr, &len);
@@ -231,7 +243,15 @@
 
 	cmd_buf = (uint32_t *)generic_ptr;
 	cmd_buf += cmd_desc->offset / 4;
-	cam_cmd_csiphy_info = (struct cam_csiphy_info *)cmd_buf;
+
+	cmd_buf_local = (uint32_t *)cam_common_mem_kdup(cmd_buf, cmd_desc->length);
+
+	if (!cmd_buf_local) {
+		CAM_ERR(CAM_CSIPHY, "Alloc and copy fail");
+		rc = -EINVAL;
+		goto rel_pkt_buf;
+	}
+	cam_cmd_csiphy_info = (struct cam_csiphy_info *)cmd_buf_local;
 
 	csiphy_dev->config_count++;
 	csiphy_dev->csiphy_info.lane_cnt += cam_cmd_csiphy_info->lane_cnt;
@@ -257,10 +277,16 @@
 			cam_cmd_csiphy_info, cfg_dev);
 
 	cam_mem_put_cpu_buf(cmd_desc->mem_handle);
+	cam_mem_put_cpu_buf((int32_t) cfg_dev->packet_handle);
+	cam_common_mem_free(csl_packet_local);
+	cam_common_mem_free(cmd_buf_local);
+	return rc;
 
 rel_pkt_buf:
 	cam_mem_put_cpu_buf((int32_t) cfg_dev->packet_handle);
-
+	cam_mem_put_cpu_buf(cmd_desc->mem_handle);
+	cam_common_mem_free(csl_packet_local);
+	cam_common_mem_free(cmd_buf_local);
 	return rc;
 }
 
diff --git a/drivers/media/platform/camx/cam_sensor_module/cam_eeprom/cam_eeprom_core.c b/drivers/media/platform/camx/cam_sensor_module/cam_eeprom/cam_eeprom_core.c
index 8e88467..f11e08f 100644
--- a/drivers/media/platform/camx/cam_sensor_module/cam_eeprom/cam_eeprom_core.c
+++ b/drivers/media/platform/camx/cam_sensor_module/cam_eeprom/cam_eeprom_core.c
@@ -571,7 +571,9 @@
 	struct cam_cmd_buf_desc        *cmd_desc = NULL;
 	uint32_t                       *offset = NULL;
 	uint32_t                       *cmd_buf = NULL;
-	uintptr_t                        generic_pkt_addr;
+	uint32_t                       *cmd_buf_local = NULL;
+	uint32_t                       *cmd_buf_local_head = NULL;
+	uintptr_t                       generic_pkt_addr;
 	size_t                          pkt_len = 0;
 	size_t                          remain_len = 0;
 	uint32_t                        total_cmd_buf_in_bytes = 0;
@@ -628,6 +630,15 @@
 		remain_len = pkt_len - cmd_desc[i].offset;
 		cmd_buf += cmd_desc[i].offset / sizeof(uint32_t);
 
+		cmd_buf_local = (uint32_t *)cam_common_mem_kdup(cmd_buf, total_cmd_buf_in_bytes);
+
+		if (!cmd_buf_local) {
+			CAM_ERR(CAM_EEPROM, "Alloc and copy fail");
+			goto rel_cmd_buf;
+		}
+
+		cmd_buf_local_head = cmd_buf_local;
+
 		if (total_cmd_buf_in_bytes > remain_len) {
 			CAM_ERR(CAM_EEPROM, "Not enough buffer for command");
 			rc = -EINVAL;
@@ -641,10 +652,10 @@
 				rc = -EINVAL;
 				goto rel_cmd_buf;
 			}
-			cmm_hdr = (struct common_header *)cmd_buf;
+			cmm_hdr = (struct common_header *)cmd_buf_local;
 			switch (cmm_hdr->cmd_type) {
 			case CAMERA_SENSOR_CMD_TYPE_I2C_INFO:
-				i2c_info = (struct cam_cmd_i2c_info *)cmd_buf;
+				i2c_info = (struct cam_cmd_i2c_info *)cmd_buf_local;
 				if ((remain_len - processed_cmd_buf_in_bytes) <
 					sizeof(struct cam_cmd_i2c_info)) {
 					CAM_ERR(CAM_EEPROM, "Not enough buf");
@@ -654,24 +665,24 @@
 				/* Configure the following map slave address */
 				map[num_map + 1].saddr = i2c_info->slave_addr;
 				rc = cam_eeprom_update_slaveInfo(e_ctrl,
-					cmd_buf);
+					cmd_buf_local);
 				cmd_length_in_bytes =
 					sizeof(struct cam_cmd_i2c_info);
 				processed_cmd_buf_in_bytes +=
 					cmd_length_in_bytes;
-				cmd_buf += cmd_length_in_bytes/
+				cmd_buf_local += cmd_length_in_bytes/
 					sizeof(uint32_t);
 				break;
 			case CAMERA_SENSOR_CMD_TYPE_PWR_UP:
 			case CAMERA_SENSOR_CMD_TYPE_PWR_DOWN:
 				cmd_length_in_bytes = total_cmd_buf_in_bytes;
-				rc = cam_sensor_update_power_settings(cmd_buf,
+				rc = cam_sensor_update_power_settings(cmd_buf_local,
 					cmd_length_in_bytes, power_info,
 					(remain_len -
 					processed_cmd_buf_in_bytes));
 				processed_cmd_buf_in_bytes +=
 					cmd_length_in_bytes;
-				cmd_buf += cmd_length_in_bytes/
+				cmd_buf_local += cmd_length_in_bytes/
 					sizeof(uint32_t);
 				if (rc) {
 					CAM_ERR(CAM_EEPROM, "Failed");
@@ -683,20 +694,23 @@
 			case CAMERA_SENSOR_CMD_TYPE_WAIT:
 				num_map++;
 				rc = cam_eeprom_parse_memory_map(
-					&e_ctrl->cal_data, cmd_buf,
+					&e_ctrl->cal_data, cmd_buf_local,
 					total_cmd_buf_in_bytes,
 					&cmd_length_in_bytes, &num_map,
 					(remain_len -
 					processed_cmd_buf_in_bytes));
 				processed_cmd_buf_in_bytes +=
 					cmd_length_in_bytes;
-				cmd_buf += cmd_length_in_bytes/sizeof(uint32_t);
+				cmd_buf_local += cmd_length_in_bytes/sizeof(uint32_t);
 				break;
 			default:
 				break;
 			}
 		}
 		e_ctrl->cal_data.num_map = num_map + 1;
+		cam_common_mem_free(cmd_buf_local_head);
+		cmd_buf_local = NULL;
+		cmd_buf_local_head = NULL;
 		cam_mem_put_cpu_buf(cmd_desc[i].mem_handle);
 	}
 
@@ -704,7 +718,7 @@
 
 rel_cmd_buf:
 	cam_mem_put_cpu_buf(cmd_desc[i].mem_handle);
-
+	cam_common_mem_free(cmd_buf_local_head);
 	return rc;
 }
 
@@ -805,9 +819,11 @@
 	size_t                          pkt_len;
 	size_t                          remain_len = 0;
 	struct cam_packet              *csl_packet = NULL;
+	struct cam_packet              *csl_packet_local = NULL;
 	struct cam_eeprom_soc_private  *soc_private =
 		(struct cam_eeprom_soc_private *)e_ctrl->soc_info.soc_private;
 	struct cam_sensor_power_ctrl_t *power_info = &soc_private->power_info;
+	uint32_t                        header_size;
 
 	ioctl_ctrl = (struct cam_control *)arg;
 
@@ -837,15 +853,24 @@
 	remain_len -= (size_t)dev_config.offset;
 	csl_packet = (struct cam_packet *)
 		(generic_pkt_addr + (uint32_t)dev_config.offset);
+	header_size = csl_packet->header.size;
 
-	if (cam_packet_util_validate_packet(csl_packet,
+	csl_packet_local = (struct cam_packet *)cam_common_mem_kdup(csl_packet, header_size);
+
+	if (!csl_packet_local) {
+		CAM_ERR(CAM_EEPROM, "Alloc and copy fail");
+		rc = -EINVAL;
+		goto release_buf;
+	}
+
+	if (cam_packet_util_validate_packet(csl_packet_local,
 		remain_len)) {
 		CAM_ERR(CAM_EEPROM, "Invalid packet params");
 		rc = -EINVAL;
 		goto release_buf;
 	}
 
-	switch (csl_packet->header.op_code & 0xFFFFFF) {
+	switch (csl_packet_local->header.op_code & 0xFFFFFF) {
 	case CAM_EEPROM_PACKET_OPCODE_INIT:
 		if (e_ctrl->userspace_probe == false) {
 			rc = cam_eeprom_parse_read_memory_map(
@@ -854,7 +879,7 @@
 				CAM_ERR(CAM_EEPROM, "Failed: rc : %d", rc);
 				goto release_buf;
 			}
-			rc = cam_eeprom_get_cal_data(e_ctrl, csl_packet);
+			rc = cam_eeprom_get_cal_data(e_ctrl, csl_packet_local);
 			vfree(e_ctrl->cal_data.mapdata);
 			vfree(e_ctrl->cal_data.map);
 			e_ctrl->cal_data.num_data = 0;
@@ -863,7 +888,7 @@
 				"Returning the data using kernel probe");
 			break;
 		}
-		rc = cam_eeprom_init_pkt_parser(e_ctrl, csl_packet);
+		rc = cam_eeprom_init_pkt_parser(e_ctrl, csl_packet_local);
 		if (rc) {
 			CAM_ERR(CAM_EEPROM,
 				"Failed in parsing the pkt");
@@ -893,7 +918,7 @@
 			goto power_down;
 		}
 
-		rc = cam_eeprom_get_cal_data(e_ctrl, csl_packet);
+		rc = cam_eeprom_get_cal_data(e_ctrl, csl_packet_local);
 		rc = cam_eeprom_power_down(e_ctrl);
 		e_ctrl->cam_eeprom_state = CAM_EEPROM_ACQUIRE;
 		vfree(e_ctrl->cal_data.mapdata);
@@ -912,6 +937,7 @@
 	}
 
 	cam_mem_put_cpu_buf(dev_config.packet_handle);
+	cam_common_mem_free(csl_packet_local);
 
 	return rc;
 
@@ -930,6 +956,7 @@
 	e_ctrl->cam_eeprom_state = CAM_EEPROM_ACQUIRE;
 release_buf:
 	cam_mem_put_cpu_buf(dev_config.packet_handle);
+	cam_common_mem_free(csl_packet_local);
 
 	return rc;
 }
diff --git a/drivers/media/platform/camx/cam_sensor_module/cam_sensor/cam_sensor_core.c b/drivers/media/platform/camx/cam_sensor_module/cam_sensor/cam_sensor_core.c
index 21c94fd..a68d912 100644
--- a/drivers/media/platform/camx/cam_sensor_module/cam_sensor/cam_sensor_core.c
+++ b/drivers/media/platform/camx/cam_sensor_module/cam_sensor/cam_sensor_core.c
@@ -93,6 +93,7 @@
 	uintptr_t generic_ptr;
 	struct cam_control *ioctl_ctrl = NULL;
 	struct cam_packet *csl_packet = NULL;
+	struct cam_packet *csl_packet_local = NULL;
 	struct cam_cmd_buf_desc *cmd_desc = NULL;
 	struct i2c_settings_array *i2c_reg_settings = NULL;
 	size_t len_of_buff = 0;
@@ -100,6 +101,7 @@
 	uint32_t *offset = NULL;
 	struct cam_config_dev_cmd config;
 	struct i2c_data_settings *i2c_data = NULL;
+	uint32_t header_size;
 
 	ioctl_ctrl = (struct cam_control *)arg;
 
@@ -136,8 +138,17 @@
 	remain_len -= (size_t)config.offset;
 	csl_packet = (struct cam_packet *)(generic_ptr +
 		(uint32_t)config.offset);
+	header_size = csl_packet->header.size;
 
-	if (cam_packet_util_validate_packet(csl_packet,
+	csl_packet_local = (struct cam_packet *)cam_common_mem_kdup(csl_packet, header_size);
+
+	if (!csl_packet_local) {
+		CAM_ERR(CAM_SENSOR, "Alloc and copy fail");
+		rc = -EINVAL;
+		goto rel_pkt_buf;
+	}
+
+	if (cam_packet_util_validate_packet(csl_packet_local,
 		remain_len)) {
 		CAM_ERR(CAM_SENSOR, "Invalid packet params");
 		rc = -EINVAL;
@@ -145,23 +156,23 @@
 
 	}
 
-	if ((csl_packet->header.op_code & 0xFFFFFF) !=
+	if ((csl_packet_local->header.op_code & 0xFFFFFF) !=
 		CAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG &&
-		csl_packet->header.request_id <= s_ctrl->last_flush_req
+		csl_packet_local->header.request_id <= s_ctrl->last_flush_req
 		&& s_ctrl->last_flush_req != 0) {
 		CAM_ERR(CAM_SENSOR,
 			"reject request %lld, last request to flush %d",
-			csl_packet->header.request_id, s_ctrl->last_flush_req);
+			csl_packet_local->header.request_id, s_ctrl->last_flush_req);
 		rc = -EINVAL;
 		goto rel_pkt_buf;
 	}
 
-	if (csl_packet->header.request_id > s_ctrl->last_flush_req)
+	if (csl_packet_local->header.request_id > s_ctrl->last_flush_req)
 		s_ctrl->last_flush_req = 0;
 
 	i2c_data = &(s_ctrl->i2c_data);
-	CAM_DBG(CAM_SENSOR, "Header OpCode: %d", csl_packet->header.op_code);
-	switch (csl_packet->header.op_code & 0xFFFFFF) {
+	CAM_DBG(CAM_SENSOR, "Header OpCode: %d", csl_packet_local->header.op_code);
+	switch (csl_packet_local->header.op_code & 0xFFFFFF) {
 	case CAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG: {
 		i2c_reg_settings = &i2c_data->init_settings;
 		i2c_reg_settings->request_id = 0;
@@ -204,22 +215,22 @@
 		}
 
 		i2c_reg_settings =
-			&i2c_data->per_frame[csl_packet->header.request_id %
+			&i2c_data->per_frame[csl_packet_local->header.request_id %
 				MAX_PER_FRAME_ARRAY];
 		CAM_DBG(CAM_SENSOR, "Received Packet: %lld req: %lld",
-			csl_packet->header.request_id % MAX_PER_FRAME_ARRAY,
-			csl_packet->header.request_id);
+			csl_packet_local->header.request_id % MAX_PER_FRAME_ARRAY,
+			csl_packet_local->header.request_id);
 		if (i2c_reg_settings->is_settings_valid == 1) {
 			CAM_ERR(CAM_SENSOR,
 				"Already some pkt in offset req : %lld",
-				csl_packet->header.request_id);
+				csl_packet_local->header.request_id);
 			/*
 			 * Update req mgr even in case of failure.
 			 * This will help not to wait indefinitely
 			 * and freeze. If this log is triggered then
 			 * fix it.
 			 */
-			cam_sensor_update_req_mgr(s_ctrl, csl_packet);
+			cam_sensor_update_req_mgr(s_ctrl, csl_packet_local);
 			goto rel_pkt_buf;
 		}
 		break;
@@ -232,7 +243,7 @@
 			goto rel_pkt_buf;
 		}
 
-		cam_sensor_update_req_mgr(s_ctrl, csl_packet);
+		cam_sensor_update_req_mgr(s_ctrl, csl_packet_local);
 		goto rel_pkt_buf;
 	}
 	default:
@@ -241,8 +252,8 @@
 		goto rel_pkt_buf;
 	}
 
-	offset = (uint32_t *)&csl_packet->payload;
-	offset += csl_packet->cmd_buf_offset / 4;
+	offset = (uint32_t *)&csl_packet_local->payload;
+	offset += csl_packet_local->cmd_buf_offset / 4;
 	cmd_desc = (struct cam_cmd_buf_desc *)(offset);
 
 	rc = cam_sensor_i2c_command_parser(&s_ctrl->io_master_info,
@@ -252,16 +263,19 @@
 		goto rel_pkt_buf;
 	}
 
-	if ((csl_packet->header.op_code & 0xFFFFFF) ==
+	if ((csl_packet_local->header.op_code & 0xFFFFFF) ==
 		CAM_SENSOR_PACKET_OPCODE_SENSOR_UPDATE) {
 		i2c_reg_settings->request_id =
-			csl_packet->header.request_id;
-		cam_sensor_update_req_mgr(s_ctrl, csl_packet);
+			csl_packet_local->header.request_id;
+		cam_sensor_update_req_mgr(s_ctrl, csl_packet_local);
 	}
+	cam_mem_put_cpu_buf(config.packet_handle);
+	cam_common_mem_free(csl_packet_local);
+	return rc;
 
 rel_pkt_buf:
 	cam_mem_put_cpu_buf(config.packet_handle);
-
+	cam_common_mem_free(csl_packet_local);
 	return rc;
 }
 
@@ -438,13 +452,16 @@
 {
 	int rc = 0, i;
 	uint32_t *cmd_buf;
+	uint32_t *cmd_buf_local = NULL;
 	void *ptr;
 	size_t len;
 	struct cam_packet *pkt = NULL;
+	struct cam_packet *pkt_local = NULL;
 	struct cam_cmd_buf_desc *cmd_desc = NULL;
 	uintptr_t cmd_buf1 = 0;
 	uintptr_t packet = 0;
 	size_t    remain_len = 0;
+	uint32_t header_size;
 
 	rc = cam_mem_get_cpu_buf(handle,
 		&packet, &len);
@@ -459,29 +476,38 @@
 		rc = -EINVAL;
 		goto rel_pkt_buf;
 	}
+	header_size = pkt->header.size;
+
+	pkt_local = (struct cam_packet *)cam_common_mem_kdup(pkt, header_size);
+
+	if (!pkt_local) {
+		CAM_ERR(CAM_SENSOR, "Alloc and copy fail");
+		rc = -EINVAL;
+		goto rel_pkt_buf;
+	}
 
 	if ((len < sizeof(struct cam_packet)) ||
-		(pkt->cmd_buf_offset >= (len - sizeof(struct cam_packet)))) {
+		(pkt_local->cmd_buf_offset >= (len - sizeof(struct cam_packet)))) {
 		CAM_ERR(CAM_SENSOR, "Not enough buf provided");
 		rc = -EINVAL;
 		goto rel_pkt_buf;
 	}
 
 	cmd_desc = (struct cam_cmd_buf_desc *)
-		((uint32_t *)&pkt->payload + pkt->cmd_buf_offset/4);
+		((uint32_t *)&pkt_local->payload + pkt_local->cmd_buf_offset/4);
 	if (cmd_desc == NULL) {
 		CAM_ERR(CAM_SENSOR, "command descriptor pos is invalid");
 		rc = -EINVAL;
 		goto rel_pkt_buf;
 	}
-	if (pkt->num_cmd_buf != 2) {
+	if (pkt_local->num_cmd_buf != 2) {
 		CAM_ERR(CAM_SENSOR, "Expected More Command Buffers : %d",
-			 pkt->num_cmd_buf);
+			 pkt_local->num_cmd_buf);
 		rc = -EINVAL;
 		goto rel_pkt_buf;
 	}
 
-	for (i = 0; i < pkt->num_cmd_buf; i++) {
+	for (i = 0; i < pkt_local->num_cmd_buf; i++) {
 		if (!(cmd_desc[i].length))
 			continue;
 		rc = cam_mem_get_cpu_buf(cmd_desc[i].mem_handle,
@@ -495,18 +521,27 @@
 			CAM_ERR(CAM_SENSOR,
 				"offset past length of buffer");
 			rc = -EINVAL;
-			goto rel_pkt_buf;
+			goto rel_cmd_buf;
 		}
 		remain_len = len - cmd_desc[i].offset;
 		if (cmd_desc[i].length > remain_len) {
 			CAM_ERR(CAM_SENSOR,
 				"Not enough buffer provided for cmd");
 			rc = -EINVAL;
-			goto rel_pkt_buf;
+			goto rel_cmd_buf;
 		}
 		cmd_buf = (uint32_t *)cmd_buf1;
 		cmd_buf += cmd_desc[i].offset/4;
-		ptr = (void *) cmd_buf;
+
+		cmd_buf_local = cam_common_mem_kdup(cmd_buf, cmd_desc[i].length);
+
+		if (!cmd_buf_local) {
+			CAM_ERR(CAM_SENSOR, "Alloc and copy fail");
+			rc = -EINVAL;
+			goto rel_cmd_buf;
+		}
+
+		ptr = (void *) cmd_buf_local;
 
 		rc = cam_handle_cmd_buffers_for_probe(ptr, s_ctrl,
 			i, cmd_desc[i].length, remain_len);
@@ -517,17 +552,23 @@
 		}
 
 		cam_mem_put_cpu_buf(cmd_desc[i].mem_handle);
+		cam_common_mem_free(cmd_buf_local);
+		cmd_buf_local = NULL;
 	}
 
 	cam_mem_put_cpu_buf(handle);
 
+	cam_common_mem_free(pkt_local);
 	return rc;
 
 rel_cmd_buf:
 	cam_mem_put_cpu_buf(cmd_desc[i].mem_handle);
+	cam_common_mem_free(pkt_local);
+	cam_common_mem_free(cmd_buf_local);
+	return rc;
 rel_pkt_buf:
 	cam_mem_put_cpu_buf(handle);
-
+	cam_common_mem_free(pkt_local);
 	return rc;
 }
 
diff --git a/drivers/media/platform/camx/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c b/drivers/media/platform/camx/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c
index a2cdb0a..02638cd 100644
--- a/drivers/media/platform/camx/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c
+++ b/drivers/media/platform/camx/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c
@@ -13,6 +13,7 @@
 
 #include <linux/kernel.h>
 #include "cam_sensor_util.h"
+#include "cam_common_util.h"
 #include <cam_mem_mgr.h>
 #include "cam_res_mgr_api.h"
 
@@ -301,6 +302,8 @@
 	uint16_t                  cmd_length_in_bytes = 0;
 	size_t                    remain_len = 0;
 	size_t                    tot_size = 0;
+	uint32_t                 *cmd_buf_local = NULL;
+	uint32_t                 *cmd_buf_local_head = NULL;
 
 	for (i = 0; i < num_cmd_buffers; i++) {
 		uint32_t                  *cmd_buf = NULL;
@@ -334,15 +337,27 @@
 			(cmd_desc[i].offset >
 			(len_of_buff - sizeof(struct common_header)))) {
 			CAM_ERR(CAM_SENSOR, "buffer provided too small");
-			return -EINVAL;
+			rc = -EINVAL;
+			goto rel_buf;
 		}
 		cmd_buf = (uint32_t *)generic_ptr;
 		cmd_buf += cmd_desc[i].offset / sizeof(uint32_t);
 
+		cmd_buf_local = (uint32_t *)cam_common_mem_kdup(cmd_buf, cmd_desc[i].length);
+
+		if (!cmd_buf_local) {
+			CAM_ERR(CAM_SENSOR, "Alloc and copy fail");
+			rc = -EINVAL;
+			goto rel_buf;
+		}
+
+		cmd_buf_local_head = cmd_buf_local;
+
 		remain_len -= cmd_desc[i].offset;
 		if (remain_len < cmd_desc[i].length) {
 			CAM_ERR(CAM_SENSOR, "buffer provided too small");
-			return -EINVAL;
+			rc = -EINVAL;
+			goto rel_buf;
 		}
 
 		while (byte_cnt < cmd_desc[i].length) {
@@ -352,14 +367,14 @@
 				rc = -EINVAL;
 				goto rel_buf;
 			}
-			cmm_hdr = (struct common_header *)cmd_buf;
+			cmm_hdr = (struct common_header *)cmd_buf_local;
 			generic_op_code = cmm_hdr->third_byte;
 			switch (cmm_hdr->cmd_type) {
 			case CAMERA_SENSOR_CMD_TYPE_I2C_RNDM_WR: {
 				uint16_t cmd_length_in_bytes   = 0;
 				struct cam_cmd_i2c_random_wr
 					*cam_cmd_i2c_random_wr =
-					(struct cam_cmd_i2c_random_wr *)cmd_buf;
+					(struct cam_cmd_i2c_random_wr *)cmd_buf_local;
 
 				if ((remain_len - byte_cnt) <
 					sizeof(struct cam_cmd_i2c_random_wr)) {
@@ -390,7 +405,7 @@
 					goto rel_buf;
 				}
 
-				cmd_buf += cmd_length_in_bytes /
+				cmd_buf_local += cmd_length_in_bytes /
 					sizeof(uint32_t);
 				byte_cnt += cmd_length_in_bytes;
 				break;
@@ -400,7 +415,7 @@
 				struct cam_cmd_i2c_continuous_wr
 				*cam_cmd_i2c_continuous_wr =
 				(struct cam_cmd_i2c_continuous_wr *)
-				cmd_buf;
+				cmd_buf_local;
 
 				if ((remain_len - byte_cnt) <
 				sizeof(struct cam_cmd_i2c_continuous_wr)) {
@@ -432,7 +447,7 @@
 					goto rel_buf;
 				}
 
-				cmd_buf += cmd_length_in_bytes /
+				cmd_buf_local += cmd_length_in_bytes /
 					sizeof(uint32_t);
 				byte_cnt += cmd_length_in_bytes;
 				break;
@@ -450,7 +465,7 @@
 					generic_op_code ==
 						CAMERA_SENSOR_WAIT_OP_SW_UCND) {
 					rc = cam_sensor_handle_delay(
-						&cmd_buf, generic_op_code,
+						&cmd_buf_local, generic_op_code,
 						i2c_reg_settings, j, &byte_cnt,
 						list);
 					if (rc < 0) {
@@ -463,7 +478,7 @@
 				} else if (generic_op_code ==
 					CAMERA_SENSOR_WAIT_OP_COND) {
 					rc = cam_sensor_handle_poll(
-						&cmd_buf, i2c_reg_settings,
+						&cmd_buf_local, i2c_reg_settings,
 						&byte_cnt, &j, &list);
 					if (rc < 0) {
 						CAM_ERR(CAM_SENSOR,
@@ -489,7 +504,7 @@
 					goto rel_buf;
 				}
 				rc = cam_sensor_handle_slave_info(
-					io_master, cmd_buf);
+					io_master, cmd_buf_local);
 				if (rc) {
 					CAM_ERR(CAM_SENSOR,
 					"Handle slave info failed with rc: %d",
@@ -498,7 +513,7 @@
 				}
 				cmd_length_in_bytes =
 					sizeof(struct cam_cmd_i2c_info);
-				cmd_buf +=
+				cmd_buf_local +=
 					cmd_length_in_bytes / sizeof(uint32_t);
 				byte_cnt += cmd_length_in_bytes;
 				break;
@@ -511,6 +526,9 @@
 			}
 		}
 		i2c_reg_settings->is_settings_valid = 1;
+		cam_common_mem_free(cmd_buf_local_head);
+		cmd_buf_local = NULL;
+		cmd_buf_local_head = NULL;
 		cam_mem_put_cpu_buf(cmd_desc[i].mem_handle);
 	}
 
@@ -518,6 +536,7 @@
 
 rel_buf:
 	cam_mem_put_cpu_buf(cmd_desc[i].mem_handle);
+	cam_common_mem_free(cmd_buf_local_head);
 	return rc;
 }
 
