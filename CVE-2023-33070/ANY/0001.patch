From eecbc8822ffdab4628b70738c58a0bcae10d294f Mon Sep 17 00:00:00 2001
From: Dheeraj Kumar Chaudhary <quic_dheech@quicinc.com>
Date: Wed, 11 Jan 2023 11:00:42 +0530
Subject: [PATCH] pinctrl: qcom: Using readl_relaxed/writel_relaxed APIs

Replacing scm_io_read/scm_io_write with readl_relaxed/writel_relaxed
respectively.

Change-Id: I0f509047d2523a1cb51d999dd8c3eec8ab9fd2f2
Signed-off-by: Dheeraj Kumar Chaudhary <quic_dheech@quicinc.com>
---
 drivers/pinctrl/qcom/pinctrl-msm.c | 20 +++++++++++++-------
 1 file changed, 13 insertions(+), 7 deletions(-)

diff --git a/drivers/pinctrl/qcom/pinctrl-msm.c b/drivers/pinctrl/qcom/pinctrl-msm.c
index 2eec26f7fbd53..a00375e7be2f7 100644
--- a/drivers/pinctrl/qcom/pinctrl-msm.c
+++ b/drivers/pinctrl/qcom/pinctrl-msm.c
@@ -91,6 +91,7 @@ struct msm_pinctrl {
 	const struct msm_pinctrl_soc_data *soc;
 	void __iomem *regs;
 	void __iomem *pdc_regs;
+	void __iomem *spi_base;
 #ifdef CONFIG_FRAGMENTED_GPIO_ADDRESS_SPACE
 	/* For holding per tile virtual address */
 	void __iomem *per_tile_regs[4];
@@ -1427,6 +1428,7 @@ static void add_dirconn_tlmm(struct irq_data *d, irq_hw_number_t irq)
 	struct msm_pinctrl *pctrl;
 	phys_addr_t spi_cfg_reg = 0;
 	unsigned long flags;
+	u32 offset_local;
 
 	offset = select_dir_conn_mux(d, &irq);
 	if (offset < 0 || !parent_data)
@@ -1447,16 +1449,17 @@ static void add_dirconn_tlmm(struct irq_data *d, irq_hw_number_t irq)
 		if (pctrl->spi_cfg_regs) {
 			spi_cfg_reg = pctrl->spi_cfg_regs +
 					((dir_conn_data->hwirq - 32) / 32) * 4;
+			offset_local = ((dir_conn_data->hwirq - 32) / 32) * 4;
 			if (spi_cfg_reg < pctrl->spi_cfg_end) {
 				raw_spin_lock_irqsave(&pctrl->lock, flags);
-				val = scm_io_read(spi_cfg_reg);
+				val = readl_relaxed(pctrl->spi_base + offset_local);
 				/*
 				 * Clear the respective bit for edge type
 				 * interrupt
 				 */
 				val &= ~(1 << ((dir_conn_data->hwirq - 32)
 									% 32));
-				WARN_ON(scm_io_write(spi_cfg_reg, val));
+				writel_relaxed(val, pctrl->spi_base + offset_local);
 				raw_spin_unlock_irqrestore(&pctrl->lock, flags);
 			} else
 				pr_err("%s: type config failed for SPI: %lu\n",
@@ -1510,6 +1513,7 @@ static int msm_dirconn_irq_set_type(struct irq_data *d, unsigned int type)
 	unsigned int config_val = 0;
 	unsigned int val = 0;
 	unsigned long flags;
+	u32 offset_local;
 
 	if (!parent_data)
 		return 0;
@@ -1537,13 +1541,14 @@ static int msm_dirconn_irq_set_type(struct irq_data *d, unsigned int type)
 	if (pctrl->spi_cfg_regs && type != IRQ_TYPE_NONE) {
 		spi_cfg_reg = pctrl->spi_cfg_regs +
 				((parent_data->hwirq - 32) / 32) * 4;
+		offset_local = ((parent_data->hwirq - 32) / 32) * 4;
 		if (spi_cfg_reg < pctrl->spi_cfg_end) {
 			raw_spin_lock_irqsave(&pctrl->lock, flags);
-			val = scm_io_read(spi_cfg_reg);
+			val = readl_relaxed(pctrl->spi_base + offset_local);
 			val &= ~(1 << ((parent_data->hwirq - 32) % 32));
 			if (config_val)
 				val |= (1 << ((parent_data->hwirq - 32)  % 32));
-			WARN_ON(scm_io_write(spi_cfg_reg, val));
+			writel_relaxed(val, pctrl->spi_base + offset_local);
 			raw_spin_unlock_irqrestore(&pctrl->lock, flags);
 		} else
 			pr_err("%s: type config failed for SPI: %lu\n",
@@ -1898,7 +1903,7 @@ static int msm_pinctrl_hibernation_suspend(void)
 		spi_cfg_reg = pctrl->spi_cfg_regs;
 		for (j = 0; j < spi_cfg_regs_count; j++)
 			pctrl->spi_cfg_regs_val[j] =
-				scm_io_read(spi_cfg_reg + j * 4);
+				readl_relaxed(pctrl->spi_base + j * 4);
 	}
 	/* All normal gpios will have common registers, first save them */
 	for (i = 0; i < soc->ngpios; i++) {
@@ -1955,8 +1960,8 @@ static void msm_pinctrl_hibernation_resume(void)
 				pctrl->spi_cfg_regs) / 4 + 2;
 		spi_cfg_reg = pctrl->spi_cfg_regs;
 		for (j = 0; j < spi_cfg_regs_count; j++)
-			WARN_ON(scm_io_write(spi_cfg_reg + j * 4,
-				pctrl->spi_cfg_regs_val[j]));
+			writel_relaxed(pctrl->spi_cfg_regs_val[j],
+					pctrl->spi_base + j * 4);
 	}
 
 	/* Restore normal gpios */
@@ -2089,6 +2094,7 @@ int msm_pinctrl_probe(struct platform_device *pdev,
 	key = "spi_cfg";
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, key);
 	if (res) {
+		pctrl->spi_base = devm_ioremap_resource(&pdev->dev, res);
 		pctrl->spi_cfg_regs = res->start;
 		pctrl->spi_cfg_end = res->end;
 	}
-- 
GitLab

