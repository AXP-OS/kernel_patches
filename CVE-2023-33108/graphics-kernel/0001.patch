From 68341b499048b6ca391fa87f8ed7b6f6e479a67f Mon Sep 17 00:00:00 2001
From: Lynus Vaz <quic_lvaz@quicinc.com>
Date: Tue, 22 Aug 2023 14:31:43 -0700
Subject: [PATCH] msm: kgsl: Simplify timelineobj cleanup

Use the same path for timelineobj retire and destroy. This keeps the
timelineobj valid until the preceding cmdbatches retire, and the scheduler
retires it during normal operation or context detach. This simplifies
cleanup when userspace detaches a context with timelineobjs in flight.

Change-Id: I8812acd045ee13bf965fea1361cf867baf7345a0
Signed-off-by: Lynus Vaz <quic_lvaz@quicinc.com>
(cherry picked from commit 65d32f9946e3eac5813252a22b8457a841ccf4b7)
---
 adreno_dispatch.c |  5 +--
 adreno_hwsched.c  |  4 +-
 kgsl_drawobj.c    | 93 ++++++++++++++++++++++++++++-------------------
 kgsl_drawobj.h    |  8 ----
 4 files changed, 57 insertions(+), 53 deletions(-)

diff --git a/adreno_dispatch.c b/adreno_dispatch.c
index bb0ae08..1ff221f 100644
--- a/adreno_dispatch.c
+++ b/adreno_dispatch.c
@@ -364,11 +364,8 @@ static int dispatch_retire_syncobj(struct kgsl_drawobj *drawobj,
 static int drawqueue_retire_timelineobj(struct kgsl_drawobj *drawobj,
 		struct adreno_context *drawctxt)
 {
-	struct kgsl_drawobj_timeline *timelineobj = TIMELINEOBJ(drawobj);
-
 	_pop_drawobj(drawctxt);
-	kgsl_drawobj_timelineobj_retire(timelineobj);
-
+	kgsl_drawobj_destroy(drawobj);
 	return 0;
 }
 
diff --git a/adreno_hwsched.c b/adreno_hwsched.c
index 1ebbf6e..da7f574 100644
--- a/adreno_hwsched.c
+++ b/adreno_hwsched.c
@@ -195,10 +195,8 @@ static int _retire_markerobj(struct adreno_device *adreno_dev, struct kgsl_drawo
 static int _retire_timelineobj(struct kgsl_drawobj *drawobj,
 		struct adreno_context *drawctxt)
 {
-	struct kgsl_drawobj_timeline *timelineobj = TIMELINEOBJ(drawobj);
-
 	_pop_drawobj(drawctxt);
-	kgsl_drawobj_timelineobj_retire(timelineobj);
+	kgsl_drawobj_destroy(drawobj);
 	return 0;
 }
 
diff --git a/kgsl_drawobj.c b/kgsl_drawobj.c
index d9ecc6e..f1fdc7b 100644
--- a/kgsl_drawobj.c
+++ b/kgsl_drawobj.c
@@ -393,12 +393,16 @@ static void syncobj_destroy(struct kgsl_drawobj *drawobj)
 
 }
 
-static void timelineobj_destroy(struct kgsl_drawobj *drawobj)
+static void _drawobj_timelineobj_retire(struct kref *kref)
 {
-	struct kgsl_drawobj_timeline *timelineobj = TIMELINEOBJ(drawobj);
 	int i;
+	struct kgsl_drawobj_timeline *timelineobj = container_of(kref,
+				struct kgsl_drawobj_timeline, sig_refcount);
 
 	for (i = 0; i < timelineobj->count; i++) {
+		kgsl_timeline_signal(timelineobj->timelines[i].timeline,
+			timelineobj->timelines[i].seqno);
+
 		kgsl_timeline_put(timelineobj->timelines[i].timeline);
 		kgsl_context_put(timelineobj->timelines[i].context);
 	}
@@ -408,6 +412,32 @@ static void timelineobj_destroy(struct kgsl_drawobj *drawobj)
 	timelineobj->count = 0;
 }
 
+static void kgsl_timelineobj_signal(struct kgsl_drawobj_timeline *timelineobj)
+{
+	kref_put(&timelineobj->sig_refcount, _drawobj_timelineobj_retire);
+}
+
+static void timelineobj_destroy(struct kgsl_drawobj *drawobj)
+{
+	struct kgsl_drawobj_timeline *timelineobj = TIMELINEOBJ(drawobj);
+	int i;
+
+	/*
+	 * At this point any syncobjs blocking this timelinobj have been
+	 * signaled. The timelineobj now only needs all preceding timestamps to
+	 * retire before signaling the timelines. Notify timelines to keep them
+	 * in sync with the timestamps as they retire.
+	 */
+	for (i = 0; i < timelineobj->count; i++)
+		kgsl_timeline_add_signal(&timelineobj->timelines[i]);
+
+	/*
+	 * The scheduler is done with the timelineobj. Put the initial
+	 * sig_refcount to continue with the signaling process.
+	 */
+	kgsl_timelineobj_signal(timelineobj);
+}
+
 static void bindobj_destroy(struct kgsl_drawobj *drawobj)
 {
 	struct kgsl_drawobj_bind *bindobj = BINDOBJ(drawobj);
@@ -938,7 +968,8 @@ kgsl_drawobj_timeline_create(struct kgsl_device *device,
 	 * Initialize the sig_refcount that triggers the timeline signal.
 	 * This refcount goes to 0 when:
 	 * 1) This timelineobj is popped off the context queue. This implies
-	 *    any syncobj blocking this timelineobj was already signaled.
+	 *    any syncobj blocking this timelineobj was already signaled, or
+	 *    the context queue is cleaned up at detach time.
 	 * 2) The cmdobjs queued on this context before this timeline object
 	 *    are retired.
 	 */
@@ -950,43 +981,17 @@ kgsl_drawobj_timeline_create(struct kgsl_device *device,
 	return timelineobj;
 }
 
-static void _drawobj_timelineobj_retire(struct kref *kref)
-{
-	struct kgsl_drawobj_timeline *timelineobj = container_of(kref,
-		struct kgsl_drawobj_timeline, sig_refcount);
-	struct kgsl_drawobj *drawobj = DRAWOBJ(timelineobj);
-	int i;
-
-	for (i = 0; i < timelineobj->count; i++)
-		kgsl_timeline_signal(timelineobj->timelines[i].timeline,
-			timelineobj->timelines[i].seqno);
-
-	/* Now that timelines are signaled destroy the drawobj */
-	kgsl_drawobj_destroy(drawobj);
-}
-
 static void _timeline_signaled(struct kgsl_device *device,
 		struct kgsl_event_group *group, void *priv, int ret)
 {
 	struct kgsl_drawobj_timeline *timelineobj = priv;
+	struct kgsl_drawobj *drawobj = DRAWOBJ(timelineobj);
 
-	kref_put(&timelineobj->sig_refcount, _drawobj_timelineobj_retire);
-}
-
-void kgsl_drawobj_timelineobj_retire(struct kgsl_drawobj_timeline *timelineobj)
-{
-	int i;
+	/* Put the sig_refcount we took when registering this event */
+	kgsl_timelineobj_signal(timelineobj);
 
-	/*
-	 * At this point any syncobjs blocking this timelinobj have been
-	 * signaled. The timelineobj now only needs all preceding timestamps to
-	 * retire before signaling the timelines. Notify timelines to keep them
-	 * in sync with the timestamps as they retire.
-	 */
-	for (i = 0; i < timelineobj->count; i++)
-		kgsl_timeline_add_signal(&timelineobj->timelines[i]);
-
-	kref_put(&timelineobj->sig_refcount, _drawobj_timelineobj_retire);
+	/* Put the drawobj refcount we took when registering this event */
+	kgsl_drawobj_put(drawobj);
 }
 
 int kgsl_drawobj_add_timeline(struct kgsl_device_private *dev_priv,
@@ -1063,18 +1068,30 @@ int kgsl_drawobj_add_timeline(struct kgsl_device_private *dev_priv,
 	timelineobj->count = cmd.count;
 
 	/*
-	 * Take a refcount that we put when the last queued timestamp on this
-	 * context is retired. Use a kgsl_event to notify us when this
-	 * timestamp retires.
+	 * Register a kgsl_event to notify us when the last queued timestamp
+	 * retires. Take a refcount on the drawobj to keep it valid for the
+	 * callback, and take the sig_refcount to synchronize with the
+	 * timelineobj retire. Both these refcounts are put in the callback.
 	 */
+	kref_get(&drawobj->refcount);
 	kref_get(&timelineobj->sig_refcount);
 	ret = kgsl_add_event(device, &context->events, queued,
 			_timeline_signaled, timelineobj);
 
 	if (ret)
-		goto err;
+		goto event_err;
 
 	return 0;
+
+event_err:
+	/*
+	 * If there was an error, put back sig_refcount and drawobj refcounts.
+	 * The caller still holds initial refcounts on both and puts them in
+	 * kgsl_drawobj_destroy(). Clean up the timelinelines array since we
+	 * do not want to signal anything now.
+	 */
+	kgsl_timelineobj_signal(timelineobj);
+	kgsl_drawobj_put(drawobj);
 err:
 	for (i = 0; i < cmd.count; i++) {
 		kgsl_timeline_put(timelineobj->timelines[i].timeline);
diff --git a/kgsl_drawobj.h b/kgsl_drawobj.h
index f60d838..138df54 100644
--- a/kgsl_drawobj.h
+++ b/kgsl_drawobj.h
@@ -345,12 +345,4 @@ int kgsl_drawobj_add_timeline(struct kgsl_device_private *dev_priv,
 		struct kgsl_drawobj_timeline *timelineobj,
 		void __user *src, u64 cmdsize);
 
-/**
- * kgsl_drawobj_timelineobj_retire - Retire the timeline drawobj
- * @timelineobj: Pointer to a timeline drawobject
- *
- * Retire the timelineobj when it is popped off the context queue.
- */
-void kgsl_drawobj_timelineobj_retire(struct kgsl_drawobj_timeline *timelineobj);
-
 #endif /* __KGSL_DRAWOBJ_H */
-- 
GitLab

