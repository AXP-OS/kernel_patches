From b8d8af85afc47a8855f26a9e41892ed78450df05 Mon Sep 17 00:00:00 2001
From: Fenil Panwala <quic_fpanwala@quicinc.com>
Date: Mon, 8 Apr 2024 16:24:45 +0530
Subject: [PATCH] memshare: Prevent possible integer overflow

Prevent possible integer overflow by sanitizing the alloc request
size coming from the client against allottable amount of memory.

Original-Change-Id: I74cb0f7b0808f20299586969fd5c810d44c3e576
Change-Id: I435b1755f16a5e5ce340848854ccb60b84291657
Signed-off-by: Manoj Prabhu B <quic_bmanoj@quicinc.com>
Signed-off-by: Fenil Panwala <quic_fpanwala@quicinc.com>
---
 drivers/soc/qcom/memshare/msm_memshare.c | 15 ++++++++++-----
 drivers/soc/qcom/memshare/msm_memshare.h |  3 +++
 2 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/soc/qcom/memshare/msm_memshare.c b/drivers/soc/qcom/memshare/msm_memshare.c
index 6542861a2f48..b2595dfcf633 100644
--- a/drivers/soc/qcom/memshare/msm_memshare.c
+++ b/drivers/soc/qcom/memshare/msm_memshare.c
@@ -1,4 +1,5 @@
 /* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -564,8 +565,11 @@ static int handle_alloc_generic_req(void *req_h, void *req, void *conn_h)
 		return -EINVAL;
 	}
 
-	if (!memblock[client_id].allotted) {
-		if (alloc_req->client_id == 1 && alloc_req->num_bytes > 0)
+	if (!memblock[client_id].allotted && alloc_req->num_bytes > 0) {
+		if (alloc_req->num_bytes > memblock[client_id].init_size)
+			alloc_req->num_bytes = memblock[client_id].init_size;
+
+		if (alloc_req->client_id == 1)
 			size = alloc_req->num_bytes + MEMSHARE_GUARD_BYTES;
 		else
 			size = alloc_req->num_bytes;
@@ -751,9 +755,9 @@ static int handle_query_size_req(void *req_h, void *req, void *conn_h)
 		return -EINVAL;
 	}
 
-	if (memblock[client_id].size) {
+	if (memblock[client_id].init_size) {
 		query_resp->size_valid = 1;
-		query_resp->size = memblock[client_id].size;
+		query_resp->size = memblock[client_id].init_size;
 	} else {
 		query_resp->size_valid = 1;
 		query_resp->size = 0;
@@ -1013,7 +1017,7 @@ static int memshare_child_probe(struct platform_device *pdev)
 	else if (strcmp(name, "wcnss") == 0)
 		memblock[num_clients].peripheral = DHMS_MEM_PROC_WCNSS_V01;
 
-	memblock[num_clients].size = size;
+	memblock[num_clients].init_size = size;
 	memblock[num_clients].client_id = client_id;
 
   /*
@@ -1030,6 +1034,7 @@ static int memshare_child_probe(struct platform_device *pdev)
 							__func__, rc);
 			return rc;
 		}
+		memblock[num_clients].size = size;
 		memblock[num_clients].allotted = 1;
 		shared_hyp_mapping(num_clients);
 	}
diff --git a/drivers/soc/qcom/memshare/msm_memshare.h b/drivers/soc/qcom/memshare/msm_memshare.h
index 908f091c86eb..d8ba1f81a5ab 100644
--- a/drivers/soc/qcom/memshare/msm_memshare.h
+++ b/drivers/soc/qcom/memshare/msm_memshare.h
@@ -1,4 +1,5 @@
 /* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -45,6 +46,8 @@ struct mem_blocks {
 	uint32_t client_request;
 	/* Size required for client */
 	uint32_t size;
+	/* Available memory size for client */
+	uint32_t init_size;
 	/*
 	 * start address of the memory block reserved by server memory
 	 * subsystem to client
