From d95862141ad7b0d0ad542ce8bc46d0fb4d772707 Mon Sep 17 00:00:00 2001
From: Pankaj Gupta <quic_gpankaj@quicinc.com>
Date: Tue, 2 Jan 2024 19:39:16 +0530
Subject: [PATCH] kgsl: Prevent wrapped around VA range allocation

Sanitize size param in gpumem_alloc_vbo_entry() to avoid integer
overflow in _get_unmapped_area(). This overflow may end up in
allocating a wrapped-around VA range, which can overlap with already
in use VA.

Change-Id: I5b4e74ce8c8e8e3323822efe40abf1f355fd3bc3
Signed-off-by: Pankaj Gupta <quic_gpankaj@quicinc.com>
(cherry picked from commit 4131ef0ad2d38cb9a438756de94bf9fca0d51f0e)
---
 kgsl.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/kgsl.c b/kgsl.c
index 249f0ba1..4d861150 100644
--- a/kgsl.c
+++ b/kgsl.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2008-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <uapi/linux/sched/types.h>
@@ -4036,6 +4036,14 @@ static u64 cap_alignment(struct kgsl_device *device, u64 flags)
 	return flags | FIELD_PREP(KGSL_MEMALIGN_MASK, align);
 }
 
+static u64 gpumem_max_va_size(struct kgsl_pagetable *pt, u64 flags)
+{
+	if (flags & KGSL_MEMFLAGS_FORCE_32BIT)
+		return pt->compat_va_end - pt->compat_va_start;
+
+	return pt->va_end - pt->va_start;
+}
+
 static struct kgsl_mem_entry *
 gpumem_alloc_vbo_entry(struct kgsl_device_private *dev_priv,
 		u64 size, u64 flags)
@@ -4044,6 +4052,7 @@ gpumem_alloc_vbo_entry(struct kgsl_device_private *dev_priv,
 	struct kgsl_device *device = dev_priv->device;
 	struct kgsl_memdesc *memdesc;
 	struct kgsl_mem_entry *entry;
+	struct kgsl_pagetable *pt;
 	int ret;
 
 	/* Disallow specific flags */
@@ -4064,6 +4073,12 @@ gpumem_alloc_vbo_entry(struct kgsl_device_private *dev_priv,
 	if ((flags & KGSL_MEMFLAGS_SECURE) && !check_and_warn_secured(device))
 		return ERR_PTR(-EOPNOTSUPP);
 
+	pt = (flags & KGSL_MEMFLAGS_SECURE) ?
+			device->mmu.securepagetable : private->pagetable;
+
+	if (!size || (size > gpumem_max_va_size(pt, flags)))
+		return ERR_PTR(-EINVAL);
+
 	flags = cap_alignment(device, flags);
 
 	entry = kgsl_mem_entry_create();
-- 
GitLab

