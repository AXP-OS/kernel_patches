From 25c49620c22e375fbd69631ea1eb408ed43db6e0 Mon Sep 17 00:00:00 2001
From: Sanjay Yadav <quic_sanjyada@quicinc.com>
Date: Wed, 31 Jan 2024 17:41:51 +0530
Subject: [PATCH] msm: kgsl: Put VBO child refcount if unmap succeeds

If the VBO range cannot be unmapped the underlying physical memory should
not be freed. Enforce this by not decrementing the mem entry's refcount.

Change-Id: Ia9d12589fbfa849ae7e2bef8e1cdbb9cf8f33364
Signed-off-by: Lynus Vaz <quic_lvaz@quicinc.com>
Signed-off-by: Sanjay Yadav <quic_sanjyada@quicinc.com>
---
 drivers/gpu/msm/kgsl_vbo.c | 28 +++++++++++++++-------------
 1 file changed, 15 insertions(+), 13 deletions(-)

diff --git a/drivers/gpu/msm/kgsl_vbo.c b/drivers/gpu/msm/kgsl_vbo.c
index aead43fc6514a..2ab97c3f5ba0a 100644
--- a/drivers/gpu/msm/kgsl_vbo.c
+++ b/drivers/gpu/msm/kgsl_vbo.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2023-2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/file.h>
@@ -46,6 +46,12 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
 	return range;
 }
 
+static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
+{
+	kgsl_mem_entry_put(range->entry);
+	kfree(range);
+}
+
 static u64 bind_range_len(struct kgsl_memdesc_bind_range *range)
 {
 	return (range->range.last - range->range.start) + 1;
@@ -113,8 +119,7 @@ static void kgsl_memdesc_remove_range(struct kgsl_mem_entry *target,
 			kgsl_mmu_map_zero_page_to_range(memdesc->pagetable,
 				memdesc, range->range.start, bind_range_len(range));
 
-			kgsl_mem_entry_put(range->entry);
-			kfree(range);
+			bind_range_destroy(range);
 		}
 	}
 
@@ -161,8 +166,7 @@ static int kgsl_memdesc_add_range(struct kgsl_mem_entry *target,
 
 		if (start <= cur->range.start) {
 			if (last >= cur->range.last) {
-				kgsl_mem_entry_put(cur->entry);
-				kfree(cur);
+				bind_range_destroy(cur);
 				continue;
 			}
 			/* Adjust the start of the mapping */
@@ -216,8 +220,7 @@ static int kgsl_memdesc_add_range(struct kgsl_mem_entry *target,
 	return ret;
 
 error:
-	kgsl_mem_entry_put(range->entry);
-	kfree(range);
+	bind_range_destroy(range);
 	mutex_unlock(&memdesc->ranges_lock);
 	return ret;
 }
@@ -247,12 +250,11 @@ static void kgsl_sharedmem_vbo_put_gpuaddr(struct kgsl_memdesc *memdesc)
 
 		interval_tree_remove(node, &memdesc->ranges);
 
-		/* If unmap failed, mark the child memdesc as still mapped */
-		if (ret)
-			range->entry->memdesc.priv |= KGSL_MEMDESC_MAPPED;
-
-		kgsl_mem_entry_put(range->entry);
-		kfree(range);
+		/* Put the child's refcount if unmap succeeds */
+		if (!ret)
+			bind_range_destroy(range);
+		else
+			kfree(range);
 	}
 
 	if (ret)
-- 
GitLab

