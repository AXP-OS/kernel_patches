From dffa3721f485a35e8e18958a4052146792c92336 Mon Sep 17 00:00:00 2001
From: Lynus Vaz <quic_lvaz@quicinc.com>
Date: Tue, 19 Dec 2023 08:18:11 -0800
Subject: [PATCH] msm: kgsl: Put VBO child refcount if unmap succeeds

If the VBO range cannot be unmapped the underlying physical memory should
not be freed. Enforce this by not decrementing the mem entry's refcount.

Change-Id: Ia9d12589fbfa849ae7e2bef8e1cdbb9cf8f33364
Signed-off-by: Lynus Vaz <quic_lvaz@quicinc.com>
(cherry picked from commit 453be8a3f65eda48da3bf36e11b0c22062565b2c)
---
 kgsl_vbo.c | 33 ++++++++++++++++++++-------------
 1 file changed, 20 insertions(+), 13 deletions(-)

diff --git a/kgsl_vbo.c b/kgsl_vbo.c
index 92d3d84c..a19a01b9 100644
--- a/kgsl_vbo.c
+++ b/kgsl_vbo.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/file.h>
@@ -46,6 +46,12 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
 	return range;
 }
 
+static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
+{
+	kgsl_mem_entry_put(range->entry);
+	kfree(range);
+}
+
 static u64 bind_range_len(struct kgsl_memdesc_bind_range *range)
 {
 	return (range->range.last - range->range.start) + 1;
@@ -114,8 +120,7 @@ static void kgsl_memdesc_remove_range(struct kgsl_mem_entry *target,
 				kgsl_mmu_map_zero_page_to_range(memdesc->pagetable,
 					memdesc, range->range.start, bind_range_len(range));
 
-			kgsl_mem_entry_put(range->entry);
-			kfree(range);
+			bind_range_destroy(range);
 		}
 	}
 
@@ -175,8 +180,7 @@ static int kgsl_memdesc_add_range(struct kgsl_mem_entry *target,
 					}
 				}
 
-				kgsl_mem_entry_put(cur->entry);
-				kfree(cur);
+				bind_range_destroy(cur);
 				continue;
 			}
 
@@ -253,8 +257,7 @@ static int kgsl_memdesc_add_range(struct kgsl_mem_entry *target,
 	return ret;
 
 error:
-	kgsl_mem_entry_put(range->entry);
-	kfree(range);
+	bind_range_destroy(range);
 	mutex_unlock(&memdesc->ranges_lock);
 	return ret;
 }
@@ -264,6 +267,7 @@ static void kgsl_sharedmem_vbo_put_gpuaddr(struct kgsl_memdesc *memdesc)
 	struct interval_tree_node *node, *next;
 	struct kgsl_memdesc_bind_range *range;
 	int ret = 0;
+	bool unmap_fail;
 
 	/*
 	 * If the VBO maps the zero range then we can unmap the entire
@@ -273,6 +277,8 @@ static void kgsl_sharedmem_vbo_put_gpuaddr(struct kgsl_memdesc *memdesc)
 		ret = kgsl_mmu_unmap_range(memdesc->pagetable, memdesc,
 			0, memdesc->size);
 
+	unmap_fail = ret;
+
 	/*
 	 * FIXME: do we have a use after free potential here?  We might need to
 	 * lock this and set a "do not update" bit
@@ -294,15 +300,16 @@ static void kgsl_sharedmem_vbo_put_gpuaddr(struct kgsl_memdesc *memdesc)
 				range->range.start,
 				range->range.last - range->range.start + 1);
 
-		/* If unmap failed, mark the child memdesc as still mapped */
-		if (ret)
-			range->entry->memdesc.priv |= KGSL_MEMDESC_MAPPED;
+		/* Put the child's refcount if unmap succeeds */
+		if (!ret)
+			bind_range_destroy(range);
+		else
+			kfree(range);
 
-		kgsl_mem_entry_put(range->entry);
-		kfree(range);
+		unmap_fail = unmap_fail || ret;
 	}
 
-	if (ret)
+	if (unmap_fail)
 		return;
 
 	/* Put back the GPU address */
-- 
GitLab

