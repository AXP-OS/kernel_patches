From e1f540c022c960bf1583c3f08595f5b8b1e657a4 Mon Sep 17 00:00:00 2001
From: Lynus Vaz <quic_lvaz@quicinc.com>
Date: Fri, 12 Jan 2024 11:16:42 -0800
Subject: [PATCH] msm: kgsl: Do not reclaim pages mapped in a VBO

Pages mapped into a VBO can be accessible both through the memdesc as well
as through the parent VBO. Reclaiming these pages would require a lot of
overhead to update iommu mappings. Instead, do not reclaim the pages of a
memdesc that is currently mapped in a VBO.

Change-Id: Ic2787f09081c5dc3a66c3582b98266937c8ce1e5
Signed-off-by: Lynus Vaz <quic_lvaz@quicinc.com>
(cherry picked from commit e04e0ebcea994fd040706d84430d4420626edb64)
---
 kgsl.c         |  3 ++-
 kgsl.h         |  4 +++-
 kgsl_reclaim.c |  9 ++++++++-
 kgsl_vbo.c     | 15 +++++++++++++--
 4 files changed, 26 insertions(+), 5 deletions(-)

diff --git a/kgsl.c b/kgsl.c
index 249f0ba1..b9aec276 100644
--- a/kgsl.c
+++ b/kgsl.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2008-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <uapi/linux/sched/types.h>
@@ -259,6 +259,7 @@ static struct kgsl_mem_entry *kgsl_mem_entry_create(void)
 		/* put this ref in userspace memory alloc and map ioctls */
 		kref_get(&entry->refcount);
 		atomic_set(&entry->map_count, 0);
+		atomic_set(&entry->vbo_count, 0);
 	}
 
 	return entry;
diff --git a/kgsl.h b/kgsl.h
index 197c9809..cbd00faa 100644
--- a/kgsl.h
+++ b/kgsl.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2008-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 #ifndef __KGSL_H
 #define __KGSL_H
@@ -358,6 +358,8 @@ struct kgsl_mem_entry {
 	 * debugfs accounting
 	 */
 	atomic_t map_count;
+	/** @vbo_count: Count how many VBO ranges this entry is mapped in */
+	atomic_t vbo_count;
 };
 
 struct kgsl_device_private;
diff --git a/kgsl_reclaim.c b/kgsl_reclaim.c
index 91713b76..60823b95 100644
--- a/kgsl_reclaim.c
+++ b/kgsl_reclaim.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/kthread.h>
@@ -267,6 +267,13 @@ static u32 kgsl_reclaim_process(struct kgsl_process_private *process,
 			continue;
 		}
 
+		/* Do not reclaim pages mapped into a VBO */
+		if (atomic_read(&valid_entry->vbo_count)) {
+			kgsl_mem_entry_put(entry);
+			next++;
+			continue;
+		}
+
 		if ((atomic_read(&process->unpinned_page_count) +
 			memdesc->page_count) > kgsl_reclaim_max_page_limit) {
 			kgsl_mem_entry_put(entry);
diff --git a/kgsl_vbo.c b/kgsl_vbo.c
index a19a01b9..bf72c139 100644
--- a/kgsl_vbo.c
+++ b/kgsl_vbo.c
@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
 		return ERR_PTR(-EINVAL);
 	}
 
+	atomic_inc(&entry->vbo_count);
 	return range;
 }
 
 static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
 {
-	kgsl_mem_entry_put(range->entry);
+	struct kgsl_mem_entry *entry = range->entry;
+
+	atomic_dec(&entry->vbo_count);
+	kgsl_mem_entry_put(entry);
 	kfree(range);
 }
 
@@ -361,8 +365,12 @@ static void kgsl_sharedmem_free_bind_op(struct kgsl_sharedmem_bind_op *op)
 	if (IS_ERR_OR_NULL(op))
 		return;
 
-	for (i = 0; i < op->nr_ops; i++)
+	for (i = 0; i < op->nr_ops; i++) {
+		/* Decrement the vbo_count we added when creating the bind_op */
+		if (op->ops[i].entry)
+			atomic_dec(&op->ops[i].entry->vbo_count);
 		kgsl_mem_entry_put(op->ops[i].entry);
+	}
 
 	kgsl_mem_entry_put(op->target);
 
@@ -468,6 +476,9 @@ kgsl_sharedmem_create_bind_op(struct kgsl_process_private *private,
 			goto err;
 		}
 
+		/* Keep the child pinned in memory */
+		atomic_inc(&entry->vbo_count);
+
 		/* Make sure the child is not a VBO */
 		if ((entry->memdesc.flags & KGSL_MEMFLAGS_VBO)) {
 			ret = -EINVAL;
-- 
GitLab

