From bd2c568db101be1b763c651edb2135a5e5da2cf9 Mon Sep 17 00:00:00 2001
From: Hui Li <quic_hul@quicinc.com>
Date: Thu, 29 Feb 2024 18:20:29 +0800
Subject: [PATCH] soc: hgsl: fix race of isync fence release

- In isync timeline destruct, fence move to free list from child list
may happens before child list delete in fence release, after isync
fence released, the fence object may still be accessed in timeline
destruct, there will be a UAF issue.

Check the fence refcount before delete fence from child list in isync
timeline destruct.

- In isync fence create, a malicious user may close the fence fd
right after fd is installed, and the fence release may be invoked
before we add fence to the list, then there will be a UAF issue.

Move the dma_fence_put after add fence to the list.

- Correct the isync fence object free.

Change-Id: Ib1ac7e055d8e8a2ece24d7fd03e4e0a45063f815
Signed-off-by: Hui Li <quic_hul@quicinc.com>
(cherry picked from commit e91a8331f6045334e9892379d727f858f591c528)
---
 drivers/soc/qcom/hgsl/hgsl_sync.c | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/drivers/soc/qcom/hgsl/hgsl_sync.c b/drivers/soc/qcom/hgsl/hgsl_sync.c
index 60b56d73049c8..87d67492a9c90 100644
--- a/drivers/soc/qcom/hgsl/hgsl_sync.c
+++ b/drivers/soc/qcom/hgsl/hgsl_sync.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/types.h>
@@ -376,16 +376,15 @@ int hgsl_isync_fence_create(struct hgsl_priv *priv, uint32_t timeline_id,
 						ts);
 
 	sync_file = sync_file_create(&fence->fence);
-	dma_fence_put(&fence->fence);
 	if (sync_file == NULL) {
 		ret = -ENOMEM;
-		goto out;
+		goto out_fence;
 	}
 
 	*fence_fd = get_unused_fd_flags(0);
 	if (*fence_fd < 0) {
 		ret = -EBADF;
-		goto out;
+		goto out_fence;
 	}
 
 	fd_install(*fence_fd, sync_file->file);
@@ -395,6 +394,8 @@ int hgsl_isync_fence_create(struct hgsl_priv *priv, uint32_t timeline_id,
 	list_add_tail(&fence->child_list, &timeline->fence_list);
 	spin_unlock_irqrestore(&timeline->lock, flags);
 
+out_fence:
+	dma_fence_put(&fence->fence);
 out:
 	if (ret) {
 		if (sync_file)
@@ -420,9 +421,10 @@ static int hgsl_isync_timeline_destruct(struct hgsl_priv *priv,
 	spin_lock_irqsave(&timeline->lock, flags);
 	list_for_each_entry_safe(cur, next, &timeline->fence_list,
 				 child_list) {
-		dma_fence_get(&cur->fence);
-		list_del_init(&cur->child_list);
-		list_add(&cur->free_list, &flist);
+		if (dma_fence_get_rcu(&cur->fence)) {
+			list_del_init(&cur->child_list);
+			list_add(&cur->free_list, &flist);
+		}
 	}
 	spin_unlock_irqrestore(&timeline->lock, flags);
 
@@ -792,7 +794,7 @@ static void hgsl_isync_fence_release(struct dma_fence *base)
 		hgsl_isync_timeline_put(fence->timeline);
 	}
 
-	dma_fence_free(&fence->fence);
+	kfree(fence);
 }
 
 static void hgsl_isync_fence_value_str(struct dma_fence *base,
-- 
GitLab

