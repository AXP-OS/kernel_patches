From cbe1ee01143de0f3cd3692874a1e01135abb9fe0 Mon Sep 17 00:00:00 2001
From: Jilai Wang <quic_jilaiw@quicinc.com>
Date: Tue, 23 Jan 2024 11:51:43 -0500
Subject: [PATCH] msm: npu: Fix OOB issue in IPC between driver and firmware

We shoudn't trust the data from firmware, and need to validate
all content before using them.

Change-Id: I87d71c7723882c012e3ca1d92b75c36dcddc270d
Signed-off-by: Jilai Wang <quic_jilaiw@quicinc.com>
---
 .../media/platform/msm/npu_v2/npu_common.h    |  8 +-
 .../media/platform/msm/npu_v2/npu_debugfs.c   | 80 +------------------
 .../media/platform/msm/npu_v2/npu_host_ipc.c  | 42 ++++++++--
 .../media/platform/msm/npu_v2/npu_hw_access.c | 49 +-----------
 .../media/platform/msm/npu_v2/npu_hw_access.h |  5 +-
 drivers/media/platform/msm/npu_v2/npu_mgr.c   | 66 +++------------
 6 files changed, 49 insertions(+), 201 deletions(-)

diff --git a/drivers/media/platform/msm/npu_v2/npu_common.h b/drivers/media/platform/msm/npu_v2/npu_common.h
index f1b5b30107fcc..e03a08a24a4d5 100644
--- a/drivers/media/platform/msm/npu_v2/npu_common.h
+++ b/drivers/media/platform/msm/npu_v2/npu_common.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022,2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #ifndef _NPU_COMMON_H
@@ -110,12 +110,6 @@ struct npu_debugfs_ctx {
 	struct dentry *root;
 	uint32_t reg_off;
 	uint32_t reg_cnt;
-	uint8_t *log_buf;
-	struct mutex log_lock;
-	uint32_t log_num_bytes_buffered;
-	uint32_t log_read_index;
-	uint32_t log_write_index;
-	uint32_t log_buf_size;
 };
 
 struct npu_debugfs_reg_ctx {
diff --git a/drivers/media/platform/msm/npu_v2/npu_debugfs.c b/drivers/media/platform/msm/npu_v2/npu_debugfs.c
index cae1abb5b45cb..aca352baf9897 100644
--- a/drivers/media/platform/msm/npu_v2/npu_debugfs.c
+++ b/drivers/media/platform/msm/npu_v2/npu_debugfs.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022,2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 /* -------------------------------------------------------------------------
@@ -13,12 +13,6 @@
 #include "npu_hw_access.h"
 #include "npu_common.h"
 
-/* -------------------------------------------------------------------------
- * Defines
- * -------------------------------------------------------------------------
- */
-#define NPU_LOG_BUF_SIZE 4096
-
 /* -------------------------------------------------------------------------
  * Function Prototypes
  * -------------------------------------------------------------------------
@@ -33,8 +27,6 @@ static ssize_t npu_debug_off_write(struct file *file,
 		const char __user *user_buf, size_t count, loff_t *ppos);
 static ssize_t npu_debug_off_read(struct file *file,
 		char __user *user_buf, size_t count, loff_t *ppos);
-static ssize_t npu_debug_log_read(struct file *file,
-		char __user *user_buf, size_t count, loff_t *ppos);
 static ssize_t npu_debug_ctrl_write(struct file *file,
 		const char __user *user_buf, size_t count, loff_t *ppos);
 
@@ -57,13 +49,6 @@ static const struct file_operations npu_off_fops = {
 	.write = npu_debug_off_write,
 };
 
-static const struct file_operations npu_log_fops = {
-	.open = npu_debug_open,
-	.release = npu_debug_release,
-	.read = npu_debug_log_read,
-	.write = NULL,
-};
-
 static const struct file_operations npu_ctrl_fops = {
 	.open = npu_debug_open,
 	.release = npu_debug_release,
@@ -248,48 +233,6 @@ static ssize_t npu_debug_off_read(struct file *file,
 	return len;
 }
 
-/* -------------------------------------------------------------------------
- * Function Implementations - DebugFS Log
- * -------------------------------------------------------------------------
- */
-static ssize_t npu_debug_log_read(struct file *file,
-			char __user *user_buf, size_t count, loff_t *ppos)
-{
-	size_t len = 0;
-	struct npu_device *npu_dev = file->private_data;
-	struct npu_debugfs_ctx *debugfs;
-
-	NPU_DBG("npu_dev %pK %pK\n", npu_dev, g_npu_dev);
-	npu_dev = g_npu_dev;
-	debugfs = &npu_dev->debugfs_ctx;
-
-	/* mutex log lock */
-	mutex_lock(&debugfs->log_lock);
-
-	if (debugfs->log_num_bytes_buffered != 0) {
-		len = min(debugfs->log_num_bytes_buffered,
-			debugfs->log_buf_size - debugfs->log_read_index);
-		len = min(count, len);
-		if (copy_to_user(user_buf, (debugfs->log_buf +
-			debugfs->log_read_index), len)) {
-			NPU_ERR("failed to copy to user\n");
-			mutex_unlock(&debugfs->log_lock);
-			return -EFAULT;
-		}
-		debugfs->log_read_index += len;
-		if (debugfs->log_read_index == debugfs->log_buf_size)
-			debugfs->log_read_index = 0;
-
-		debugfs->log_num_bytes_buffered -= len;
-		*ppos += len;
-	}
-
-	/* mutex log unlock */
-	mutex_unlock(&debugfs->log_lock);
-
-	return len;
-}
-
 /* -------------------------------------------------------------------------
  * Function Implementations - DebugFS Control
  * -------------------------------------------------------------------------
@@ -373,12 +316,6 @@ int npu_debugfs_init(struct npu_device *npu_dev)
 		goto err;
 	}
 
-	if (!debugfs_create_file("log", 0644, debugfs->root,
-		npu_dev, &npu_log_fops)) {
-		NPU_ERR("debugfs_create_file log fail\n");
-		goto err;
-	}
-
 	if (!debugfs_create_file("ctrl", 0644, debugfs->root,
 		npu_dev, &npu_ctrl_fops)) {
 		NPU_ERR("debugfs_create_file ctrl fail\n");
@@ -421,15 +358,6 @@ int npu_debugfs_init(struct npu_device *npu_dev)
 		goto err;
 	}
 
-	debugfs->log_num_bytes_buffered = 0;
-	debugfs->log_read_index = 0;
-	debugfs->log_write_index = 0;
-	debugfs->log_buf_size = NPU_LOG_BUF_SIZE;
-	debugfs->log_buf = kzalloc(debugfs->log_buf_size, GFP_KERNEL);
-	if (!debugfs->log_buf)
-		goto err;
-	mutex_init(&debugfs->log_lock);
-
 	return 0;
 
 err:
@@ -441,12 +369,6 @@ void npu_debugfs_deinit(struct npu_device *npu_dev)
 {
 	struct npu_debugfs_ctx *debugfs = &npu_dev->debugfs_ctx;
 
-	debugfs->log_num_bytes_buffered = 0;
-	debugfs->log_read_index = 0;
-	debugfs->log_write_index = 0;
-	debugfs->log_buf_size = 0;
-	kfree(debugfs->log_buf);
-
 	if (!IS_ERR_OR_NULL(debugfs->root)) {
 		debugfs_remove_recursive(debugfs->root);
 		debugfs->root = NULL;
diff --git a/drivers/media/platform/msm/npu_v2/npu_host_ipc.c b/drivers/media/platform/msm/npu_v2/npu_host_ipc.c
index eadf6bb214e13..540f9bd581d18 100644
--- a/drivers/media/platform/msm/npu_v2/npu_host_ipc.c
+++ b/drivers/media/platform/msm/npu_v2/npu_host_ipc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022,2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 /* -------------------------------------------------------------------------
@@ -31,15 +31,16 @@
 struct npu_queue_tuple {
 	uint32_t size;
 	uint32_t hdr;
+	uint32_t start_offset;
 };
 
-static const struct npu_queue_tuple npu_q_setup[6] = {
-	{ 1024, IPC_QUEUE_CMD_HIGH_PRIORITY | TX_HDR_TYPE | RX_HDR_TYPE },
-	{ 4096, IPC_QUEUE_APPS_EXEC         | TX_HDR_TYPE | RX_HDR_TYPE },
-	{ 4096, IPC_QUEUE_DSP_EXEC          | TX_HDR_TYPE | RX_HDR_TYPE },
-	{ 4096, IPC_QUEUE_APPS_RSP          | TX_HDR_TYPE | RX_HDR_TYPE },
-	{ 4096, IPC_QUEUE_DSP_RSP           | TX_HDR_TYPE | RX_HDR_TYPE },
-	{ 1024, IPC_QUEUE_LOG               | TX_HDR_TYPE | RX_HDR_TYPE },
+static struct npu_queue_tuple npu_q_setup[6] = {
+	{ 1024, IPC_QUEUE_CMD_HIGH_PRIORITY | TX_HDR_TYPE | RX_HDR_TYPE, 0},
+	{ 4096, IPC_QUEUE_APPS_EXEC         | TX_HDR_TYPE | RX_HDR_TYPE, 0},
+	{ 4096, IPC_QUEUE_DSP_EXEC          | TX_HDR_TYPE | RX_HDR_TYPE, 0},
+	{ 4096, IPC_QUEUE_APPS_RSP          | TX_HDR_TYPE | RX_HDR_TYPE, 0},
+	{ 4096, IPC_QUEUE_DSP_RSP           | TX_HDR_TYPE | RX_HDR_TYPE, 0},
+	{ 1024, IPC_QUEUE_LOG               | TX_HDR_TYPE | RX_HDR_TYPE, 0},
 };
 
 /* -------------------------------------------------------------------------
@@ -111,6 +112,7 @@ static int npu_host_ipc_init_hfi(struct npu_device *npu_dev)
 		/* queue is active */
 		q_hdr->qhdr_status = 0x01;
 		q_hdr->qhdr_start_offset = cur_start_offset;
+		npu_q_setup[q_idx].start_offset = cur_start_offset;
 		q_size = npu_q_setup[q_idx].size;
 		q_hdr->qhdr_type = npu_q_setup[q_idx].hdr;
 		/* in bytes */
@@ -217,6 +219,18 @@ static int ipc_queue_read(struct npu_device *npu_dev,
 	/* Read the queue */
 	MEMR(npu_dev, (void *)((size_t)offset), (uint8_t *)&queue,
 		HFI_QUEUE_HEADER_SIZE);
+
+	if (queue.qhdr_type != npu_q_setup[target_que].hdr ||
+		queue.qhdr_q_size != npu_q_setup[target_que].size ||
+		queue.qhdr_read_idx >= queue.qhdr_q_size ||
+		queue.qhdr_write_idx >= queue.qhdr_q_size ||
+		queue.qhdr_start_offset !=
+			npu_q_setup[target_que].start_offset) {
+		NPU_ERR("Invalid Queue header\n");
+		status = -EIO;
+		goto exit;
+	}
+
 	/* check if queue is empty */
 	if (queue.qhdr_read_idx == queue.qhdr_write_idx) {
 		/*
@@ -314,6 +328,18 @@ static int ipc_queue_write(struct npu_device *npu_dev,
 
 	MEMR(npu_dev, (void *)((size_t)offset), (uint8_t *)&queue,
 		HFI_QUEUE_HEADER_SIZE);
+
+	if (queue.qhdr_type != npu_q_setup[target_que].hdr ||
+		queue.qhdr_q_size != npu_q_setup[target_que].size ||
+		queue.qhdr_read_idx >= queue.qhdr_q_size ||
+		queue.qhdr_write_idx >= queue.qhdr_q_size ||
+		queue.qhdr_start_offset !=
+			npu_q_setup[target_que].start_offset) {
+		NPU_ERR("Invalid Queue header\n");
+		status = -EIO;
+		goto exit;
+	}
+
 	packet_size = (*(uint32_t *)packet);
 	if (packet_size == 0) {
 		/* assign failed status and return */
diff --git a/drivers/media/platform/msm/npu_v2/npu_hw_access.c b/drivers/media/platform/msm/npu_v2/npu_hw_access.c
index e25e44e48f266..23706830d0d4b 100644
--- a/drivers/media/platform/msm/npu_v2/npu_hw_access.c
+++ b/drivers/media/platform/msm/npu_v2/npu_hw_access.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022,2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 /* -------------------------------------------------------------------------
@@ -430,50 +430,3 @@ void subsystem_put_local(void *sub_system_handle)
 {
 	return subsystem_put(sub_system_handle);
 }
-
-/* -------------------------------------------------------------------------
- * Functions - Log
- * -------------------------------------------------------------------------
- */
-void npu_process_log_message(struct npu_device *npu_dev, uint32_t *message,
-	uint32_t size)
-{
-	struct npu_debugfs_ctx *debugfs = &npu_dev->debugfs_ctx;
-
-	/* mutex log lock */
-	mutex_lock(&debugfs->log_lock);
-
-	if ((debugfs->log_num_bytes_buffered + size) >
-		debugfs->log_buf_size) {
-		/* No more space, invalidate it all and start over */
-		debugfs->log_read_index = 0;
-		debugfs->log_write_index = size;
-		debugfs->log_num_bytes_buffered = size;
-		memcpy(debugfs->log_buf, message, size);
-	} else {
-		if ((debugfs->log_write_index + size) >
-			debugfs->log_buf_size) {
-			/* Wrap around case */
-			uint8_t *src_addr = (uint8_t *)message;
-			uint8_t *dst_addr = 0;
-			uint32_t remaining_to_end = debugfs->log_buf_size -
-				debugfs->log_write_index + 1;
-			dst_addr = debugfs->log_buf + debugfs->log_write_index;
-			memcpy(dst_addr, src_addr, remaining_to_end);
-			src_addr = &(src_addr[remaining_to_end]);
-			dst_addr = debugfs->log_buf;
-			memcpy(dst_addr, src_addr, size-remaining_to_end);
-			debugfs->log_write_index = size-remaining_to_end;
-		} else {
-			memcpy((debugfs->log_buf + debugfs->log_write_index),
-				message, size);
-			debugfs->log_write_index += size;
-			if (debugfs->log_write_index == debugfs->log_buf_size)
-				debugfs->log_write_index = 0;
-		}
-		debugfs->log_num_bytes_buffered += size;
-	}
-
-	/* mutex log unlock */
-	mutex_unlock(&debugfs->log_lock);
-}
diff --git a/drivers/media/platform/msm/npu_v2/npu_hw_access.h b/drivers/media/platform/msm/npu_v2/npu_hw_access.h
index 03df54dfb7683..4736fa82031dc 100644
--- a/drivers/media/platform/msm/npu_v2/npu_hw_access.h
+++ b/drivers/media/platform/msm/npu_v2/npu_hw_access.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022,2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #ifndef _NPU_HW_ACCESS_H
@@ -86,7 +86,4 @@ void npu_disable_sys_cache(struct npu_device *npu_dev);
 void *subsystem_get_local(char *sub_system);
 void subsystem_put_local(void *sub_system_handle);
 
-void npu_process_log_message(struct npu_device *npu_dev, uint32_t *msg,
-	uint32_t size);
-
 #endif /* _NPU_HW_ACCESS_H*/
diff --git a/drivers/media/platform/msm/npu_v2/npu_mgr.c b/drivers/media/platform/msm/npu_v2/npu_mgr.c
index b39a988c48555..2611ce04821c1 100644
--- a/drivers/media/platform/msm/npu_v2/npu_mgr.c
+++ b/drivers/media/platform/msm/npu_v2/npu_mgr.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 /* -------------------------------------------------------------------------
@@ -17,15 +17,6 @@
 #include <soc/qcom/subsystem_restart.h>
 #include <linux/reboot.h>
 
-/* -------------------------------------------------------------------------
- * Defines
- * -------------------------------------------------------------------------
- */
-#define LOG_MSG_HEADER_SIZE      20
-#define LOG_MSG_START_MSG_INDEX  5
-#define LOG_MSG_TOTAL_SIZE_INDEX 0
-#define LOG_MSG_MSG_ID_INDEX     1
-
 /* -------------------------------------------------------------------------
  * File Scope Function Prototypes
  * -------------------------------------------------------------------------
@@ -51,9 +42,7 @@ static void free_network(struct npu_host_ctx *ctx, struct npu_client *client,
 static int network_get(struct npu_network *network);
 static int network_put(struct npu_network *network);
 static int app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg);
-static void log_msg_proc(struct npu_device *npu_dev, uint32_t *msg);
 static void host_session_msg_hdlr(struct npu_device *npu_dev);
-static void host_session_log_hdlr(struct npu_device *npu_dev);
 static int host_error_hdlr(struct npu_device *npu_dev, bool force);
 static int npu_send_network_cmd(struct npu_device *npu_dev,
 	struct npu_network *network, void *cmd_ptr,
@@ -1154,7 +1143,6 @@ static void npu_ipc_irq_work(struct work_struct *work)
 	host_ctx = container_of(work, struct npu_host_ctx, ipc_irq_work);
 	npu_dev = container_of(host_ctx, struct npu_device, host_ctx);
 
-	host_session_log_hdlr(npu_dev);
 	host_session_msg_hdlr(npu_dev);
 }
 
@@ -1689,6 +1677,12 @@ static int app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg)
 		}
 
 		NPU_DBG("network id : %lld\n", network->id);
+		if (exe_rsp_pkt->header.size < sizeof(*exe_rsp_pkt)) {
+			NPU_ERR("invalid packet header size, header.size: %d",
+				exe_rsp_pkt->header.size);
+			network_put(network);
+			break;
+		}
 		stats_size = exe_rsp_pkt->header.size - sizeof(*exe_rsp_pkt);
 		NPU_DBG("stats_size %d:%d\n", exe_rsp_pkt->header.size,
 			stats_size);
@@ -1930,47 +1924,6 @@ static void host_session_msg_hdlr(struct npu_device *npu_dev)
 	mutex_unlock(&host_ctx->lock);
 }
 
-static void log_msg_proc(struct npu_device *npu_dev, uint32_t *msg)
-{
-	uint32_t msg_id;
-	uint32_t *log_msg;
-	uint32_t size;
-
-	msg_id = msg[LOG_MSG_MSG_ID_INDEX];
-	size = msg[LOG_MSG_TOTAL_SIZE_INDEX] - LOG_MSG_HEADER_SIZE;
-
-	switch (msg_id) {
-	case NPU_IPC_MSG_EVENT_NOTIFY:
-		/* Process the message */
-		log_msg = &(msg[LOG_MSG_START_MSG_INDEX]);
-		npu_process_log_message(npu_dev, log_msg, size);
-		break;
-	default:
-		NPU_ERR("unsupported log response received %d\n", msg_id);
-		break;
-	}
-}
-
-static void host_session_log_hdlr(struct npu_device *npu_dev)
-{
-	struct npu_host_ctx *host_ctx = &npu_dev->host_ctx;
-
-	mutex_lock(&host_ctx->lock);
-	if (host_ctx->fw_state != FW_ENABLED) {
-		NPU_WARN("handle npu session msg when FW is disabled\n");
-		goto skip_read_msg;
-	}
-
-	while (npu_host_ipc_read_msg(npu_dev, IPC_QUEUE_LOG,
-		host_ctx->ipc_msg_buf) == 0) {
-		NPU_DBG("received from log queue\n");
-		log_msg_proc(npu_dev, host_ctx->ipc_msg_buf);
-	}
-
-skip_read_msg:
-	mutex_unlock(&host_ctx->lock);
-}
-
 /* -------------------------------------------------------------------------
  * Function Definitions - Functionality
  * -------------------------------------------------------------------------
@@ -2368,7 +2321,10 @@ int32_t npu_host_get_fw_property(struct npu_device *npu_dev,
 		NPU_ERR("prop_id: %x\n", prop_from_fw->prop_id);
 		NPU_ERR("network_hdl: %x\n", prop_from_fw->network_hdl);
 		NPU_ERR("param_num: %x\n", prop_from_fw->num_of_params);
-		for (i = 0; i < prop_from_fw->num_of_params; i++)
+		num_of_params = min_t(uint32_t,
+			prop_from_fw->num_of_params,
+			(uint32_t)PROP_PARAM_MAX_SIZE);
+		for (i = 0; i < num_of_params; i++)
 			NPU_ERR("%x\n", prop_from_fw->prop_param[i]);
 	}
 
-- 
GitLab

