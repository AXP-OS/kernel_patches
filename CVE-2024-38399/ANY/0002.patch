From 8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e Mon Sep 17 00:00:00 2001
From: Sanjay Yadav <quic_sanjyada@quicinc.com>
Date: Mon, 15 Apr 2024 17:32:12 +0530
Subject: [PATCH] msm: kgsl: Hold fault lock while accessing context faults

Currently, there is no lock held while accessing context
faults during the fault report IOCTL. This could introduce
a race which can lead to use after free. Thus, hold fault
lock while accessing context faults.

Change-Id: I09cbda15de3f3fc1074d5ec3e4b7b5daf211fe4a
Signed-off-by: Kamal Agrawal <quic_kamaagra@quicinc.com>
Signed-off-by: Sanjay Yadav <quic_sanjyada@quicinc.com>
---
 drivers/gpu/msm/kgsl.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index c606bca1eb4ef..398abd77304db 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -3877,6 +3877,8 @@ static int kgsl_update_fault_details(struct kgsl_context *context,
 		memcpy(&faults[fault.type], &fault, sizeof(fault));
 	}
 
+	mutex_lock(&context->fault_lock);
+
 	list_for_each_entry(fault_node, &context->faults, node) {
 		u32 fault_type = fault_node->type;
 
@@ -3894,12 +3896,15 @@ static int kgsl_update_fault_details(struct kgsl_context *context,
 			cur_idx[fault_type] * faults[fault_type].size),
 			fault_node->priv, size)) {
 			ret = -EFAULT;
-			goto err;
+			goto release_lock;
 		}
 
 		cur_idx[fault_type] += 1;
 	}
 
+release_lock:
+	mutex_unlock(&context->fault_lock);
+
 err:
 	kfree(faults);
 	return ret;
@@ -3913,8 +3918,10 @@ static int kgsl_update_fault_count(struct kgsl_context *context,
 	struct kgsl_fault_node *fault_node;
 	int i, j;
 
+	mutex_lock(&context->fault_lock);
 	list_for_each_entry(fault_node, &context->faults, node)
 		faultcount[fault_node->type]++;
+	mutex_unlock(&context->fault_lock);
 
 	/* KGSL_FAULT_TYPE_NO_FAULT (i.e. 0) is not an actual fault type */
 	for (i = 0, j = 1; i < faultnents && j < KGSL_FAULT_TYPE_MAX; j++) {
-- 
GitLab

