From 467ba29f0c8f6e6c17971795ebdce90a1d5d6fc6 Mon Sep 17 00:00:00 2001
From: Kamal Agrawal <quic_kamaagra@quicinc.com>
Date: Wed, 20 Mar 2024 00:16:31 +0530
Subject: [PATCH] msm: kgsl: Hold fault lock while accessing context faults

Currently, there is no lock held while accessing context
faults during the fault report IOCTL. This could introduce
a race which can lead to use after free. Thus, hold fault
lock while accessing context faults.

Change-Id: I09cbda15de3f3fc1074d5ec3e4b7b5daf211fe4a
Signed-off-by: Kamal Agrawal <quic_kamaagra@quicinc.com>
(cherry picked from commit 4485497a428a86916746b7a19bb70d3b77192597)
---
 kgsl.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/kgsl.c b/kgsl.c
index 78eb389b..9dcc774f 100644
--- a/kgsl.c
+++ b/kgsl.c
@@ -3838,6 +3838,8 @@ static int kgsl_update_fault_details(struct kgsl_context *context,
 		memcpy(&faults[fault.type], &fault, sizeof(fault));
 	}
 
+	mutex_lock(&context->fault_lock);
+
 	list_for_each_entry(fault_node, &context->faults, node) {
 		u32 fault_type = fault_node->type;
 
@@ -3855,12 +3857,15 @@ static int kgsl_update_fault_details(struct kgsl_context *context,
 			cur_idx[fault_type] * faults[fault_type].size),
 			fault_node->priv, size)) {
 			ret = -EFAULT;
-			goto err;
+			goto release_lock;
 		}
 
 		cur_idx[fault_type] += 1;
 	}
 
+release_lock:
+	mutex_unlock(&context->fault_lock);
+
 err:
 	kfree(faults);
 	return ret;
@@ -3874,8 +3879,10 @@ static int kgsl_update_fault_count(struct kgsl_context *context,
 	struct kgsl_fault_node *fault_node;
 	int i, j;
 
+	mutex_lock(&context->fault_lock);
 	list_for_each_entry(fault_node, &context->faults, node)
 		faultcount[fault_node->type]++;
+	mutex_unlock(&context->fault_lock);
 
 	/* KGSL_FAULT_TYPE_NO_FAULT (i.e. 0) is not an actual fault type */
 	for (i = 0, j = 1; i < faultnents && j < KGSL_FAULT_TYPE_MAX; j++) {
-- 
GitLab

