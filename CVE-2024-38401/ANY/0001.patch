From ebfb213db41929f33636158ec3ed1b13cf9880bd Mon Sep 17 00:00:00 2001
From: Chris Lew <quic_clew@quicinc.com>
Date: Tue, 25 Jun 2024 21:40:03 -0700
Subject: [PATCH] net: qrtr: bpf_service: Fix rcu logic

RCU locks still require the updating of the object to be protected by
locks or semaphores. Add a new lock to ensure writes to the bpf_filter
pointer cannot race against each other.

Expand the rcu_read_locks to ensure they are held during all places
where the bpf_filter pointer is being used. This will ensure that
references are properly accounted for and can be synchronized on before
attempting to free the filter in the detach ioctl.

Change-Id: Ib4a9d6e3b44fa6253164c50f52c627e64941baea
Signed-off-by: Chris Lew <quic_clew@quicinc.com>
---
 net/qrtr/bpf_service.c | 89 +++++++++++++++++++++++-------------------
 1 file changed, 49 insertions(+), 40 deletions(-)

diff --git a/net/qrtr/bpf_service.c b/net/qrtr/bpf_service.c
index dfee88eed890f..eebc6ddc1d996 100644
--- a/net/qrtr/bpf_service.c
+++ b/net/qrtr/bpf_service.c
@@ -35,6 +35,9 @@ static DEFINE_MUTEX(service_lookup_lock);
 /* variable to hold bpf filter object */
 static struct sk_filter __rcu *bpf_filter;
 
+/* mutex to lock when updating bpf_filter pointer */
+static DEFINE_MUTEX(bpf_filter_update_lock);
+
 /**
  * Add service information (service id & instance id) to lookup table
  * with key as node & port id pair
@@ -143,26 +146,35 @@ int qrtr_bpf_filter_attach(int ufd)
 	if (ufd < 0)
 		return -EINVAL;
 
-	/* return -EEXIST if ebpf filter is already attached */
-	if (bpf_filter)
-		return -EEXIST;
-
 	if (!(in_egroup_p(AID_VENDOR_QRTR) ||
 	      in_egroup_p(GLOBAL_ROOT_GID)))
 		return -EPERM;
 
+	/* return -EEXIST if ebpf filter is already attached */
+	mutex_lock(&bpf_filter_update_lock);
+	if (bpf_filter) {
+		rc = -EEXIST;
+		goto out;
+	}
+
 	prog = bpf_prog_get_type(ufd, BPF_PROG_TYPE_SOCKET_FILTER);
-	if (prog) {
-		pr_info("%s bpf filter with fd %d attached with qrtr\n",
-			__func__, ufd);
-		filter = kzalloc(sizeof(*bpf_filter), GFP_KERNEL);
-		if (!filter)
-			return -ENOMEM;
-		filter->prog = prog;
-		rcu_assign_pointer(bpf_filter, filter);
-	} else {
+	if (!prog) {
 		rc = -EFAULT;
+		goto out;
+	}
+	pr_info("%s bpf filter with fd %d attached with qrtr\n", __func__, ufd);
+
+	filter = kzalloc(sizeof(*bpf_filter), GFP_KERNEL);
+	if (!filter) {
+		rc = -ENOMEM;
+		bpf_prog_put(prog);
+		goto out;
 	}
+	filter->prog = prog;
+	rcu_assign_pointer(bpf_filter, filter);
+
+out:
+	mutex_unlock(&bpf_filter_update_lock);
 
 	return rc;
 }
@@ -172,22 +184,22 @@ EXPORT_SYMBOL(qrtr_bpf_filter_attach);
 int qrtr_bpf_filter_detach(void)
 {
 	struct sk_filter *filter = NULL;
-	int rc = -EFAULT;
 
-	rcu_read_lock();
-	filter = rcu_dereference(bpf_filter);
-	rcu_read_unlock();
+	mutex_lock(&bpf_filter_update_lock);
+	filter = rcu_replace_pointer(bpf_filter, NULL,
+				     mutex_is_locked(&bpf_filter_update_lock));
+	mutex_unlock(&bpf_filter_update_lock);
 
-	if (filter && filter->prog) {
-		pr_info("%s bpf filter program detached\n",
-			__func__);
-		bpf_filter = NULL;
-		bpf_prog_put(filter->prog);
-		kfree(filter);
-		rc = 0;
-	}
+	synchronize_rcu();
+	if (!filter)
+		return -EFAULT;
 
-	return rc;
+	pr_info("%s bpf filter program detached\n", __func__);
+
+	bpf_prog_put(filter->prog);
+	kfree(filter);
+
+	return 0;
 }
 EXPORT_SYMBOL(qrtr_bpf_filter_detach);
 
@@ -206,6 +218,7 @@ int qrtr_run_bpf_filter(struct sk_buff *skb, u32 service_id, u32 instance_id,
 	kuid_t euid;
 	kgid_t egid;
 	uid_t kgid;
+	u32 status;
 	int i = 0;
 
 	/* populate filter argument with service & pkt type information */
@@ -243,7 +256,9 @@ int qrtr_run_bpf_filter(struct sk_buff *skb, u32 service_id, u32 instance_id,
 	}
 
 	/* Run bpf filter program if it is already attached */
-	if (bpf_filter) {
+	rcu_read_lock();
+	filter = rcu_dereference(bpf_filter);
+	if (filter) {
 		/**
 		 * Allocate dummy skb to pass required arguments to bpf
 		 * filter program
@@ -255,19 +270,12 @@ int qrtr_run_bpf_filter(struct sk_buff *skb, u32 service_id, u32 instance_id,
 			       BPF_DATA_SIZE);
 
 			/* execute eBPF filter here */
-			rcu_read_lock();
-			filter = rcu_dereference(bpf_filter);
-			if (filter) {
-				u32 status;
-				/**
-				 * Deny/grant permission based on return
-				 * value of the filter
-				 */
-				status = bpf_prog_run_save_cb(filter->prog,
-							      skb_bpf);
-				err = status ? 0 : -EPERM;
-			}
-			rcu_read_unlock();
+			status = bpf_prog_run_save_cb(filter->prog, skb_bpf);
+			/**
+			 * Deny/grant permission based on return
+			 * value of the filter
+			 */
+			err = status ? 0 : -EPERM;
 			kfree_skb(skb_bpf);
 			if (err) {
 				if (pkt_type == QRTR_TYPE_DATA)
@@ -281,6 +289,7 @@ int qrtr_run_bpf_filter(struct sk_buff *skb, u32 service_id, u32 instance_id,
 			}
 		}
 	}
+	rcu_read_unlock();
 
 	return err;
 }
-- 
GitLab

