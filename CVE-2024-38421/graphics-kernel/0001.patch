From 38c77d8ee7df7a0379a5f3361ed251057f40d6b0 Mon Sep 17 00:00:00 2001
From: Harshdeep Dhatt <quic_hdhatt@quicinc.com>
Date: Wed, 22 May 2024 13:41:07 -0600
Subject: [PATCH] kgsl: hwfence:  Take context reference in
 drain_guilty_context_hw_fences

Say, a context is invalidated, and we drain all its hardware
fences in drawctxt->hw_fence_list as part of recovery sequence.
However, the KGSL_CONTEXT_PRIV_INVALID remains set. Say, as part
of replay, another context causes a GPU fault and we again run
recovery. If the invalidated context has not been destroyed yet,
after recovery we will again get a handle to that context. And
say if context gets destroyed concurrently, we will end up
de-referencing invalid drawctxt->hw_fence_list pointer. To fix this,
try to take context reference before de-referencing
drawctxt->hw_fence_list. In case the context is in the middle of
getting destroyed, but hasn't been removed from the
device->context_idr, _kgsl_context_get() will fail and avoid
de-referencing the invalid drawctxt->hw_fence_list pointer.

Change-Id: I93d8b7ad23c8cd6a805ed82a70b1b573f15c79ae
Signed-off-by: Harshdeep Dhatt <quic_hdhatt@quicinc.com>
---
 adreno_gen7_hwsched.c | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/adreno_gen7_hwsched.c b/adreno_gen7_hwsched.c
index 015d9366..ab865a32 100644
--- a/adreno_gen7_hwsched.c
+++ b/adreno_gen7_hwsched.c
@@ -1562,11 +1562,12 @@ static int drain_guilty_context_hw_fences(struct adreno_device *adreno_dev)
 	struct kgsl_device *device = KGSL_DEVICE(adreno_dev);
 	struct kgsl_context *context = NULL;
 	struct adreno_context *guilty = NULL;
-	int id;
+	int id, ret = 0;
 
 	read_lock(&device->context_lock);
 	idr_for_each_entry(&device->context_idr, context, id) {
-		if (test_bit(KGSL_CONTEXT_PRIV_INVALID, &context->priv)) {
+		if (test_bit(KGSL_CONTEXT_PRIV_INVALID, &context->priv) &&
+			_kgsl_context_get(context)) {
 			guilty = ADRENO_CONTEXT(context);
 			break;
 		}
@@ -1576,7 +1577,16 @@ static int drain_guilty_context_hw_fences(struct adreno_device *adreno_dev)
 	if (!guilty)
 		return 0;
 
-	return gen7_hwsched_drain_context_hw_fences(adreno_dev, guilty);
+	/*
+	 * We don't need drawctxt spinlock to signal these fences since the only other place
+	 * which can access these fences is the context detach path and device mutex
+	 * ensures mutual exclusion between recovery thread and detach thread.
+	 */
+	ret = gen7_hwsched_drain_context_hw_fences(adreno_dev, guilty);
+
+	kgsl_context_put(&guilty->base);
+
+	return ret;
 }
 
 static int handle_hw_fences_after_reset(struct adreno_device *adreno_dev)
-- 
GitLab

